/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(){function n(n,t,r){switch(r.length){case 0:return n.call(t);case 1:return n.call(t,r[0]);case 2:return n.call(t,r[0],r[1]);case 3:return n.call(t,r[0],r[1],r[2])}return n.apply(t,r)}function t(n,t,r,e){for(var u=-1,i=null==n?0:n.length;++u<i;){var o=n[u];t(e,o,r(o),n)}return e}function r(n,t){for(var r=-1,e=null==n?0:n.length;++r<e&&t(n[r],r,n)!==!1;);return n}function e(n,t){for(var r=null==n?0:n.length;r--&&t(n[r],r,n)!==!1;);return n}function u(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(!t(n[r],r,n))return!1;
return!0}function i(n,t){for(var r=-1,e=null==n?0:n.length,u=0,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[u++]=o)}return i}function o(n,t){return!!(null==n?0:n.length)&&y(n,t,0)>-1}function f(n,t,r){for(var e=-1,u=null==n?0:n.length;++e<u;)if(r(t,n[e]))return!0;return!1}function c(n,t){for(var r=-1,e=null==n?0:n.length,u=Array(e);++r<e;)u[r]=t(n[r],r,n);return u}function a(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];return n}function l(n,t,r,e){var u=-1,i=null==n?0:n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);
return r}function s(n,t,r,e){var u=null==n?0:n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function h(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(t(n[r],r,n))return!0;return!1}function p(n){return n.split("")}function _(n){return n.match(Bt)||[]}function v(n,t,r){var e;return r(n,function(n,r,u){if(t(n,r,u))return e=r,!1}),e}function g(n,t,r,e){for(var u=n.length,i=r+(e?1:-1);e?i--:++i<u;)if(t(n[i],i,n))return i;return-1}function y(n,t,r){return t===t?q(n,t,r):g(n,b,r)}function d(n,t,r,e){
for(var u=r-1,i=n.length;++u<i;)if(e(n[u],t))return u;return-1}function b(n){return n!==n}function w(n,t){var r=null==n?0:n.length;return r?k(n,t)/r:Sn}function m(n){return function(t){return null==t?Y:t[n]}}function x(n){return function(t){return null==n?Y:n[t]}}function j(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=!1,n):t(r,n,u,i)}),r}function A(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].value;return n}function k(n,t){for(var r,e=-1,u=n.length;++e<u;){var i=t(n[e]);i!==Y&&(r=r===Y?i:r+i);
}return r}function O(n,t){for(var r=-1,e=Array(n);++r<n;)e[r]=t(r);return e}function I(n,t){return c(t,function(t){return[t,n[t]]})}function R(n){return function(t){return n(t)}}function z(n,t){return c(t,function(t){return n[t]})}function E(n,t){return n.has(t)}function S(n,t){for(var r=-1,e=n.length;++r<e&&y(t,n[r],0)>-1;);return r}function W(n,t){for(var r=n.length;r--&&y(t,n[r],0)>-1;);return r}function L(n,t){for(var r=n.length,e=0;r--;)n[r]===t&&++e;return e}function C(n){return"\\"+Gr[n]}function U(n,t){
return null==n?Y:n[t]}function B(n){return Dr.test(n)}function T(n){return Mr.test(n)}function $(n){for(var t,r=[];!(t=n.next()).done;)r.push(t.value);return r}function D(n){var t=-1,r=Array(n.size);return n.forEach(function(n,e){r[++t]=[e,n]}),r}function M(n,t){return function(r){return n(t(r))}}function F(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r];o!==t&&o!==un||(n[r]=un,i[u++]=r)}return i}function N(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=n}),r}function P(n){
var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=[n,n]}),r}function q(n,t,r){for(var e=r-1,u=n.length;++e<u;)if(n[e]===t)return e;return-1}function Z(n,t,r){for(var e=r+1;e--;)if(n[e]===t)return e;return e}function K(n){return B(n)?G(n):se(n)}function V(n){return B(n)?H(n):p(n)}function G(n){for(var t=Tr.lastIndex=0;Tr.test(n);)++t;return t}function H(n){return n.match(Tr)||[]}function J(n){return n.match($r)||[]}var Y,Q="4.17.20",X=200,nn="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",tn="Expected a function",rn="__lodash_hash_undefined__",en=500,un="__lodash_placeholder__",on=1,fn=2,cn=4,an=1,ln=2,sn=1,hn=2,pn=4,_n=8,vn=16,gn=32,yn=64,dn=128,bn=256,wn=512,mn=30,xn="...",jn=800,An=16,kn=1,On=2,In=3,Rn=1/0,zn=9007199254740991,En=1.7976931348623157e308,Sn=NaN,Wn=4294967295,Ln=Wn-1,Cn=Wn>>>1,Un=[["ary",dn],["bind",sn],["bindKey",hn],["curry",_n],["curryRight",vn],["flip",wn],["partial",gn],["partialRight",yn],["rearg",bn]],Bn="[object Arguments]",Tn="[object Array]",$n="[object AsyncFunction]",Dn="[object Boolean]",Mn="[object Date]",Fn="[object DOMException]",Nn="[object Error]",Pn="[object Function]",qn="[object GeneratorFunction]",Zn="[object Map]",Kn="[object Number]",Vn="[object Null]",Gn="[object Object]",Hn="[object Promise]",Jn="[object Proxy]",Yn="[object RegExp]",Qn="[object Set]",Xn="[object String]",nt="[object Symbol]",tt="[object Undefined]",rt="[object WeakMap]",et="[object WeakSet]",ut="[object ArrayBuffer]",it="[object DataView]",ot="[object Float32Array]",ft="[object Float64Array]",ct="[object Int8Array]",at="[object Int16Array]",lt="[object Int32Array]",st="[object Uint8Array]",ht="[object Uint8ClampedArray]",pt="[object Uint16Array]",_t="[object Uint32Array]",vt=/\b__p \+= '';/g,gt=/\b(__p \+=) '' \+/g,yt=/(__e\(.*?\)|\b__t\)) \+\n'';/g,dt=/&(?:amp|lt|gt|quot|#39);/g,bt=/[&<>"']/g,wt=RegExp(dt.source),mt=RegExp(bt.source),xt=/<%-([\s\S]+?)%>/g,jt=/<%([\s\S]+?)%>/g,At=/<%=([\s\S]+?)%>/g,kt=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Ot=/^\w*$/,It=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Rt=/[\\^$.*+?()[\]{}|]/g,zt=RegExp(Rt.source),Et=/^\s+|\s+$/g,St=/^\s+/,Wt=/\s+$/,Lt=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,Ct=/\{\n\/\* \[wrapped with (.+)\] \*/,Ut=/,? & /,Bt=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,Tt=/\\(\\)?/g,$t=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Dt=/\w*$/,Mt=/^[-+]0x[0-9a-f]+$/i,Ft=/^0b[01]+$/i,Nt=/^\[object .+?Constructor\]$/,Pt=/^0o[0-7]+$/i,qt=/^(?:0|[1-9]\d*)$/,Zt=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,Kt=/($^)/,Vt=/['\n\r\u2028\u2029\\]/g,Gt="\\ud800-\\udfff",Ht="\\u0300-\\u036f",Jt="\\ufe20-\\ufe2f",Yt="\\u20d0-\\u20ff",Qt=Ht+Jt+Yt,Xt="\\u2700-\\u27bf",nr="a-z\\xdf-\\xf6\\xf8-\\xff",tr="\\xac\\xb1\\xd7\\xf7",rr="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",er="\\u2000-\\u206f",ur=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",ir="A-Z\\xc0-\\xd6\\xd8-\\xde",or="\\ufe0e\\ufe0f",fr=tr+rr+er+ur,cr="['\u2019]",ar="["+Gt+"]",lr="["+fr+"]",sr="["+Qt+"]",hr="\\d+",pr="["+Xt+"]",_r="["+nr+"]",vr="[^"+Gt+fr+hr+Xt+nr+ir+"]",gr="\\ud83c[\\udffb-\\udfff]",yr="(?:"+sr+"|"+gr+")",dr="[^"+Gt+"]",br="(?:\\ud83c[\\udde6-\\uddff]){2}",wr="[\\ud800-\\udbff][\\udc00-\\udfff]",mr="["+ir+"]",xr="\\u200d",jr="(?:"+_r+"|"+vr+")",Ar="(?:"+mr+"|"+vr+")",kr="(?:"+cr+"(?:d|ll|m|re|s|t|ve))?",Or="(?:"+cr+"(?:D|LL|M|RE|S|T|VE))?",Ir=yr+"?",Rr="["+or+"]?",zr="(?:"+xr+"(?:"+[dr,br,wr].join("|")+")"+Rr+Ir+")*",Er="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",Sr="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",Wr=Rr+Ir+zr,Lr="(?:"+[pr,br,wr].join("|")+")"+Wr,Cr="(?:"+[dr+sr+"?",sr,br,wr,ar].join("|")+")",Ur=RegExp(cr,"g"),Br=RegExp(sr,"g"),Tr=RegExp(gr+"(?="+gr+")|"+Cr+Wr,"g"),$r=RegExp([mr+"?"+_r+"+"+kr+"(?="+[lr,mr,"$"].join("|")+")",Ar+"+"+Or+"(?="+[lr,mr+jr,"$"].join("|")+")",mr+"?"+jr+"+"+kr,mr+"+"+Or,Sr,Er,hr,Lr].join("|"),"g"),Dr=RegExp("["+xr+Gt+Qt+or+"]"),Mr=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Fr=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],Nr=-1,Pr={};
Pr[ot]=Pr[ft]=Pr[ct]=Pr[at]=Pr[lt]=Pr[st]=Pr[ht]=Pr[pt]=Pr[_t]=!0,Pr[Bn]=Pr[Tn]=Pr[ut]=Pr[Dn]=Pr[it]=Pr[Mn]=Pr[Nn]=Pr[Pn]=Pr[Zn]=Pr[Kn]=Pr[Gn]=Pr[Yn]=Pr[Qn]=Pr[Xn]=Pr[rt]=!1;var qr={};qr[Bn]=qr[Tn]=qr[ut]=qr[it]=qr[Dn]=qr[Mn]=qr[ot]=qr[ft]=qr[ct]=qr[at]=qr[lt]=qr[Zn]=qr[Kn]=qr[Gn]=qr[Yn]=qr[Qn]=qr[Xn]=qr[nt]=qr[st]=qr[ht]=qr[pt]=qr[_t]=!0,qr[Nn]=qr[Pn]=qr[rt]=!1;var Zr={"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a",
"\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xcc":"I","\xcd":"I","\xce":"I","\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y","\xfd":"y","\xff":"y","\xc6":"Ae",
"\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss","\u0100":"A","\u0102":"A","\u0104":"A","\u0101":"a","\u0103":"a","\u0105":"a","\u0106":"C","\u0108":"C","\u010a":"C","\u010c":"C","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\u010e":"D","\u0110":"D","\u010f":"d","\u0111":"d","\u0112":"E","\u0114":"E","\u0116":"E","\u0118":"E","\u011a":"E","\u0113":"e","\u0115":"e","\u0117":"e","\u0119":"e","\u011b":"e","\u011c":"G","\u011e":"G","\u0120":"G","\u0122":"G","\u011d":"g","\u011f":"g","\u0121":"g",
"\u0123":"g","\u0124":"H","\u0126":"H","\u0125":"h","\u0127":"h","\u0128":"I","\u012a":"I","\u012c":"I","\u012e":"I","\u0130":"I","\u0129":"i","\u012b":"i","\u012d":"i","\u012f":"i","\u0131":"i","\u0134":"J","\u0135":"j","\u0136":"K","\u0137":"k","\u0138":"k","\u0139":"L","\u013b":"L","\u013d":"L","\u013f":"L","\u0141":"L","\u013a":"l","\u013c":"l","\u013e":"l","\u0140":"l","\u0142":"l","\u0143":"N","\u0145":"N","\u0147":"N","\u014a":"N","\u0144":"n","\u0146":"n","\u0148":"n","\u014b":"n","\u014c":"O",
"\u014e":"O","\u0150":"O","\u014d":"o","\u014f":"o","\u0151":"o","\u0154":"R","\u0156":"R","\u0158":"R","\u0155":"r","\u0157":"r","\u0159":"r","\u015a":"S","\u015c":"S","\u015e":"S","\u0160":"S","\u015b":"s","\u015d":"s","\u015f":"s","\u0161":"s","\u0162":"T","\u0164":"T","\u0166":"T","\u0163":"t","\u0165":"t","\u0167":"t","\u0168":"U","\u016a":"U","\u016c":"U","\u016e":"U","\u0170":"U","\u0172":"U","\u0169":"u","\u016b":"u","\u016d":"u","\u016f":"u","\u0171":"u","\u0173":"u","\u0174":"W","\u0175":"w",
"\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017b":"Z","\u017d":"Z","\u017a":"z","\u017c":"z","\u017e":"z","\u0132":"IJ","\u0133":"ij","\u0152":"Oe","\u0153":"oe","\u0149":"'n","\u017f":"s"},Kr={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},Vr={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},Gr={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Hr=parseFloat,Jr=parseInt,Yr="object"==typeof global&&global&&global.Object===Object&&global,Qr="object"==typeof self&&self&&self.Object===Object&&self,Xr=Yr||Qr||Function("return this")(),ne="object"==typeof exports&&exports&&!exports.nodeType&&exports,te=ne&&"object"==typeof module&&module&&!module.nodeType&&module,re=te&&te.exports===ne,ee=re&&Yr.process,ue=function(){
try{var n=te&&te.require&&te.require("util").types;return n?n:ee&&ee.binding&&ee.binding("util")}catch(n){}}(),ie=ue&&ue.isArrayBuffer,oe=ue&&ue.isDate,fe=ue&&ue.isMap,ce=ue&&ue.isRegExp,ae=ue&&ue.isSet,le=ue&&ue.isTypedArray,se=m("length"),he=x(Zr),pe=x(Kr),_e=x(Vr),ve=function p(x){function q(n){if(oc(n)&&!yh(n)&&!(n instanceof Bt)){if(n instanceof H)return n;if(yl.call(n,"__wrapped__"))return to(n)}return new H(n)}function G(){}function H(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,
this.__index__=0,this.__values__=Y}function Bt(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=Wn,this.__views__=[]}function Gt(){var n=new Bt(this.__wrapped__);return n.__actions__=Uu(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Uu(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Uu(this.__views__),n}function Ht(){if(this.__filtered__){var n=new Bt(this);n.__dir__=-1,
n.__filtered__=!0}else n=this.clone(),n.__dir__*=-1;return n}function Jt(){var n=this.__wrapped__.value(),t=this.__dir__,r=yh(n),e=t<0,u=r?n.length:0,i=Ai(0,u,this.__views__),o=i.start,f=i.end,c=f-o,a=e?f:o-1,l=this.__iteratees__,s=l.length,h=0,p=Vl(c,this.__takeCount__);if(!r||!e&&u==c&&p==c)return du(n,this.__actions__);var _=[];n:for(;c--&&h<p;){a+=t;for(var v=-1,g=n[a];++v<s;){var y=l[v],d=y.iteratee,b=y.type,w=d(g);if(b==On)g=w;else if(!w){if(b==kn)continue n;break n}}_[h++]=g}return _}function Yt(n){
var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Qt(){this.__data__=es?es(null):{},this.size=0}function Xt(n){var t=this.has(n)&&delete this.__data__[n];return this.size-=t?1:0,t}function nr(n){var t=this.__data__;if(es){var r=t[n];return r===rn?Y:r}return yl.call(t,n)?t[n]:Y}function tr(n){var t=this.__data__;return es?t[n]!==Y:yl.call(t,n)}function rr(n,t){var r=this.__data__;return this.size+=this.has(n)?0:1,r[n]=es&&t===Y?rn:t,this}function er(n){
var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function ur(){this.__data__=[],this.size=0}function ir(n){var t=this.__data__,r=Er(t,n);return!(r<0)&&(r==t.length-1?t.pop():Sl.call(t,r,1),--this.size,!0)}function or(n){var t=this.__data__,r=Er(t,n);return r<0?Y:t[r][1]}function fr(n){return Er(this.__data__,n)>-1}function cr(n,t){var r=this.__data__,e=Er(r,n);return e<0?(++this.size,r.push([n,t])):r[e][1]=t,this}function ar(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){
var e=n[t];this.set(e[0],e[1])}}function lr(){this.size=0,this.__data__={hash:new Yt,map:new(Xl||er),string:new Yt}}function sr(n){var t=wi(this,n).delete(n);return this.size-=t?1:0,t}function hr(n){return wi(this,n).get(n)}function pr(n){return wi(this,n).has(n)}function _r(n,t){var r=wi(this,n),e=r.size;return r.set(n,t),this.size+=r.size==e?0:1,this}function vr(n){var t=-1,r=null==n?0:n.length;for(this.__data__=new ar;++t<r;)this.add(n[t])}function gr(n){return this.__data__.set(n,rn),this}function yr(n){
return this.__data__.has(n)}function dr(n){this.size=(this.__data__=new er(n)).size}function br(){this.__data__=new er,this.size=0}function wr(n){var t=this.__data__,r=t.delete(n);return this.size=t.size,r}function mr(n){return this.__data__.get(n)}function xr(n){return this.__data__.has(n)}function jr(n,t){var r=this.__data__;if(r instanceof er){var e=r.__data__;if(!Xl||e.length<X-1)return e.push([n,t]),this.size=++r.size,this;r=this.__data__=new ar(e)}return r.set(n,t),this.size=r.size,this}function Ar(n,t){
var r=yh(n),e=!r&&gh(n),u=!r&&!e&&bh(n),i=!r&&!e&&!u&&Ah(n),o=r||e||u||i,f=o?O(n.length,ll):[],c=f.length;for(var a in n)!t&&!yl.call(n,a)||o&&("length"==a||u&&("offset"==a||"parent"==a)||i&&("buffer"==a||"byteLength"==a||"byteOffset"==a)||Wi(a,c))||f.push(a);return f}function kr(n){var t=n.length;return t?n[Xe(0,t-1)]:Y}function Or(n,t){return Yi(Uu(n),$r(t,0,n.length))}function Ir(n){return Yi(Uu(n))}function Rr(n,t,r){(r===Y||Kf(n[t],r))&&(r!==Y||t in n)||Cr(n,t,r)}function zr(n,t,r){var e=n[t];
yl.call(n,t)&&Kf(e,r)&&(r!==Y||t in n)||Cr(n,t,r)}function Er(n,t){for(var r=n.length;r--;)if(Kf(n[r][0],t))return r;return-1}function Sr(n,t,r,e){return vs(n,function(n,u,i){t(e,n,r(n),i)}),e}function Wr(n,t){return n&&Bu(t,Fc(t),n)}function Lr(n,t){return n&&Bu(t,Nc(t),n)}function Cr(n,t,r){"__proto__"==t&&Ul?Ul(n,t,{configurable:!0,enumerable:!0,value:r,writable:!0}):n[t]=r}function Tr(n,t){for(var r=-1,e=t.length,u=el(e),i=null==n;++r<e;)u[r]=i?Y:$c(n,t[r]);return u}function $r(n,t,r){return n===n&&(r!==Y&&(n=n<=r?n:r),
t!==Y&&(n=n>=t?n:t)),n}function Dr(n,t,e,u,i,o){var f,c=t&on,a=t&fn,l=t&cn;if(e&&(f=i?e(n,u,i,o):e(n)),f!==Y)return f;if(!ic(n))return n;var s=yh(n);if(s){if(f=Ii(n),!c)return Uu(n,f)}else{var h=Is(n),p=h==Pn||h==qn;if(bh(n))return ku(n,c);if(h==Gn||h==Bn||p&&!i){if(f=a||p?{}:Ri(n),!c)return a?$u(n,Lr(f,n)):Tu(n,Wr(f,n))}else{if(!qr[h])return i?n:{};f=zi(n,h,c)}}o||(o=new dr);var _=o.get(n);if(_)return _;o.set(n,f),jh(n)?n.forEach(function(r){f.add(Dr(r,t,e,r,n,o))}):mh(n)&&n.forEach(function(r,u){
f.set(u,Dr(r,t,e,u,n,o))});var v=l?a?gi:vi:a?Nc:Fc,g=s?Y:v(n);return r(g||n,function(r,u){g&&(u=r,r=n[u]),zr(f,u,Dr(r,t,e,u,n,o))}),f}function Mr(n){var t=Fc(n);return function(r){return Zr(r,n,t)}}function Zr(n,t,r){var e=r.length;if(null==n)return!e;for(n=cl(n);e--;){var u=r[e],i=t[u],o=n[u];if(o===Y&&!(u in n)||!i(o))return!1}return!0}function Kr(n,t,r){if("function"!=typeof n)throw new sl(tn);return Es(function(){n.apply(Y,r)},t)}function Vr(n,t,r,e){var u=-1,i=o,a=!0,l=n.length,s=[],h=t.length;
if(!l)return s;r&&(t=c(t,R(r))),e?(i=f,a=!1):t.length>=X&&(i=E,a=!1,t=new vr(t));n:for(;++u<l;){var p=n[u],_=null==r?p:r(p);if(p=e||0!==p?p:0,a&&_===_){for(var v=h;v--;)if(t[v]===_)continue n;s.push(p)}else i(t,_,e)||s.push(p)}return s}function Gr(n,t){var r=!0;return vs(n,function(n,e,u){return r=!!t(n,e,u)}),r}function Yr(n,t,r){for(var e=-1,u=n.length;++e<u;){var i=n[e],o=t(i);if(null!=o&&(f===Y?o===o&&!yc(o):r(o,f)))var f=o,c=i}return c}function Qr(n,t,r,e){var u=n.length;for(r=jc(r),r<0&&(r=-r>u?0:u+r),
e=e===Y||e>u?u:jc(e),e<0&&(e+=u),e=r>e?0:Ac(e);r<e;)n[r++]=t;return n}function ne(n,t){var r=[];return vs(n,function(n,e,u){t(n,e,u)&&r.push(n)}),r}function te(n,t,r,e,u){var i=-1,o=n.length;for(r||(r=Si),u||(u=[]);++i<o;){var f=n[i];t>0&&r(f)?t>1?te(f,t-1,r,e,u):a(u,f):e||(u[u.length]=f)}return u}function ee(n,t){return n&&ys(n,t,Fc)}function ue(n,t){return n&&ds(n,t,Fc)}function se(n,t){return i(t,function(t){return rc(n[t])})}function ve(n,t){t=ju(t,n);for(var r=0,e=t.length;null!=n&&r<e;)n=n[Qi(t[r++])];
return r&&r==e?n:Y}function ye(n,t,r){var e=t(n);return yh(n)?e:a(e,r(n))}function de(n){return null==n?n===Y?tt:Vn:Cl&&Cl in cl(n)?ji(n):qi(n)}function be(n,t){return n>t}function we(n,t){return null!=n&&yl.call(n,t)}function me(n,t){return null!=n&&t in cl(n)}function xe(n,t,r){return n>=Vl(t,r)&&n<Kl(t,r)}function je(n,t,r){for(var e=r?f:o,u=n[0].length,i=n.length,a=i,l=el(i),s=1/0,h=[];a--;){var p=n[a];a&&t&&(p=c(p,R(t))),s=Vl(p.length,s),l[a]=!r&&(t||u>=120&&p.length>=120)?new vr(a&&p):Y}p=n[0];
var _=-1,v=l[0];n:for(;++_<u&&h.length<s;){var g=p[_],y=t?t(g):g;if(g=r||0!==g?g:0,!(v?E(v,y):e(h,y,r))){for(a=i;--a;){var d=l[a];if(!(d?E(d,y):e(n[a],y,r)))continue n}v&&v.push(y),h.push(g)}}return h}function Ae(n,t,r,e){return ee(n,function(n,u,i){t(e,r(n),u,i)}),e}function ke(t,r,e){r=ju(r,t),t=Ki(t,r);var u=null==t?t:t[Qi(mo(r))];return null==u?Y:n(u,t,e)}function Oe(n){return oc(n)&&de(n)==Bn}function Ie(n){return oc(n)&&de(n)==ut}function Re(n){return oc(n)&&de(n)==Mn}function ze(n,t,r,e,u){
return n===t||(null==n||null==t||!oc(n)&&!oc(t)?n!==n&&t!==t:Ee(n,t,r,e,ze,u))}function Ee(n,t,r,e,u,i){var o=yh(n),f=yh(t),c=o?Tn:Is(n),a=f?Tn:Is(t);c=c==Bn?Gn:c,a=a==Bn?Gn:a;var l=c==Gn,s=a==Gn,h=c==a;if(h&&bh(n)){if(!bh(t))return!1;o=!0,l=!1}if(h&&!l)return i||(i=new dr),o||Ah(n)?si(n,t,r,e,u,i):hi(n,t,c,r,e,u,i);if(!(r&an)){var p=l&&yl.call(n,"__wrapped__"),_=s&&yl.call(t,"__wrapped__");if(p||_){var v=p?n.value():n,g=_?t.value():t;return i||(i=new dr),u(v,g,r,e,i)}}return!!h&&(i||(i=new dr),pi(n,t,r,e,u,i));
}function Se(n){return oc(n)&&Is(n)==Zn}function We(n,t,r,e){var u=r.length,i=u,o=!e;if(null==n)return!i;for(n=cl(n);u--;){var f=r[u];if(o&&f[2]?f[1]!==n[f[0]]:!(f[0]in n))return!1}for(;++u<i;){f=r[u];var c=f[0],a=n[c],l=f[1];if(o&&f[2]){if(a===Y&&!(c in n))return!1}else{var s=new dr;if(e)var h=e(a,l,c,n,t,s);if(!(h===Y?ze(l,a,an|ln,e,s):h))return!1}}return!0}function Le(n){return!(!ic(n)||Ti(n))&&(rc(n)?jl:Nt).test(Xi(n))}function Ce(n){return oc(n)&&de(n)==Yn}function Ue(n){return oc(n)&&Is(n)==Qn;
}function Be(n){return oc(n)&&uc(n.length)&&!!Pr[de(n)]}function Te(n){return"function"==typeof n?n:null==n?Sa:"object"==typeof n?yh(n)?Pe(n[0],n[1]):Ne(n):Da(n)}function $e(n){if(!$i(n))return Zl(n);var t=[];for(var r in cl(n))yl.call(n,r)&&"constructor"!=r&&t.push(r);return t}function De(n){if(!ic(n))return Pi(n);var t=$i(n),r=[];for(var e in n)("constructor"!=e||!t&&yl.call(n,e))&&r.push(e);return r}function Me(n,t){return n<t}function Fe(n,t){var r=-1,e=Vf(n)?el(n.length):[];return vs(n,function(n,u,i){
e[++r]=t(n,u,i)}),e}function Ne(n){var t=mi(n);return 1==t.length&&t[0][2]?Mi(t[0][0],t[0][1]):function(r){return r===n||We(r,n,t)}}function Pe(n,t){return Ci(n)&&Di(t)?Mi(Qi(n),t):function(r){var e=$c(r,n);return e===Y&&e===t?Mc(r,n):ze(t,e,an|ln)}}function qe(n,t,r,e,u){n!==t&&ys(t,function(i,o){if(u||(u=new dr),ic(i))Ze(n,t,o,r,qe,e,u);else{var f=e?e(Gi(n,o),i,o+"",n,t,u):Y;f===Y&&(f=i),Rr(n,o,f)}},Nc)}function Ze(n,t,r,e,u,i,o){var f=Gi(n,r),c=Gi(t,r),a=o.get(c);if(a)return Rr(n,r,a),Y;var l=i?i(f,c,r+"",n,t,o):Y,s=l===Y;
if(s){var h=yh(c),p=!h&&bh(c),_=!h&&!p&&Ah(c);l=c,h||p||_?yh(f)?l=f:Gf(f)?l=Uu(f):p?(s=!1,l=ku(c,!0)):_?(s=!1,l=Eu(c,!0)):l=[]:_c(c)||gh(c)?(l=f,gh(f)?l=Oc(f):ic(f)&&!rc(f)||(l=Ri(c))):s=!1}s&&(o.set(c,l),u(l,c,e,i,o),o.delete(c)),Rr(n,r,l)}function Ke(n,t){var r=n.length;if(r)return t+=t<0?r:0,Wi(t,r)?n[t]:Y}function Ve(n,t,r){t=t.length?c(t,function(n){return yh(n)?function(t){return ve(t,1===n.length?n[0]:n)}:n}):[Sa];var e=-1;return t=c(t,R(bi())),A(Fe(n,function(n,r,u){return{criteria:c(t,function(t){
return t(n)}),index:++e,value:n}}),function(n,t){return Wu(n,t,r)})}function Ge(n,t){return He(n,t,function(t,r){return Mc(n,r)})}function He(n,t,r){for(var e=-1,u=t.length,i={};++e<u;){var o=t[e],f=ve(n,o);r(f,o)&&iu(i,ju(o,n),f)}return i}function Je(n){return function(t){return ve(t,n)}}function Ye(n,t,r,e){var u=e?d:y,i=-1,o=t.length,f=n;for(n===t&&(t=Uu(t)),r&&(f=c(n,R(r)));++i<o;)for(var a=0,l=t[i],s=r?r(l):l;(a=u(f,s,a,e))>-1;)f!==n&&Sl.call(f,a,1),Sl.call(n,a,1);return n}function Qe(n,t){for(var r=n?t.length:0,e=r-1;r--;){
var u=t[r];if(r==e||u!==i){var i=u;Wi(u)?Sl.call(n,u,1):vu(n,u)}}return n}function Xe(n,t){return n+Ml(Jl()*(t-n+1))}function nu(n,t,r,e){for(var u=-1,i=Kl(Dl((t-n)/(r||1)),0),o=el(i);i--;)o[e?i:++u]=n,n+=r;return o}function tu(n,t){var r="";if(!n||t<1||t>zn)return r;do t%2&&(r+=n),t=Ml(t/2),t&&(n+=n);while(t);return r}function ru(n,t){return Ss(Zi(n,t,Sa),n+"")}function eu(n){return kr(na(n))}function uu(n,t){var r=na(n);return Yi(r,$r(t,0,r.length))}function iu(n,t,r,e){if(!ic(n))return n;t=ju(t,n);
for(var u=-1,i=t.length,o=i-1,f=n;null!=f&&++u<i;){var c=Qi(t[u]),a=r;if("__proto__"===c||"constructor"===c||"prototype"===c)return n;if(u!=o){var l=f[c];a=e?e(l,c,f):Y,a===Y&&(a=ic(l)?l:Wi(t[u+1])?[]:{})}zr(f,c,a),f=f[c]}return n}function ou(n){return Yi(na(n))}function fu(n,t,r){var e=-1,u=n.length;t<0&&(t=-t>u?0:u+t),r=r>u?u:r,r<0&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0;for(var i=el(u);++e<u;)i[e]=n[e+t];return i}function cu(n,t){var r;return vs(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function au(n,t,r){
var e=0,u=null==n?e:n.length;if("number"==typeof t&&t===t&&u<=Cn){for(;e<u;){var i=e+u>>>1,o=n[i];null!==o&&!yc(o)&&(r?o<=t:o<t)?e=i+1:u=i}return u}return lu(n,t,Sa,r)}function lu(n,t,r,e){var u=0,i=null==n?0:n.length;if(0===i)return 0;t=r(t);for(var o=t!==t,f=null===t,c=yc(t),a=t===Y;u<i;){var l=Ml((u+i)/2),s=r(n[l]),h=s!==Y,p=null===s,_=s===s,v=yc(s);if(o)var g=e||_;else g=a?_&&(e||h):f?_&&h&&(e||!p):c?_&&h&&!p&&(e||!v):!p&&!v&&(e?s<=t:s<t);g?u=l+1:i=l}return Vl(i,Ln)}function su(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){
var o=n[r],f=t?t(o):o;if(!r||!Kf(f,c)){var c=f;i[u++]=0===o?0:o}}return i}function hu(n){return"number"==typeof n?n:yc(n)?Sn:+n}function pu(n){if("string"==typeof n)return n;if(yh(n))return c(n,pu)+"";if(yc(n))return ps?ps.call(n):"";var t=n+"";return"0"==t&&1/n==-Rn?"-0":t}function _u(n,t,r){var e=-1,u=o,i=n.length,c=!0,a=[],l=a;if(r)c=!1,u=f;else if(i>=X){var s=t?null:js(n);if(s)return N(s);c=!1,u=E,l=new vr}else l=t?[]:a;n:for(;++e<i;){var h=n[e],p=t?t(h):h;if(h=r||0!==h?h:0,c&&p===p){for(var _=l.length;_--;)if(l[_]===p)continue n;
t&&l.push(p),a.push(h)}else u(l,p,r)||(l!==a&&l.push(p),a.push(h))}return a}function vu(n,t){return t=ju(t,n),n=Ki(n,t),null==n||delete n[Qi(mo(t))]}function gu(n,t,r,e){return iu(n,t,r(ve(n,t)),e)}function yu(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?fu(n,e?0:i,e?i+1:u):fu(n,e?i+1:0,e?u:i)}function du(n,t){var r=n;return r instanceof Bt&&(r=r.value()),l(t,function(n,t){return t.func.apply(t.thisArg,a([n],t.args))},r)}function bu(n,t,r){var e=n.length;if(e<2)return e?_u(n[0]):[];
for(var u=-1,i=el(e);++u<e;)for(var o=n[u],f=-1;++f<e;)f!=u&&(i[u]=Vr(i[u]||o,n[f],t,r));return _u(te(i,1),t,r)}function wu(n,t,r){for(var e=-1,u=n.length,i=t.length,o={};++e<u;){r(o,n[e],e<i?t[e]:Y)}return o}function mu(n){return Gf(n)?n:[]}function xu(n){return"function"==typeof n?n:Sa}function ju(n,t){return yh(n)?n:Ci(n,t)?[n]:Ws(Rc(n))}function Au(n,t,r){var e=n.length;return r=r===Y?e:r,!t&&r>=e?n:fu(n,t,r)}function ku(n,t){if(t)return n.slice();var r=n.length,e=Il?Il(r):new n.constructor(r);
return n.copy(e),e}function Ou(n){var t=new n.constructor(n.byteLength);return new Ol(t).set(new Ol(n)),t}function Iu(n,t){return new n.constructor(t?Ou(n.buffer):n.buffer,n.byteOffset,n.byteLength)}function Ru(n){var t=new n.constructor(n.source,Dt.exec(n));return t.lastIndex=n.lastIndex,t}function zu(n){return hs?cl(hs.call(n)):{}}function Eu(n,t){return new n.constructor(t?Ou(n.buffer):n.buffer,n.byteOffset,n.length)}function Su(n,t){if(n!==t){var r=n!==Y,e=null===n,u=n===n,i=yc(n),o=t!==Y,f=null===t,c=t===t,a=yc(t);
if(!f&&!a&&!i&&n>t||i&&o&&c&&!f&&!a||e&&o&&c||!r&&c||!u)return 1;if(!e&&!i&&!a&&n<t||a&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!c)return-1}return 0}function Wu(n,t,r){for(var e=-1,u=n.criteria,i=t.criteria,o=u.length,f=r.length;++e<o;){var c=Su(u[e],i[e]);if(c){if(e>=f)return c;return c*("desc"==r[e]?-1:1)}}return n.index-t.index}function Lu(n,t,r,e){for(var u=-1,i=n.length,o=r.length,f=-1,c=t.length,a=Kl(i-o,0),l=el(c+a),s=!e;++f<c;)l[f]=t[f];for(;++u<o;)(s||u<i)&&(l[r[u]]=n[u]);for(;a--;)l[f++]=n[u++];return l;
}function Cu(n,t,r,e){for(var u=-1,i=n.length,o=-1,f=r.length,c=-1,a=t.length,l=Kl(i-f,0),s=el(l+a),h=!e;++u<l;)s[u]=n[u];for(var p=u;++c<a;)s[p+c]=t[c];for(;++o<f;)(h||u<i)&&(s[p+r[o]]=n[u++]);return s}function Uu(n,t){var r=-1,e=n.length;for(t||(t=el(e));++r<e;)t[r]=n[r];return t}function Bu(n,t,r,e){var u=!r;r||(r={});for(var i=-1,o=t.length;++i<o;){var f=t[i],c=e?e(r[f],n[f],f,r,n):Y;c===Y&&(c=n[f]),u?Cr(r,f,c):zr(r,f,c)}return r}function Tu(n,t){return Bu(n,ks(n),t)}function $u(n,t){return Bu(n,Os(n),t);
}function Du(n,r){return function(e,u){var i=yh(e)?t:Sr,o=r?r():{};return i(e,n,bi(u,2),o)}}function Mu(n){return ru(function(t,r){var e=-1,u=r.length,i=u>1?r[u-1]:Y,o=u>2?r[2]:Y;for(i=n.length>3&&"function"==typeof i?(u--,i):Y,o&&Li(r[0],r[1],o)&&(i=u<3?Y:i,u=1),t=cl(t);++e<u;){var f=r[e];f&&n(t,f,e,i)}return t})}function Fu(n,t){return function(r,e){if(null==r)return r;if(!Vf(r))return n(r,e);for(var u=r.length,i=t?u:-1,o=cl(r);(t?i--:++i<u)&&e(o[i],i,o)!==!1;);return r}}function Nu(n){return function(t,r,e){
for(var u=-1,i=cl(t),o=e(t),f=o.length;f--;){var c=o[n?f:++u];if(r(i[c],c,i)===!1)break}return t}}function Pu(n,t,r){function e(){return(this&&this!==Xr&&this instanceof e?i:n).apply(u?r:this,arguments)}var u=t&sn,i=Ku(n);return e}function qu(n){return function(t){t=Rc(t);var r=B(t)?V(t):Y,e=r?r[0]:t.charAt(0),u=r?Au(r,1).join(""):t.slice(1);return e[n]()+u}}function Zu(n){return function(t){return l(Oa(oa(t).replace(Ur,"")),n,"")}}function Ku(n){return function(){var t=arguments;switch(t.length){
case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=_s(n.prototype),e=n.apply(r,t);return ic(e)?e:r}}function Vu(t,r,e){function u(){for(var o=arguments.length,f=el(o),c=o,a=di(u);c--;)f[c]=arguments[c];var l=o<3&&f[0]!==a&&f[o-1]!==a?[]:F(f,a);
return o-=l.length,o<e?ui(t,r,Ju,u.placeholder,Y,f,l,Y,Y,e-o):n(this&&this!==Xr&&this instanceof u?i:t,this,f)}var i=Ku(t);return u}function Gu(n){return function(t,r,e){var u=cl(t);if(!Vf(t)){var i=bi(r,3);t=Fc(t),r=function(n){return i(u[n],n,u)}}var o=n(t,r,e);return o>-1?u[i?t[o]:o]:Y}}function Hu(n){return _i(function(t){var r=t.length,e=r,u=H.prototype.thru;for(n&&t.reverse();e--;){var i=t[e];if("function"!=typeof i)throw new sl(tn);if(u&&!o&&"wrapper"==yi(i))var o=new H([],!0)}for(e=o?e:r;++e<r;){
i=t[e];var f=yi(i),c="wrapper"==f?As(i):Y;o=c&&Bi(c[0])&&c[1]==(dn|_n|gn|bn)&&!c[4].length&&1==c[9]?o[yi(c[0])].apply(o,c[3]):1==i.length&&Bi(i)?o[f]():o.thru(i)}return function(){var n=arguments,e=n[0];if(o&&1==n.length&&yh(e))return o.plant(e).value();for(var u=0,i=r?t[u].apply(this,n):e;++u<r;)i=t[u].call(this,i);return i}})}function Ju(n,t,r,e,u,i,o,f,c,a){function l(){for(var y=arguments.length,d=el(y),b=y;b--;)d[b]=arguments[b];if(_)var w=di(l),m=L(d,w);if(e&&(d=Lu(d,e,u,_)),i&&(d=Cu(d,i,o,_)),
y-=m,_&&y<a){return ui(n,t,Ju,l.placeholder,r,d,F(d,w),f,c,a-y)}var x=h?r:this,j=p?x[n]:n;return y=d.length,f?d=Vi(d,f):v&&y>1&&d.reverse(),s&&c<y&&(d.length=c),this&&this!==Xr&&this instanceof l&&(j=g||Ku(j)),j.apply(x,d)}var s=t&dn,h=t&sn,p=t&hn,_=t&(_n|vn),v=t&wn,g=p?Y:Ku(n);return l}function Yu(n,t){return function(r,e){return Ae(r,n,t(e),{})}}function Qu(n,t){return function(r,e){var u;if(r===Y&&e===Y)return t;if(r!==Y&&(u=r),e!==Y){if(u===Y)return e;"string"==typeof r||"string"==typeof e?(r=pu(r),
e=pu(e)):(r=hu(r),e=hu(e)),u=n(r,e)}return u}}function Xu(t){return _i(function(r){return r=c(r,R(bi())),ru(function(e){var u=this;return t(r,function(t){return n(t,u,e)})})})}function ni(n,t){t=t===Y?" ":pu(t);var r=t.length;if(r<2)return r?tu(t,n):t;var e=tu(t,Dl(n/K(t)));return B(t)?Au(V(e),0,n).join(""):e.slice(0,n)}function ti(t,r,e,u){function i(){for(var r=-1,c=arguments.length,a=-1,l=u.length,s=el(l+c),h=this&&this!==Xr&&this instanceof i?f:t;++a<l;)s[a]=u[a];for(;c--;)s[a++]=arguments[++r];
return n(h,o?e:this,s)}var o=r&sn,f=Ku(t);return i}function ri(n){return function(t,r,e){return e&&"number"!=typeof e&&Li(t,r,e)&&(r=e=Y),t=xc(t),r===Y?(r=t,t=0):r=xc(r),e=e===Y?t<r?1:-1:xc(e),nu(t,r,e,n)}}function ei(n){return function(t,r){return"string"==typeof t&&"string"==typeof r||(t=kc(t),r=kc(r)),n(t,r)}}function ui(n,t,r,e,u,i,o,f,c,a){var l=t&_n,s=l?o:Y,h=l?Y:o,p=l?i:Y,_=l?Y:i;t|=l?gn:yn,t&=~(l?yn:gn),t&pn||(t&=~(sn|hn));var v=[n,t,u,p,s,_,h,f,c,a],g=r.apply(Y,v);return Bi(n)&&zs(g,v),g.placeholder=e,
Hi(g,n,t)}function ii(n){var t=fl[n];return function(n,r){if(n=kc(n),r=null==r?0:Vl(jc(r),292),r&&Pl(n)){var e=(Rc(n)+"e").split("e");return e=(Rc(t(e[0]+"e"+(+e[1]+r)))+"e").split("e"),+(e[0]+"e"+(+e[1]-r))}return t(n)}}function oi(n){return function(t){var r=Is(t);return r==Zn?D(t):r==Qn?P(t):I(t,n(t))}}function fi(n,t,r,e,u,i,o,f){var c=t&hn;if(!c&&"function"!=typeof n)throw new sl(tn);var a=e?e.length:0;if(a||(t&=~(gn|yn),e=u=Y),o=o===Y?o:Kl(jc(o),0),f=f===Y?f:jc(f),a-=u?u.length:0,t&yn){var l=e,s=u;
e=u=Y}var h=c?Y:As(n),p=[n,t,r,e,u,l,s,i,o,f];if(h&&Ni(p,h),n=p[0],t=p[1],r=p[2],e=p[3],u=p[4],f=p[9]=p[9]===Y?c?0:n.length:Kl(p[9]-a,0),!f&&t&(_n|vn)&&(t&=~(_n|vn)),t&&t!=sn)_=t==_n||t==vn?Vu(n,t,f):t!=gn&&t!=(sn|gn)||u.length?Ju.apply(Y,p):ti(n,t,r,e);else var _=Pu(n,t,r);return Hi((h?bs:zs)(_,p),n,t)}function ci(n,t,r,e){return n===Y||Kf(n,_l[r])&&!yl.call(e,r)?t:n}function ai(n,t,r,e,u,i){return ic(n)&&ic(t)&&(i.set(t,n),qe(n,t,Y,ai,i),i.delete(t)),n}function li(n){return _c(n)?Y:n}function si(n,t,r,e,u,i){
var o=r&an,f=n.length,c=t.length;if(f!=c&&!(o&&c>f))return!1;var a=i.get(n),l=i.get(t);if(a&&l)return a==t&&l==n;var s=-1,p=!0,_=r&ln?new vr:Y;for(i.set(n,t),i.set(t,n);++s<f;){var v=n[s],g=t[s];if(e)var y=o?e(g,v,s,t,n,i):e(v,g,s,n,t,i);if(y!==Y){if(y)continue;p=!1;break}if(_){if(!h(t,function(n,t){if(!E(_,t)&&(v===n||u(v,n,r,e,i)))return _.push(t)})){p=!1;break}}else if(v!==g&&!u(v,g,r,e,i)){p=!1;break}}return i.delete(n),i.delete(t),p}function hi(n,t,r,e,u,i,o){switch(r){case it:if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)return!1;
n=n.buffer,t=t.buffer;case ut:return!(n.byteLength!=t.byteLength||!i(new Ol(n),new Ol(t)));case Dn:case Mn:case Kn:return Kf(+n,+t);case Nn:return n.name==t.name&&n.message==t.message;case Yn:case Xn:return n==t+"";case Zn:var f=D;case Qn:var c=e&an;if(f||(f=N),n.size!=t.size&&!c)return!1;var a=o.get(n);if(a)return a==t;e|=ln,o.set(n,t);var l=si(f(n),f(t),e,u,i,o);return o.delete(n),l;case nt:if(hs)return hs.call(n)==hs.call(t)}return!1}function pi(n,t,r,e,u,i){var o=r&an,f=vi(n),c=f.length;if(c!=vi(t).length&&!o)return!1;
for(var a=c;a--;){var l=f[a];if(!(o?l in t:yl.call(t,l)))return!1}var s=i.get(n),h=i.get(t);if(s&&h)return s==t&&h==n;var p=!0;i.set(n,t),i.set(t,n);for(var _=o;++a<c;){l=f[a];var v=n[l],g=t[l];if(e)var y=o?e(g,v,l,t,n,i):e(v,g,l,n,t,i);if(!(y===Y?v===g||u(v,g,r,e,i):y)){p=!1;break}_||(_="constructor"==l)}if(p&&!_){var d=n.constructor,b=t.constructor;d!=b&&"constructor"in n&&"constructor"in t&&!("function"==typeof d&&d instanceof d&&"function"==typeof b&&b instanceof b)&&(p=!1)}return i.delete(n),
i.delete(t),p}function _i(n){return Ss(Zi(n,Y,ho),n+"")}function vi(n){return ye(n,Fc,ks)}function gi(n){return ye(n,Nc,Os)}function yi(n){for(var t=n.name+"",r=is[t],e=yl.call(is,t)?r.length:0;e--;){var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function di(n){return(yl.call(q,"placeholder")?q:n).placeholder}function bi(){var n=q.iteratee||Wa;return n=n===Wa?Te:n,arguments.length?n(arguments[0],arguments[1]):n}function wi(n,t){var r=n.__data__;return Ui(t)?r["string"==typeof t?"string":"hash"]:r.map;
}function mi(n){for(var t=Fc(n),r=t.length;r--;){var e=t[r],u=n[e];t[r]=[e,u,Di(u)]}return t}function xi(n,t){var r=U(n,t);return Le(r)?r:Y}function ji(n){var t=yl.call(n,Cl),r=n[Cl];try{n[Cl]=Y;var e=!0}catch(n){}var u=wl.call(n);return e&&(t?n[Cl]=r:delete n[Cl]),u}function Ai(n,t,r){for(var e=-1,u=r.length;++e<u;){var i=r[e],o=i.size;switch(i.type){case"drop":n+=o;break;case"dropRight":t-=o;break;case"take":t=Vl(t,n+o);break;case"takeRight":n=Kl(n,t-o)}}return{start:n,end:t}}function ki(n){var t=n.match(Ct);
return t?t[1].split(Ut):[]}function Oi(n,t,r){t=ju(t,n);for(var e=-1,u=t.length,i=!1;++e<u;){var o=Qi(t[e]);if(!(i=null!=n&&r(n,o)))break;n=n[o]}return i||++e!=u?i:(u=null==n?0:n.length,!!u&&uc(u)&&Wi(o,u)&&(yh(n)||gh(n)))}function Ii(n){var t=n.length,r=new n.constructor(t);return t&&"string"==typeof n[0]&&yl.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Ri(n){return"function"!=typeof n.constructor||$i(n)?{}:_s(Rl(n))}function zi(n,t,r){var e=n.constructor;switch(t){case ut:return Ou(n);
case Dn:case Mn:return new e(+n);case it:return Iu(n,r);case ot:case ft:case ct:case at:case lt:case st:case ht:case pt:case _t:return Eu(n,r);case Zn:return new e;case Kn:case Xn:return new e(n);case Yn:return Ru(n);case Qn:return new e;case nt:return zu(n)}}function Ei(n,t){var r=t.length;if(!r)return n;var e=r-1;return t[e]=(r>1?"& ":"")+t[e],t=t.join(r>2?", ":" "),n.replace(Lt,"{\n/* [wrapped with "+t+"] */\n")}function Si(n){return yh(n)||gh(n)||!!(Wl&&n&&n[Wl])}function Wi(n,t){var r=typeof n;
return t=null==t?zn:t,!!t&&("number"==r||"symbol"!=r&&qt.test(n))&&n>-1&&n%1==0&&n<t}function Li(n,t,r){if(!ic(r))return!1;var e=typeof t;return!!("number"==e?Vf(r)&&Wi(t,r.length):"string"==e&&t in r)&&Kf(r[t],n)}function Ci(n,t){if(yh(n))return!1;var r=typeof n;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=n&&!yc(n))||(Ot.test(n)||!kt.test(n)||null!=t&&n in cl(t))}function Ui(n){var t=typeof n;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==n:null===n}function Bi(n){
var t=yi(n),r=q[t];if("function"!=typeof r||!(t in Bt.prototype))return!1;if(n===r)return!0;var e=As(r);return!!e&&n===e[0]}function Ti(n){return!!bl&&bl in n}function $i(n){var t=n&&n.constructor;return n===("function"==typeof t&&t.prototype||_l)}function Di(n){return n===n&&!ic(n)}function Mi(n,t){return function(r){return null!=r&&(r[n]===t&&(t!==Y||n in cl(r)))}}function Fi(n){var t=Wf(n,function(n){return r.size===en&&r.clear(),n}),r=t.cache;return t}function Ni(n,t){var r=n[1],e=t[1],u=r|e,i=u<(sn|hn|dn),o=e==dn&&r==_n||e==dn&&r==bn&&n[7].length<=t[8]||e==(dn|bn)&&t[7].length<=t[8]&&r==_n;
if(!i&&!o)return n;e&sn&&(n[2]=t[2],u|=r&sn?0:pn);var f=t[3];if(f){var c=n[3];n[3]=c?Lu(c,f,t[4]):f,n[4]=c?F(n[3],un):t[4]}return f=t[5],f&&(c=n[5],n[5]=c?Cu(c,f,t[6]):f,n[6]=c?F(n[5],un):t[6]),f=t[7],f&&(n[7]=f),e&dn&&(n[8]=null==n[8]?t[8]:Vl(n[8],t[8])),null==n[9]&&(n[9]=t[9]),n[0]=t[0],n[1]=u,n}function Pi(n){var t=[];if(null!=n)for(var r in cl(n))t.push(r);return t}function qi(n){return wl.call(n)}function Zi(t,r,e){return r=Kl(r===Y?t.length-1:r,0),function(){for(var u=arguments,i=-1,o=Kl(u.length-r,0),f=el(o);++i<o;)f[i]=u[r+i];
i=-1;for(var c=el(r+1);++i<r;)c[i]=u[i];return c[r]=e(f),n(t,this,c)}}function Ki(n,t){return t.length<2?n:ve(n,fu(t,0,-1))}function Vi(n,t){for(var r=n.length,e=Vl(t.length,r),u=Uu(n);e--;){var i=t[e];n[e]=Wi(i,r)?u[i]:Y}return n}function Gi(n,t){if(("constructor"!==t||"function"!=typeof n[t])&&"__proto__"!=t)return n[t]}function Hi(n,t,r){var e=t+"";return Ss(n,Ei(e,no(ki(e),r)))}function Ji(n){var t=0,r=0;return function(){var e=Gl(),u=An-(e-r);if(r=e,u>0){if(++t>=jn)return arguments[0]}else t=0;
return n.apply(Y,arguments)}}function Yi(n,t){var r=-1,e=n.length,u=e-1;for(t=t===Y?e:t;++r<t;){var i=Xe(r,u),o=n[i];n[i]=n[r],n[r]=o}return n.length=t,n}function Qi(n){if("string"==typeof n||yc(n))return n;var t=n+"";return"0"==t&&1/n==-Rn?"-0":t}function Xi(n){if(null!=n){try{return gl.call(n)}catch(n){}try{return n+""}catch(n){}}return""}function no(n,t){return r(Un,function(r){var e="_."+r[0];t&r[1]&&!o(n,e)&&n.push(e)}),n.sort()}function to(n){if(n instanceof Bt)return n.clone();var t=new H(n.__wrapped__,n.__chain__);
return t.__actions__=Uu(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function ro(n,t,r){t=(r?Li(n,t,r):t===Y)?1:Kl(jc(t),0);var e=null==n?0:n.length;if(!e||t<1)return[];for(var u=0,i=0,o=el(Dl(e/t));u<e;)o[i++]=fu(n,u,u+=t);return o}function eo(n){for(var t=-1,r=null==n?0:n.length,e=0,u=[];++t<r;){var i=n[t];i&&(u[e++]=i)}return u}function uo(){var n=arguments.length;if(!n)return[];for(var t=el(n-1),r=arguments[0],e=n;e--;)t[e-1]=arguments[e];return a(yh(r)?Uu(r):[r],te(t,1));
}function io(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===Y?1:jc(t),fu(n,t<0?0:t,e)):[]}function oo(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===Y?1:jc(t),t=e-t,fu(n,0,t<0?0:t)):[]}function fo(n,t){return n&&n.length?yu(n,bi(t,3),!0,!0):[]}function co(n,t){return n&&n.length?yu(n,bi(t,3),!0):[]}function ao(n,t,r,e){var u=null==n?0:n.length;return u?(r&&"number"!=typeof r&&Li(n,t,r)&&(r=0,e=u),Qr(n,t,r,e)):[]}function lo(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=null==r?0:jc(r);
return u<0&&(u=Kl(e+u,0)),g(n,bi(t,3),u)}function so(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e-1;return r!==Y&&(u=jc(r),u=r<0?Kl(e+u,0):Vl(u,e-1)),g(n,bi(t,3),u,!0)}function ho(n){return(null==n?0:n.length)?te(n,1):[]}function po(n){return(null==n?0:n.length)?te(n,Rn):[]}function _o(n,t){return(null==n?0:n.length)?(t=t===Y?1:jc(t),te(n,t)):[]}function vo(n){for(var t=-1,r=null==n?0:n.length,e={};++t<r;){var u=n[t];e[u[0]]=u[1]}return e}function go(n){return n&&n.length?n[0]:Y}function yo(n,t,r){
var e=null==n?0:n.length;if(!e)return-1;var u=null==r?0:jc(r);return u<0&&(u=Kl(e+u,0)),y(n,t,u)}function bo(n){return(null==n?0:n.length)?fu(n,0,-1):[]}function wo(n,t){return null==n?"":ql.call(n,t)}function mo(n){var t=null==n?0:n.length;return t?n[t-1]:Y}function xo(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e;return r!==Y&&(u=jc(r),u=u<0?Kl(e+u,0):Vl(u,e-1)),t===t?Z(n,t,u):g(n,b,u,!0)}function jo(n,t){return n&&n.length?Ke(n,jc(t)):Y}function Ao(n,t){return n&&n.length&&t&&t.length?Ye(n,t):n;
}function ko(n,t,r){return n&&n.length&&t&&t.length?Ye(n,t,bi(r,2)):n}function Oo(n,t,r){return n&&n.length&&t&&t.length?Ye(n,t,Y,r):n}function Io(n,t){var r=[];if(!n||!n.length)return r;var e=-1,u=[],i=n.length;for(t=bi(t,3);++e<i;){var o=n[e];t(o,e,n)&&(r.push(o),u.push(e))}return Qe(n,u),r}function Ro(n){return null==n?n:Yl.call(n)}function zo(n,t,r){var e=null==n?0:n.length;return e?(r&&"number"!=typeof r&&Li(n,t,r)?(t=0,r=e):(t=null==t?0:jc(t),r=r===Y?e:jc(r)),fu(n,t,r)):[]}function Eo(n,t){
return au(n,t)}function So(n,t,r){return lu(n,t,bi(r,2))}function Wo(n,t){var r=null==n?0:n.length;if(r){var e=au(n,t);if(e<r&&Kf(n[e],t))return e}return-1}function Lo(n,t){return au(n,t,!0)}function Co(n,t,r){return lu(n,t,bi(r,2),!0)}function Uo(n,t){if(null==n?0:n.length){var r=au(n,t,!0)-1;if(Kf(n[r],t))return r}return-1}function Bo(n){return n&&n.length?su(n):[]}function To(n,t){return n&&n.length?su(n,bi(t,2)):[]}function $o(n){var t=null==n?0:n.length;return t?fu(n,1,t):[]}function Do(n,t,r){
return n&&n.length?(t=r||t===Y?1:jc(t),fu(n,0,t<0?0:t)):[]}function Mo(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===Y?1:jc(t),t=e-t,fu(n,t<0?0:t,e)):[]}function Fo(n,t){return n&&n.length?yu(n,bi(t,3),!1,!0):[]}function No(n,t){return n&&n.length?yu(n,bi(t,3)):[]}function Po(n){return n&&n.length?_u(n):[]}function qo(n,t){return n&&n.length?_u(n,bi(t,2)):[]}function Zo(n,t){return t="function"==typeof t?t:Y,n&&n.length?_u(n,Y,t):[]}function Ko(n){if(!n||!n.length)return[];var t=0;return n=i(n,function(n){
if(Gf(n))return t=Kl(n.length,t),!0}),O(t,function(t){return c(n,m(t))})}function Vo(t,r){if(!t||!t.length)return[];var e=Ko(t);return null==r?e:c(e,function(t){return n(r,Y,t)})}function Go(n,t){return wu(n||[],t||[],zr)}function Ho(n,t){return wu(n||[],t||[],iu)}function Jo(n){var t=q(n);return t.__chain__=!0,t}function Yo(n,t){return t(n),n}function Qo(n,t){return t(n)}function Xo(){return Jo(this)}function nf(){return new H(this.value(),this.__chain__)}function tf(){this.__values__===Y&&(this.__values__=mc(this.value()));
var n=this.__index__>=this.__values__.length;return{done:n,value:n?Y:this.__values__[this.__index__++]}}function rf(){return this}function ef(n){for(var t,r=this;r instanceof G;){var e=to(r);e.__index__=0,e.__values__=Y,t?u.__wrapped__=e:t=e;var u=e;r=r.__wrapped__}return u.__wrapped__=n,t}function uf(){var n=this.__wrapped__;if(n instanceof Bt){var t=n;return this.__actions__.length&&(t=new Bt(this)),t=t.reverse(),t.__actions__.push({func:Qo,args:[Ro],thisArg:Y}),new H(t,this.__chain__)}return this.thru(Ro);
}function of(){return du(this.__wrapped__,this.__actions__)}function ff(n,t,r){var e=yh(n)?u:Gr;return r&&Li(n,t,r)&&(t=Y),e(n,bi(t,3))}function cf(n,t){return(yh(n)?i:ne)(n,bi(t,3))}function af(n,t){return te(vf(n,t),1)}function lf(n,t){return te(vf(n,t),Rn)}function sf(n,t,r){return r=r===Y?1:jc(r),te(vf(n,t),r)}function hf(n,t){return(yh(n)?r:vs)(n,bi(t,3))}function pf(n,t){return(yh(n)?e:gs)(n,bi(t,3))}function _f(n,t,r,e){n=Vf(n)?n:na(n),r=r&&!e?jc(r):0;var u=n.length;return r<0&&(r=Kl(u+r,0)),
gc(n)?r<=u&&n.indexOf(t,r)>-1:!!u&&y(n,t,r)>-1}function vf(n,t){return(yh(n)?c:Fe)(n,bi(t,3))}function gf(n,t,r,e){return null==n?[]:(yh(t)||(t=null==t?[]:[t]),r=e?Y:r,yh(r)||(r=null==r?[]:[r]),Ve(n,t,r))}function yf(n,t,r){var e=yh(n)?l:j,u=arguments.length<3;return e(n,bi(t,4),r,u,vs)}function df(n,t,r){var e=yh(n)?s:j,u=arguments.length<3;return e(n,bi(t,4),r,u,gs)}function bf(n,t){return(yh(n)?i:ne)(n,Lf(bi(t,3)))}function wf(n){return(yh(n)?kr:eu)(n)}function mf(n,t,r){return t=(r?Li(n,t,r):t===Y)?1:jc(t),
(yh(n)?Or:uu)(n,t)}function xf(n){return(yh(n)?Ir:ou)(n)}function jf(n){if(null==n)return 0;if(Vf(n))return gc(n)?K(n):n.length;var t=Is(n);return t==Zn||t==Qn?n.size:$e(n).length}function Af(n,t,r){var e=yh(n)?h:cu;return r&&Li(n,t,r)&&(t=Y),e(n,bi(t,3))}function kf(n,t){if("function"!=typeof t)throw new sl(tn);return n=jc(n),function(){if(--n<1)return t.apply(this,arguments)}}function Of(n,t,r){return t=r?Y:t,t=n&&null==t?n.length:t,fi(n,dn,Y,Y,Y,Y,t)}function If(n,t){var r;if("function"!=typeof t)throw new sl(tn);
return n=jc(n),function(){return--n>0&&(r=t.apply(this,arguments)),n<=1&&(t=Y),r}}function Rf(n,t,r){t=r?Y:t;var e=fi(n,_n,Y,Y,Y,Y,Y,t);return e.placeholder=Rf.placeholder,e}function zf(n,t,r){t=r?Y:t;var e=fi(n,vn,Y,Y,Y,Y,Y,t);return e.placeholder=zf.placeholder,e}function Ef(n,t,r){function e(t){var r=h,e=p;return h=p=Y,d=t,v=n.apply(e,r)}function u(n){return d=n,g=Es(f,t),b?e(n):v}function i(n){var r=n-y,e=n-d,u=t-r;return w?Vl(u,_-e):u}function o(n){var r=n-y,e=n-d;return y===Y||r>=t||r<0||w&&e>=_;
}function f(){var n=ih();return o(n)?c(n):(g=Es(f,i(n)),Y)}function c(n){return g=Y,m&&h?e(n):(h=p=Y,v)}function a(){g!==Y&&xs(g),d=0,h=y=p=g=Y}function l(){return g===Y?v:c(ih())}function s(){var n=ih(),r=o(n);if(h=arguments,p=this,y=n,r){if(g===Y)return u(y);if(w)return xs(g),g=Es(f,t),e(y)}return g===Y&&(g=Es(f,t)),v}var h,p,_,v,g,y,d=0,b=!1,w=!1,m=!0;if("function"!=typeof n)throw new sl(tn);return t=kc(t)||0,ic(r)&&(b=!!r.leading,w="maxWait"in r,_=w?Kl(kc(r.maxWait)||0,t):_,m="trailing"in r?!!r.trailing:m),
s.cancel=a,s.flush=l,s}function Sf(n){return fi(n,wn)}function Wf(n,t){if("function"!=typeof n||null!=t&&"function"!=typeof t)throw new sl(tn);var r=function(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;if(i.has(u))return i.get(u);var o=n.apply(this,e);return r.cache=i.set(u,o)||i,o};return r.cache=new(Wf.Cache||ar),r}function Lf(n){if("function"!=typeof n)throw new sl(tn);return function(){var t=arguments;switch(t.length){case 0:return!n.call(this);case 1:return!n.call(this,t[0]);case 2:
return!n.call(this,t[0],t[1]);case 3:return!n.call(this,t[0],t[1],t[2])}return!n.apply(this,t)}}function Cf(n){return If(2,n)}function Uf(n,t){if("function"!=typeof n)throw new sl(tn);return t=t===Y?t:jc(t),ru(n,t)}function Bf(t,r){if("function"!=typeof t)throw new sl(tn);return r=null==r?0:Kl(jc(r),0),ru(function(e){var u=e[r],i=Au(e,0,r);return u&&a(i,u),n(t,this,i)})}function Tf(n,t,r){var e=!0,u=!0;if("function"!=typeof n)throw new sl(tn);return ic(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),
Ef(n,t,{leading:e,maxWait:t,trailing:u})}function $f(n){return Of(n,1)}function Df(n,t){return sh(xu(t),n)}function Mf(){if(!arguments.length)return[];var n=arguments[0];return yh(n)?n:[n]}function Ff(n){return Dr(n,cn)}function Nf(n,t){return t="function"==typeof t?t:Y,Dr(n,cn,t)}function Pf(n){return Dr(n,on|cn)}function qf(n,t){return t="function"==typeof t?t:Y,Dr(n,on|cn,t)}function Zf(n,t){return null==t||Zr(n,t,Fc(t))}function Kf(n,t){return n===t||n!==n&&t!==t}function Vf(n){return null!=n&&uc(n.length)&&!rc(n);
}function Gf(n){return oc(n)&&Vf(n)}function Hf(n){return n===!0||n===!1||oc(n)&&de(n)==Dn}function Jf(n){return oc(n)&&1===n.nodeType&&!_c(n)}function Yf(n){if(null==n)return!0;if(Vf(n)&&(yh(n)||"string"==typeof n||"function"==typeof n.splice||bh(n)||Ah(n)||gh(n)))return!n.length;var t=Is(n);if(t==Zn||t==Qn)return!n.size;if($i(n))return!$e(n).length;for(var r in n)if(yl.call(n,r))return!1;return!0}function Qf(n,t){return ze(n,t)}function Xf(n,t,r){r="function"==typeof r?r:Y;var e=r?r(n,t):Y;return e===Y?ze(n,t,Y,r):!!e;
}function nc(n){if(!oc(n))return!1;var t=de(n);return t==Nn||t==Fn||"string"==typeof n.message&&"string"==typeof n.name&&!_c(n)}function tc(n){return"number"==typeof n&&Pl(n)}function rc(n){if(!ic(n))return!1;var t=de(n);return t==Pn||t==qn||t==$n||t==Jn}function ec(n){return"number"==typeof n&&n==jc(n)}function uc(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=zn}function ic(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)}function oc(n){return null!=n&&"object"==typeof n}function fc(n,t){
return n===t||We(n,t,mi(t))}function cc(n,t,r){return r="function"==typeof r?r:Y,We(n,t,mi(t),r)}function ac(n){return pc(n)&&n!=+n}function lc(n){if(Rs(n))throw new il(nn);return Le(n)}function sc(n){return null===n}function hc(n){return null==n}function pc(n){return"number"==typeof n||oc(n)&&de(n)==Kn}function _c(n){if(!oc(n)||de(n)!=Gn)return!1;var t=Rl(n);if(null===t)return!0;var r=yl.call(t,"constructor")&&t.constructor;return"function"==typeof r&&r instanceof r&&gl.call(r)==ml}function vc(n){
return ec(n)&&n>=-zn&&n<=zn}function gc(n){return"string"==typeof n||!yh(n)&&oc(n)&&de(n)==Xn}function yc(n){return"symbol"==typeof n||oc(n)&&de(n)==nt}function dc(n){return n===Y}function bc(n){return oc(n)&&Is(n)==rt}function wc(n){return oc(n)&&de(n)==et}function mc(n){if(!n)return[];if(Vf(n))return gc(n)?V(n):Uu(n);if(Ll&&n[Ll])return $(n[Ll]());var t=Is(n);return(t==Zn?D:t==Qn?N:na)(n)}function xc(n){if(!n)return 0===n?n:0;if(n=kc(n),n===Rn||n===-Rn){return(n<0?-1:1)*En}return n===n?n:0}function jc(n){
var t=xc(n),r=t%1;return t===t?r?t-r:t:0}function Ac(n){return n?$r(jc(n),0,Wn):0}function kc(n){if("number"==typeof n)return n;if(yc(n))return Sn;if(ic(n)){var t="function"==typeof n.valueOf?n.valueOf():n;n=ic(t)?t+"":t}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(Et,"");var r=Ft.test(n);return r||Pt.test(n)?Jr(n.slice(2),r?2:8):Mt.test(n)?Sn:+n}function Oc(n){return Bu(n,Nc(n))}function Ic(n){return n?$r(jc(n),-zn,zn):0===n?n:0}function Rc(n){return null==n?"":pu(n)}function zc(n,t){var r=_s(n);
return null==t?r:Wr(r,t)}function Ec(n,t){return v(n,bi(t,3),ee)}function Sc(n,t){return v(n,bi(t,3),ue)}function Wc(n,t){return null==n?n:ys(n,bi(t,3),Nc)}function Lc(n,t){return null==n?n:ds(n,bi(t,3),Nc)}function Cc(n,t){return n&&ee(n,bi(t,3))}function Uc(n,t){return n&&ue(n,bi(t,3))}function Bc(n){return null==n?[]:se(n,Fc(n))}function Tc(n){return null==n?[]:se(n,Nc(n))}function $c(n,t,r){var e=null==n?Y:ve(n,t);return e===Y?r:e}function Dc(n,t){return null!=n&&Oi(n,t,we)}function Mc(n,t){return null!=n&&Oi(n,t,me);
}function Fc(n){return Vf(n)?Ar(n):$e(n)}function Nc(n){return Vf(n)?Ar(n,!0):De(n)}function Pc(n,t){var r={};return t=bi(t,3),ee(n,function(n,e,u){Cr(r,t(n,e,u),n)}),r}function qc(n,t){var r={};return t=bi(t,3),ee(n,function(n,e,u){Cr(r,e,t(n,e,u))}),r}function Zc(n,t){return Kc(n,Lf(bi(t)))}function Kc(n,t){if(null==n)return{};var r=c(gi(n),function(n){return[n]});return t=bi(t),He(n,r,function(n,r){return t(n,r[0])})}function Vc(n,t,r){t=ju(t,n);var e=-1,u=t.length;for(u||(u=1,n=Y);++e<u;){var i=null==n?Y:n[Qi(t[e])];
i===Y&&(e=u,i=r),n=rc(i)?i.call(n):i}return n}function Gc(n,t,r){return null==n?n:iu(n,t,r)}function Hc(n,t,r,e){return e="function"==typeof e?e:Y,null==n?n:iu(n,t,r,e)}function Jc(n,t,e){var u=yh(n),i=u||bh(n)||Ah(n);if(t=bi(t,4),null==e){var o=n&&n.constructor;e=i?u?new o:[]:ic(n)&&rc(o)?_s(Rl(n)):{}}return(i?r:ee)(n,function(n,r,u){return t(e,n,r,u)}),e}function Yc(n,t){return null==n||vu(n,t)}function Qc(n,t,r){return null==n?n:gu(n,t,xu(r))}function Xc(n,t,r,e){return e="function"==typeof e?e:Y,
null==n?n:gu(n,t,xu(r),e)}function na(n){return null==n?[]:z(n,Fc(n))}function ta(n){return null==n?[]:z(n,Nc(n))}function ra(n,t,r){return r===Y&&(r=t,t=Y),r!==Y&&(r=kc(r),r=r===r?r:0),t!==Y&&(t=kc(t),t=t===t?t:0),$r(kc(n),t,r)}function ea(n,t,r){return t=xc(t),r===Y?(r=t,t=0):r=xc(r),n=kc(n),xe(n,t,r)}function ua(n,t,r){if(r&&"boolean"!=typeof r&&Li(n,t,r)&&(t=r=Y),r===Y&&("boolean"==typeof t?(r=t,t=Y):"boolean"==typeof n&&(r=n,n=Y)),n===Y&&t===Y?(n=0,t=1):(n=xc(n),t===Y?(t=n,n=0):t=xc(t)),n>t){
var e=n;n=t,t=e}if(r||n%1||t%1){var u=Jl();return Vl(n+u*(t-n+Hr("1e-"+((u+"").length-1))),t)}return Xe(n,t)}function ia(n){return Jh(Rc(n).toLowerCase())}function oa(n){return n=Rc(n),n&&n.replace(Zt,he).replace(Br,"")}function fa(n,t,r){n=Rc(n),t=pu(t);var e=n.length;r=r===Y?e:$r(jc(r),0,e);var u=r;return r-=t.length,r>=0&&n.slice(r,u)==t}function ca(n){return n=Rc(n),n&&mt.test(n)?n.replace(bt,pe):n}function aa(n){return n=Rc(n),n&&zt.test(n)?n.replace(Rt,"\\$&"):n}function la(n,t,r){n=Rc(n),t=jc(t);
var e=t?K(n):0;if(!t||e>=t)return n;var u=(t-e)/2;return ni(Ml(u),r)+n+ni(Dl(u),r)}function sa(n,t,r){n=Rc(n),t=jc(t);var e=t?K(n):0;return t&&e<t?n+ni(t-e,r):n}function ha(n,t,r){n=Rc(n),t=jc(t);var e=t?K(n):0;return t&&e<t?ni(t-e,r)+n:n}function pa(n,t,r){return r||null==t?t=0:t&&(t=+t),Hl(Rc(n).replace(St,""),t||0)}function _a(n,t,r){return t=(r?Li(n,t,r):t===Y)?1:jc(t),tu(Rc(n),t)}function va(){var n=arguments,t=Rc(n[0]);return n.length<3?t:t.replace(n[1],n[2])}function ga(n,t,r){return r&&"number"!=typeof r&&Li(n,t,r)&&(t=r=Y),
(r=r===Y?Wn:r>>>0)?(n=Rc(n),n&&("string"==typeof t||null!=t&&!xh(t))&&(t=pu(t),!t&&B(n))?Au(V(n),0,r):n.split(t,r)):[]}function ya(n,t,r){return n=Rc(n),r=null==r?0:$r(jc(r),0,n.length),t=pu(t),n.slice(r,r+t.length)==t}function da(n,t,r){var e=q.templateSettings;r&&Li(n,t,r)&&(t=Y),n=Rc(n),t=zh({},t,e,ci);var u,i,o=zh({},t.imports,e.imports,ci),f=Fc(o),c=z(o,f),a=0,l=t.interpolate||Kt,s="__p += '",h=al((t.escape||Kt).source+"|"+l.source+"|"+(l===At?$t:Kt).source+"|"+(t.evaluate||Kt).source+"|$","g"),p="//# sourceURL="+(yl.call(t,"sourceURL")?(t.sourceURL+"").replace(/\s/g," "):"lodash.templateSources["+ ++Nr+"]")+"\n";
n.replace(h,function(t,r,e,o,f,c){return e||(e=o),s+=n.slice(a,c).replace(Vt,C),r&&(u=!0,s+="' +\n__e("+r+") +\n'"),f&&(i=!0,s+="';\n"+f+";\n__p += '"),e&&(s+="' +\n((__t = ("+e+")) == null ? '' : __t) +\n'"),a=c+t.length,t}),s+="';\n";var _=yl.call(t,"variable")&&t.variable;_||(s="with (obj) {\n"+s+"\n}\n"),s=(i?s.replace(vt,""):s).replace(gt,"$1").replace(yt,"$1;"),s="function("+(_||"obj")+") {\n"+(_?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(u?", __e = _.escape":"")+(i?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+s+"return __p\n}";
var v=Yh(function(){return ol(f,p+"return "+s).apply(Y,c)});if(v.source=s,nc(v))throw v;return v}function ba(n){return Rc(n).toLowerCase()}function wa(n){return Rc(n).toUpperCase()}function ma(n,t,r){if(n=Rc(n),n&&(r||t===Y))return n.replace(Et,"");if(!n||!(t=pu(t)))return n;var e=V(n),u=V(t);return Au(e,S(e,u),W(e,u)+1).join("")}function xa(n,t,r){if(n=Rc(n),n&&(r||t===Y))return n.replace(Wt,"");if(!n||!(t=pu(t)))return n;var e=V(n);return Au(e,0,W(e,V(t))+1).join("")}function ja(n,t,r){if(n=Rc(n),
n&&(r||t===Y))return n.replace(St,"");if(!n||!(t=pu(t)))return n;var e=V(n);return Au(e,S(e,V(t))).join("")}function Aa(n,t){var r=mn,e=xn;if(ic(t)){var u="separator"in t?t.separator:u;r="length"in t?jc(t.length):r,e="omission"in t?pu(t.omission):e}n=Rc(n);var i=n.length;if(B(n)){var o=V(n);i=o.length}if(r>=i)return n;var f=r-K(e);if(f<1)return e;var c=o?Au(o,0,f).join(""):n.slice(0,f);if(u===Y)return c+e;if(o&&(f+=c.length-f),xh(u)){if(n.slice(f).search(u)){var a,l=c;for(u.global||(u=al(u.source,Rc(Dt.exec(u))+"g")),
u.lastIndex=0;a=u.exec(l);)var s=a.index;c=c.slice(0,s===Y?f:s)}}else if(n.indexOf(pu(u),f)!=f){var h=c.lastIndexOf(u);h>-1&&(c=c.slice(0,h))}return c+e}function ka(n){return n=Rc(n),n&&wt.test(n)?n.replace(dt,_e):n}function Oa(n,t,r){return n=Rc(n),t=r?Y:t,t===Y?T(n)?J(n):_(n):n.match(t)||[]}function Ia(t){var r=null==t?0:t.length,e=bi();return t=r?c(t,function(n){if("function"!=typeof n[1])throw new sl(tn);return[e(n[0]),n[1]]}):[],ru(function(e){for(var u=-1;++u<r;){var i=t[u];if(n(i[0],this,e))return n(i[1],this,e);
}})}function Ra(n){return Mr(Dr(n,on))}function za(n){return function(){return n}}function Ea(n,t){return null==n||n!==n?t:n}function Sa(n){return n}function Wa(n){return Te("function"==typeof n?n:Dr(n,on))}function La(n){return Ne(Dr(n,on))}function Ca(n,t){return Pe(n,Dr(t,on))}function Ua(n,t,e){var u=Fc(t),i=se(t,u);null!=e||ic(t)&&(i.length||!u.length)||(e=t,t=n,n=this,i=se(t,Fc(t)));var o=!(ic(e)&&"chain"in e&&!e.chain),f=rc(n);return r(i,function(r){var e=t[r];n[r]=e,f&&(n.prototype[r]=function(){
var t=this.__chain__;if(o||t){var r=n(this.__wrapped__);return(r.__actions__=Uu(this.__actions__)).push({func:e,args:arguments,thisArg:n}),r.__chain__=t,r}return e.apply(n,a([this.value()],arguments))})}),n}function Ba(){return Xr._===this&&(Xr._=xl),this}function Ta(){}function $a(n){return n=jc(n),ru(function(t){return Ke(t,n)})}function Da(n){return Ci(n)?m(Qi(n)):Je(n)}function Ma(n){return function(t){return null==n?Y:ve(n,t)}}function Fa(){return[]}function Na(){return!1}function Pa(){return{};
}function qa(){return""}function Za(){return!0}function Ka(n,t){if(n=jc(n),n<1||n>zn)return[];var r=Wn,e=Vl(n,Wn);t=bi(t),n-=Wn;for(var u=O(e,t);++r<n;)t(r);return u}function Va(n){return yh(n)?c(n,Qi):yc(n)?[n]:Uu(Ws(Rc(n)))}function Ga(n){var t=++dl;return Rc(n)+t}function Ha(n){return n&&n.length?Yr(n,Sa,be):Y}function Ja(n,t){return n&&n.length?Yr(n,bi(t,2),be):Y}function Ya(n){return w(n,Sa)}function Qa(n,t){return w(n,bi(t,2))}function Xa(n){return n&&n.length?Yr(n,Sa,Me):Y}function nl(n,t){
return n&&n.length?Yr(n,bi(t,2),Me):Y}function tl(n){return n&&n.length?k(n,Sa):0}function rl(n,t){return n&&n.length?k(n,bi(t,2)):0}x=null==x?Xr:ge.defaults(Xr.Object(),x,ge.pick(Xr,Fr));var el=x.Array,ul=x.Date,il=x.Error,ol=x.Function,fl=x.Math,cl=x.Object,al=x.RegExp,ll=x.String,sl=x.TypeError,hl=el.prototype,pl=ol.prototype,_l=cl.prototype,vl=x["__core-js_shared__"],gl=pl.toString,yl=_l.hasOwnProperty,dl=0,bl=function(){var n=/[^.]+$/.exec(vl&&vl.keys&&vl.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:"";
}(),wl=_l.toString,ml=gl.call(cl),xl=Xr._,jl=al("^"+gl.call(yl).replace(Rt,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Al=re?x.Buffer:Y,kl=x.Symbol,Ol=x.Uint8Array,Il=Al?Al.allocUnsafe:Y,Rl=M(cl.getPrototypeOf,cl),zl=cl.create,El=_l.propertyIsEnumerable,Sl=hl.splice,Wl=kl?kl.isConcatSpreadable:Y,Ll=kl?kl.iterator:Y,Cl=kl?kl.toStringTag:Y,Ul=function(){try{var n=xi(cl,"defineProperty");return n({},"",{}),n}catch(n){}}(),Bl=x.clearTimeout!==Xr.clearTimeout&&x.clearTimeout,Tl=ul&&ul.now!==Xr.Date.now&&ul.now,$l=x.setTimeout!==Xr.setTimeout&&x.setTimeout,Dl=fl.ceil,Ml=fl.floor,Fl=cl.getOwnPropertySymbols,Nl=Al?Al.isBuffer:Y,Pl=x.isFinite,ql=hl.join,Zl=M(cl.keys,cl),Kl=fl.max,Vl=fl.min,Gl=ul.now,Hl=x.parseInt,Jl=fl.random,Yl=hl.reverse,Ql=xi(x,"DataView"),Xl=xi(x,"Map"),ns=xi(x,"Promise"),ts=xi(x,"Set"),rs=xi(x,"WeakMap"),es=xi(cl,"create"),us=rs&&new rs,is={},os=Xi(Ql),fs=Xi(Xl),cs=Xi(ns),as=Xi(ts),ls=Xi(rs),ss=kl?kl.prototype:Y,hs=ss?ss.valueOf:Y,ps=ss?ss.toString:Y,_s=function(){
function n(){}return function(t){if(!ic(t))return{};if(zl)return zl(t);n.prototype=t;var r=new n;return n.prototype=Y,r}}();q.templateSettings={escape:xt,evaluate:jt,interpolate:At,variable:"",imports:{_:q}},q.prototype=G.prototype,q.prototype.constructor=q,H.prototype=_s(G.prototype),H.prototype.constructor=H,Bt.prototype=_s(G.prototype),Bt.prototype.constructor=Bt,Yt.prototype.clear=Qt,Yt.prototype.delete=Xt,Yt.prototype.get=nr,Yt.prototype.has=tr,Yt.prototype.set=rr,er.prototype.clear=ur,er.prototype.delete=ir,
er.prototype.get=or,er.prototype.has=fr,er.prototype.set=cr,ar.prototype.clear=lr,ar.prototype.delete=sr,ar.prototype.get=hr,ar.prototype.has=pr,ar.prototype.set=_r,vr.prototype.add=vr.prototype.push=gr,vr.prototype.has=yr,dr.prototype.clear=br,dr.prototype.delete=wr,dr.prototype.get=mr,dr.prototype.has=xr,dr.prototype.set=jr;var vs=Fu(ee),gs=Fu(ue,!0),ys=Nu(),ds=Nu(!0),bs=us?function(n,t){return us.set(n,t),n}:Sa,ws=Ul?function(n,t){return Ul(n,"toString",{configurable:!0,enumerable:!1,value:za(t),
writable:!0})}:Sa,ms=ru,xs=Bl||function(n){return Xr.clearTimeout(n)},js=ts&&1/N(new ts([,-0]))[1]==Rn?function(n){return new ts(n)}:Ta,As=us?function(n){return us.get(n)}:Ta,ks=Fl?function(n){return null==n?[]:(n=cl(n),i(Fl(n),function(t){return El.call(n,t)}))}:Fa,Os=Fl?function(n){for(var t=[];n;)a(t,ks(n)),n=Rl(n);return t}:Fa,Is=de;(Ql&&Is(new Ql(new ArrayBuffer(1)))!=it||Xl&&Is(new Xl)!=Zn||ns&&Is(ns.resolve())!=Hn||ts&&Is(new ts)!=Qn||rs&&Is(new rs)!=rt)&&(Is=function(n){var t=de(n),r=t==Gn?n.constructor:Y,e=r?Xi(r):"";
if(e)switch(e){case os:return it;case fs:return Zn;case cs:return Hn;case as:return Qn;case ls:return rt}return t});var Rs=vl?rc:Na,zs=Ji(bs),Es=$l||function(n,t){return Xr.setTimeout(n,t)},Ss=Ji(ws),Ws=Fi(function(n){var t=[];return 46===n.charCodeAt(0)&&t.push(""),n.replace(It,function(n,r,e,u){t.push(e?u.replace(Tt,"$1"):r||n)}),t}),Ls=ru(function(n,t){return Gf(n)?Vr(n,te(t,1,Gf,!0)):[]}),Cs=ru(function(n,t){var r=mo(t);return Gf(r)&&(r=Y),Gf(n)?Vr(n,te(t,1,Gf,!0),bi(r,2)):[]}),Us=ru(function(n,t){
var r=mo(t);return Gf(r)&&(r=Y),Gf(n)?Vr(n,te(t,1,Gf,!0),Y,r):[]}),Bs=ru(function(n){var t=c(n,mu);return t.length&&t[0]===n[0]?je(t):[]}),Ts=ru(function(n){var t=mo(n),r=c(n,mu);return t===mo(r)?t=Y:r.pop(),r.length&&r[0]===n[0]?je(r,bi(t,2)):[]}),$s=ru(function(n){var t=mo(n),r=c(n,mu);return t="function"==typeof t?t:Y,t&&r.pop(),r.length&&r[0]===n[0]?je(r,Y,t):[]}),Ds=ru(Ao),Ms=_i(function(n,t){var r=null==n?0:n.length,e=Tr(n,t);return Qe(n,c(t,function(n){return Wi(n,r)?+n:n}).sort(Su)),e}),Fs=ru(function(n){
return _u(te(n,1,Gf,!0))}),Ns=ru(function(n){var t=mo(n);return Gf(t)&&(t=Y),_u(te(n,1,Gf,!0),bi(t,2))}),Ps=ru(function(n){var t=mo(n);return t="function"==typeof t?t:Y,_u(te(n,1,Gf,!0),Y,t)}),qs=ru(function(n,t){return Gf(n)?Vr(n,t):[]}),Zs=ru(function(n){return bu(i(n,Gf))}),Ks=ru(function(n){var t=mo(n);return Gf(t)&&(t=Y),bu(i(n,Gf),bi(t,2))}),Vs=ru(function(n){var t=mo(n);return t="function"==typeof t?t:Y,bu(i(n,Gf),Y,t)}),Gs=ru(Ko),Hs=ru(function(n){var t=n.length,r=t>1?n[t-1]:Y;return r="function"==typeof r?(n.pop(),
r):Y,Vo(n,r)}),Js=_i(function(n){var t=n.length,r=t?n[0]:0,e=this.__wrapped__,u=function(t){return Tr(t,n)};return!(t>1||this.__actions__.length)&&e instanceof Bt&&Wi(r)?(e=e.slice(r,+r+(t?1:0)),e.__actions__.push({func:Qo,args:[u],thisArg:Y}),new H(e,this.__chain__).thru(function(n){return t&&!n.length&&n.push(Y),n})):this.thru(u)}),Ys=Du(function(n,t,r){yl.call(n,r)?++n[r]:Cr(n,r,1)}),Qs=Gu(lo),Xs=Gu(so),nh=Du(function(n,t,r){yl.call(n,r)?n[r].push(t):Cr(n,r,[t])}),th=ru(function(t,r,e){var u=-1,i="function"==typeof r,o=Vf(t)?el(t.length):[];
return vs(t,function(t){o[++u]=i?n(r,t,e):ke(t,r,e)}),o}),rh=Du(function(n,t,r){Cr(n,r,t)}),eh=Du(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),uh=ru(function(n,t){if(null==n)return[];var r=t.length;return r>1&&Li(n,t[0],t[1])?t=[]:r>2&&Li(t[0],t[1],t[2])&&(t=[t[0]]),Ve(n,te(t,1),[])}),ih=Tl||function(){return Xr.Date.now()},oh=ru(function(n,t,r){var e=sn;if(r.length){var u=F(r,di(oh));e|=gn}return fi(n,e,t,r,u)}),fh=ru(function(n,t,r){var e=sn|hn;if(r.length){var u=F(r,di(fh));e|=gn;
}return fi(t,e,n,r,u)}),ch=ru(function(n,t){return Kr(n,1,t)}),ah=ru(function(n,t,r){return Kr(n,kc(t)||0,r)});Wf.Cache=ar;var lh=ms(function(t,r){r=1==r.length&&yh(r[0])?c(r[0],R(bi())):c(te(r,1),R(bi()));var e=r.length;return ru(function(u){for(var i=-1,o=Vl(u.length,e);++i<o;)u[i]=r[i].call(this,u[i]);return n(t,this,u)})}),sh=ru(function(n,t){return fi(n,gn,Y,t,F(t,di(sh)))}),hh=ru(function(n,t){return fi(n,yn,Y,t,F(t,di(hh)))}),ph=_i(function(n,t){return fi(n,bn,Y,Y,Y,t)}),_h=ei(be),vh=ei(function(n,t){
return n>=t}),gh=Oe(function(){return arguments}())?Oe:function(n){return oc(n)&&yl.call(n,"callee")&&!El.call(n,"callee")},yh=el.isArray,dh=ie?R(ie):Ie,bh=Nl||Na,wh=oe?R(oe):Re,mh=fe?R(fe):Se,xh=ce?R(ce):Ce,jh=ae?R(ae):Ue,Ah=le?R(le):Be,kh=ei(Me),Oh=ei(function(n,t){return n<=t}),Ih=Mu(function(n,t){if($i(t)||Vf(t))return Bu(t,Fc(t),n),Y;for(var r in t)yl.call(t,r)&&zr(n,r,t[r])}),Rh=Mu(function(n,t){Bu(t,Nc(t),n)}),zh=Mu(function(n,t,r,e){Bu(t,Nc(t),n,e)}),Eh=Mu(function(n,t,r,e){Bu(t,Fc(t),n,e);
}),Sh=_i(Tr),Wh=ru(function(n,t){n=cl(n);var r=-1,e=t.length,u=e>2?t[2]:Y;for(u&&Li(t[0],t[1],u)&&(e=1);++r<e;)for(var i=t[r],o=Nc(i),f=-1,c=o.length;++f<c;){var a=o[f],l=n[a];(l===Y||Kf(l,_l[a])&&!yl.call(n,a))&&(n[a]=i[a])}return n}),Lh=ru(function(t){return t.push(Y,ai),n($h,Y,t)}),Ch=Yu(function(n,t,r){null!=t&&"function"!=typeof t.toString&&(t=wl.call(t)),n[t]=r},za(Sa)),Uh=Yu(function(n,t,r){null!=t&&"function"!=typeof t.toString&&(t=wl.call(t)),yl.call(n,t)?n[t].push(r):n[t]=[r]},bi),Bh=ru(ke),Th=Mu(function(n,t,r){
qe(n,t,r)}),$h=Mu(function(n,t,r,e){qe(n,t,r,e)}),Dh=_i(function(n,t){var r={};if(null==n)return r;var e=!1;t=c(t,function(t){return t=ju(t,n),e||(e=t.length>1),t}),Bu(n,gi(n),r),e&&(r=Dr(r,on|fn|cn,li));for(var u=t.length;u--;)vu(r,t[u]);return r}),Mh=_i(function(n,t){return null==n?{}:Ge(n,t)}),Fh=oi(Fc),Nh=oi(Nc),Ph=Zu(function(n,t,r){return t=t.toLowerCase(),n+(r?ia(t):t)}),qh=Zu(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Zh=Zu(function(n,t,r){return n+(r?" ":"")+t.toLowerCase()}),Kh=qu("toLowerCase"),Vh=Zu(function(n,t,r){
return n+(r?"_":"")+t.toLowerCase()}),Gh=Zu(function(n,t,r){return n+(r?" ":"")+Jh(t)}),Hh=Zu(function(n,t,r){return n+(r?" ":"")+t.toUpperCase()}),Jh=qu("toUpperCase"),Yh=ru(function(t,r){try{return n(t,Y,r)}catch(n){return nc(n)?n:new il(n)}}),Qh=_i(function(n,t){return r(t,function(t){t=Qi(t),Cr(n,t,oh(n[t],n))}),n}),Xh=Hu(),np=Hu(!0),tp=ru(function(n,t){return function(r){return ke(r,n,t)}}),rp=ru(function(n,t){return function(r){return ke(n,r,t)}}),ep=Xu(c),up=Xu(u),ip=Xu(h),op=ri(),fp=ri(!0),cp=Qu(function(n,t){
return n+t},0),ap=ii("ceil"),lp=Qu(function(n,t){return n/t},1),sp=ii("floor"),hp=Qu(function(n,t){return n*t},1),pp=ii("round"),_p=Qu(function(n,t){return n-t},0);return q.after=kf,q.ary=Of,q.assign=Ih,q.assignIn=Rh,q.assignInWith=zh,q.assignWith=Eh,q.at=Sh,q.before=If,q.bind=oh,q.bindAll=Qh,q.bindKey=fh,q.castArray=Mf,q.chain=Jo,q.chunk=ro,q.compact=eo,q.concat=uo,q.cond=Ia,q.conforms=Ra,q.constant=za,q.countBy=Ys,q.create=zc,q.curry=Rf,q.curryRight=zf,q.debounce=Ef,q.defaults=Wh,q.defaultsDeep=Lh,
q.defer=ch,q.delay=ah,q.difference=Ls,q.differenceBy=Cs,q.differenceWith=Us,q.drop=io,q.dropRight=oo,q.dropRightWhile=fo,q.dropWhile=co,q.fill=ao,q.filter=cf,q.flatMap=af,q.flatMapDeep=lf,q.flatMapDepth=sf,q.flatten=ho,q.flattenDeep=po,q.flattenDepth=_o,q.flip=Sf,q.flow=Xh,q.flowRight=np,q.fromPairs=vo,q.functions=Bc,q.functionsIn=Tc,q.groupBy=nh,q.initial=bo,q.intersection=Bs,q.intersectionBy=Ts,q.intersectionWith=$s,q.invert=Ch,q.invertBy=Uh,q.invokeMap=th,q.iteratee=Wa,q.keyBy=rh,q.keys=Fc,q.keysIn=Nc,
q.map=vf,q.mapKeys=Pc,q.mapValues=qc,q.matches=La,q.matchesProperty=Ca,q.memoize=Wf,q.merge=Th,q.mergeWith=$h,q.method=tp,q.methodOf=rp,q.mixin=Ua,q.negate=Lf,q.nthArg=$a,q.omit=Dh,q.omitBy=Zc,q.once=Cf,q.orderBy=gf,q.over=ep,q.overArgs=lh,q.overEvery=up,q.overSome=ip,q.partial=sh,q.partialRight=hh,q.partition=eh,q.pick=Mh,q.pickBy=Kc,q.property=Da,q.propertyOf=Ma,q.pull=Ds,q.pullAll=Ao,q.pullAllBy=ko,q.pullAllWith=Oo,q.pullAt=Ms,q.range=op,q.rangeRight=fp,q.rearg=ph,q.reject=bf,q.remove=Io,q.rest=Uf,
q.reverse=Ro,q.sampleSize=mf,q.set=Gc,q.setWith=Hc,q.shuffle=xf,q.slice=zo,q.sortBy=uh,q.sortedUniq=Bo,q.sortedUniqBy=To,q.split=ga,q.spread=Bf,q.tail=$o,q.take=Do,q.takeRight=Mo,q.takeRightWhile=Fo,q.takeWhile=No,q.tap=Yo,q.throttle=Tf,q.thru=Qo,q.toArray=mc,q.toPairs=Fh,q.toPairsIn=Nh,q.toPath=Va,q.toPlainObject=Oc,q.transform=Jc,q.unary=$f,q.union=Fs,q.unionBy=Ns,q.unionWith=Ps,q.uniq=Po,q.uniqBy=qo,q.uniqWith=Zo,q.unset=Yc,q.unzip=Ko,q.unzipWith=Vo,q.update=Qc,q.updateWith=Xc,q.values=na,q.valuesIn=ta,
q.without=qs,q.words=Oa,q.wrap=Df,q.xor=Zs,q.xorBy=Ks,q.xorWith=Vs,q.zip=Gs,q.zipObject=Go,q.zipObjectDeep=Ho,q.zipWith=Hs,q.entries=Fh,q.entriesIn=Nh,q.extend=Rh,q.extendWith=zh,Ua(q,q),q.add=cp,q.attempt=Yh,q.camelCase=Ph,q.capitalize=ia,q.ceil=ap,q.clamp=ra,q.clone=Ff,q.cloneDeep=Pf,q.cloneDeepWith=qf,q.cloneWith=Nf,q.conformsTo=Zf,q.deburr=oa,q.defaultTo=Ea,q.divide=lp,q.endsWith=fa,q.eq=Kf,q.escape=ca,q.escapeRegExp=aa,q.every=ff,q.find=Qs,q.findIndex=lo,q.findKey=Ec,q.findLast=Xs,q.findLastIndex=so,
q.findLastKey=Sc,q.floor=sp,q.forEach=hf,q.forEachRight=pf,q.forIn=Wc,q.forInRight=Lc,q.forOwn=Cc,q.forOwnRight=Uc,q.get=$c,q.gt=_h,q.gte=vh,q.has=Dc,q.hasIn=Mc,q.head=go,q.identity=Sa,q.includes=_f,q.indexOf=yo,q.inRange=ea,q.invoke=Bh,q.isArguments=gh,q.isArray=yh,q.isArrayBuffer=dh,q.isArrayLike=Vf,q.isArrayLikeObject=Gf,q.isBoolean=Hf,q.isBuffer=bh,q.isDate=wh,q.isElement=Jf,q.isEmpty=Yf,q.isEqual=Qf,q.isEqualWith=Xf,q.isError=nc,q.isFinite=tc,q.isFunction=rc,q.isInteger=ec,q.isLength=uc,q.isMap=mh,
q.isMatch=fc,q.isMatchWith=cc,q.isNaN=ac,q.isNative=lc,q.isNil=hc,q.isNull=sc,q.isNumber=pc,q.isObject=ic,q.isObjectLike=oc,q.isPlainObject=_c,q.isRegExp=xh,q.isSafeInteger=vc,q.isSet=jh,q.isString=gc,q.isSymbol=yc,q.isTypedArray=Ah,q.isUndefined=dc,q.isWeakMap=bc,q.isWeakSet=wc,q.join=wo,q.kebabCase=qh,q.last=mo,q.lastIndexOf=xo,q.lowerCase=Zh,q.lowerFirst=Kh,q.lt=kh,q.lte=Oh,q.max=Ha,q.maxBy=Ja,q.mean=Ya,q.meanBy=Qa,q.min=Xa,q.minBy=nl,q.stubArray=Fa,q.stubFalse=Na,q.stubObject=Pa,q.stubString=qa,
q.stubTrue=Za,q.multiply=hp,q.nth=jo,q.noConflict=Ba,q.noop=Ta,q.now=ih,q.pad=la,q.padEnd=sa,q.padStart=ha,q.parseInt=pa,q.random=ua,q.reduce=yf,q.reduceRight=df,q.repeat=_a,q.replace=va,q.result=Vc,q.round=pp,q.runInContext=p,q.sample=wf,q.size=jf,q.snakeCase=Vh,q.some=Af,q.sortedIndex=Eo,q.sortedIndexBy=So,q.sortedIndexOf=Wo,q.sortedLastIndex=Lo,q.sortedLastIndexBy=Co,q.sortedLastIndexOf=Uo,q.startCase=Gh,q.startsWith=ya,q.subtract=_p,q.sum=tl,q.sumBy=rl,q.template=da,q.times=Ka,q.toFinite=xc,q.toInteger=jc,
q.toLength=Ac,q.toLower=ba,q.toNumber=kc,q.toSafeInteger=Ic,q.toString=Rc,q.toUpper=wa,q.trim=ma,q.trimEnd=xa,q.trimStart=ja,q.truncate=Aa,q.unescape=ka,q.uniqueId=Ga,q.upperCase=Hh,q.upperFirst=Jh,q.each=hf,q.eachRight=pf,q.first=go,Ua(q,function(){var n={};return ee(q,function(t,r){yl.call(q.prototype,r)||(n[r]=t)}),n}(),{chain:!1}),q.VERSION=Q,r(["bind","bindKey","curry","curryRight","partial","partialRight"],function(n){q[n].placeholder=q}),r(["drop","take"],function(n,t){Bt.prototype[n]=function(r){
r=r===Y?1:Kl(jc(r),0);var e=this.__filtered__&&!t?new Bt(this):this.clone();return e.__filtered__?e.__takeCount__=Vl(r,e.__takeCount__):e.__views__.push({size:Vl(r,Wn),type:n+(e.__dir__<0?"Right":"")}),e},Bt.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse()}}),r(["filter","map","takeWhile"],function(n,t){var r=t+1,e=r==kn||r==In;Bt.prototype[n]=function(n){var t=this.clone();return t.__iteratees__.push({iteratee:bi(n,3),type:r}),t.__filtered__=t.__filtered__||e,t}}),r(["head","last"],function(n,t){
var r="take"+(t?"Right":"");Bt.prototype[n]=function(){return this[r](1).value()[0]}}),r(["initial","tail"],function(n,t){var r="drop"+(t?"":"Right");Bt.prototype[n]=function(){return this.__filtered__?new Bt(this):this[r](1)}}),Bt.prototype.compact=function(){return this.filter(Sa)},Bt.prototype.find=function(n){return this.filter(n).head()},Bt.prototype.findLast=function(n){return this.reverse().find(n)},Bt.prototype.invokeMap=ru(function(n,t){return"function"==typeof n?new Bt(this):this.map(function(r){
return ke(r,n,t)})}),Bt.prototype.reject=function(n){return this.filter(Lf(bi(n)))},Bt.prototype.slice=function(n,t){n=jc(n);var r=this;return r.__filtered__&&(n>0||t<0)?new Bt(r):(n<0?r=r.takeRight(-n):n&&(r=r.drop(n)),t!==Y&&(t=jc(t),r=t<0?r.dropRight(-t):r.take(t-n)),r)},Bt.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},Bt.prototype.toArray=function(){return this.take(Wn)},ee(Bt.prototype,function(n,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),e=/^(?:head|last)$/.test(t),u=q[e?"take"+("last"==t?"Right":""):t],i=e||/^find/.test(t);
u&&(q.prototype[t]=function(){var t=this.__wrapped__,o=e?[1]:arguments,f=t instanceof Bt,c=o[0],l=f||yh(t),s=function(n){var t=u.apply(q,a([n],o));return e&&h?t[0]:t};l&&r&&"function"==typeof c&&1!=c.length&&(f=l=!1);var h=this.__chain__,p=!!this.__actions__.length,_=i&&!h,v=f&&!p;if(!i&&l){t=v?t:new Bt(this);var g=n.apply(t,o);return g.__actions__.push({func:Qo,args:[s],thisArg:Y}),new H(g,h)}return _&&v?n.apply(this,o):(g=this.thru(s),_?e?g.value()[0]:g.value():g)})}),r(["pop","push","shift","sort","splice","unshift"],function(n){
var t=hl[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:pop|shift)$/.test(n);q.prototype[n]=function(){var n=arguments;if(e&&!this.__chain__){var u=this.value();return t.apply(yh(u)?u:[],n)}return this[r](function(r){return t.apply(yh(r)?r:[],n)})}}),ee(Bt.prototype,function(n,t){var r=q[t];if(r){var e=r.name+"";yl.call(is,e)||(is[e]=[]),is[e].push({name:t,func:r})}}),is[Ju(Y,hn).name]=[{name:"wrapper",func:Y}],Bt.prototype.clone=Gt,Bt.prototype.reverse=Ht,Bt.prototype.value=Jt,q.prototype.at=Js,
q.prototype.chain=Xo,q.prototype.commit=nf,q.prototype.next=tf,q.prototype.plant=ef,q.prototype.reverse=uf,q.prototype.toJSON=q.prototype.valueOf=q.prototype.value=of,q.prototype.first=q.prototype.head,Ll&&(q.prototype[Ll]=rf),q},ge=ve();"function"==typeof define&&"object"==typeof define.amd&&define.amd?(Xr._=ge,define(function(){return ge})):te?((te.exports=ge)._=ge,ne._=ge):Xr._=ge}).call(this);
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.decomp=e()}}(function(){return function e(f,o,n){function d(t,l){if(!o[t]){if(!f[t]){var u="function"==typeof require&&require;if(!l&&u)return u(t,!0);if(i)return i(t,!0);throw new Error("Cannot find module '"+t+"'")}var p=o[t]={exports:{}};f[t][0].call(p.exports,function(e){var o=f[t][1][e];return d(o?o:e)},p,p.exports,e,f,o,n)}return o[t].exports}for(var i="function"==typeof require&&require,t=0;t<n.length;t++)d(n[t]);return d}({1:[function(e,f,o){function n(e,f,o){o=o||0;var n,d,i,t,l,u,p,s=[0,0];return n=e[1][1]-e[0][1],d=e[0][0]-e[1][0],i=n*e[0][0]+d*e[0][1],t=f[1][1]-f[0][1],l=f[0][0]-f[1][0],u=t*f[0][0]+l*f[0][1],p=n*l-t*d,D(p,0,o)||(s[0]=(l*i-d*u)/p,s[1]=(n*u-t*i)/p),s}function d(e,f,o,n){var d=f[0]-e[0],i=f[1]-e[1],t=n[0]-o[0],l=n[1]-o[1];if(t*i-l*d===0)return!1;var u=(d*(o[1]-e[1])+i*(e[0]-o[0]))/(t*i-l*d),p=(t*(e[1]-o[1])+l*(o[0]-e[0]))/(l*d-t*i);return u>=0&&1>=u&&p>=0&&1>=p}function i(e,f,o){return(f[0]-e[0])*(o[1]-e[1])-(o[0]-e[0])*(f[1]-e[1])}function t(e,f,o){return i(e,f,o)>0}function l(e,f,o){return i(e,f,o)>=0}function u(e,f,o){return i(e,f,o)<0}function p(e,f,o){return i(e,f,o)<=0}function s(e,f,o,n){if(n){var d=F,t=G;d[0]=f[0]-e[0],d[1]=f[1]-e[1],t[0]=o[0]-f[0],t[1]=o[1]-f[1];var l=d[0]*t[0]+d[1]*t[1],u=Math.sqrt(d[0]*d[0]+d[1]*d[1]),p=Math.sqrt(t[0]*t[0]+t[1]*t[1]),s=Math.acos(l/(u*p));return n>s}return 0===i(e,f,o)}function c(e,f){var o=f[0]-e[0],n=f[1]-e[1];return o*o+n*n}function y(e,f){var o=e.length;return e[0>f?f%o+o:f%o]}function a(e){e.length=0}function m(e,f,o,n){for(var d=o;n>d;d++)e.push(f[d])}function r(e){for(var f=0,o=e,n=1;n<e.length;++n)(o[n][1]<o[f][1]||o[n][1]===o[f][1]&&o[n][0]>o[f][0])&&(f=n);return t(y(e,f-1),y(e,f),y(e,f+1))?!1:(w(e),!0)}function w(e){for(var f=[],o=e.length,n=0;n!==o;n++)f.push(e.pop());for(var n=0;n!==o;n++)e[n]=f[n]}function b(e,f){return u(y(e,f-1),y(e,f),y(e,f+1))}function g(e,f,o){var d,i,t=H,u=I;if(l(y(e,f+1),y(e,f),y(e,o))&&p(y(e,f-1),y(e,f),y(e,o)))return!1;i=c(y(e,f),y(e,o));for(var s=0;s!==e.length;++s)if((s+1)%e.length!==f&&s!==f&&l(y(e,f),y(e,o),y(e,s+1))&&p(y(e,f),y(e,o),y(e,s))&&(t[0]=y(e,f),t[1]=y(e,o),u[0]=y(e,s),u[1]=y(e,s+1),d=n(t,u),c(y(e,f),d)<i))return!1;return!0}function x(e,f,o){for(var n=0;n!==e.length;++n)if(n!==f&&n!==o&&(n+1)%e.length!==f&&(n+1)%e.length!==o&&d(y(e,f),y(e,o),y(e,n),y(e,n+1)))return!1;return!0}function j(e,f,o,n){var d=n||[];if(a(d),o>f)for(var i=f;o>=i;i++)d.push(e[i]);else{for(var i=0;o>=i;i++)d.push(e[i]);for(var i=f;i<e.length;i++)d.push(e[i])}return d}function v(e){for(var f=[],o=[],n=[],d=[],i=Number.MAX_VALUE,t=0;t<e.length;++t)if(b(e,t))for(var l=0;l<e.length;++l)if(g(e,t,l)){o=v(j(e,t,l,d)),n=v(j(e,l,t,d));for(var u=0;u<n.length;u++)o.push(n[u]);o.length<i&&(f=o,i=o.length,f.push([y(e,t),y(e,l)]))}return f}function h(e){var f=v(e);return f.length>0?k(e,f):[e]}function k(e,f){if(0===f.length)return[e];if(f instanceof Array&&f.length&&f[0]instanceof Array&&2===f[0].length&&f[0][0]instanceof Array){for(var o=[e],n=0;n<f.length;n++)for(var d=f[n],i=0;i<o.length;i++){var t=o[i],l=k(t,d);if(l){o.splice(i,1),o.push(l[0],l[1]);break}}return o}var d=f,n=e.indexOf(d[0]),i=e.indexOf(d[1]);return-1!==n&&-1!==i?[j(e,n,i),j(e,i,n)]:!1}function q(e){var f,o=e;for(f=0;f<o.length-1;f++)for(var n=0;f-1>n;n++)if(d(o[f],o[f+1],o[n],o[n+1]))return!1;for(f=1;f<o.length-2;f++)if(d(o[0],o[o.length-1],o[f],o[f+1]))return!1;return!0}function z(e,f,o,n,d){d=d||0;var i=f[1]-e[1],t=e[0]-f[0],l=i*e[0]+t*e[1],u=n[1]-o[1],p=o[0]-n[0],s=u*o[0]+p*o[1],c=i*p-u*t;return D(c,0,d)?[0,0]:[(p*l-t*s)/c,(i*s-u*l)/c]}function A(e,f,o,n,d,i,s){i=i||100,s=s||0,d=d||25,f="undefined"!=typeof f?f:[],o=o||[],n=n||[];var a=[0,0],r=[0,0],w=[0,0],g=0,j=0,v=0,h=0,k=0,q=0,B=0,C=[],D=[],E=e,F=e;if(F.length<3)return f;if(s++,s>i)return console.warn("quickDecomp: max level ("+i+") reached."),f;for(var G=0;G<e.length;++G)if(b(E,G)){o.push(E[G]),g=j=Number.MAX_VALUE;for(var H=0;H<e.length;++H)t(y(E,G-1),y(E,G),y(E,H))&&p(y(E,G-1),y(E,G),y(E,H-1))&&(w=z(y(E,G-1),y(E,G),y(E,H),y(E,H-1)),u(y(E,G+1),y(E,G),w)&&(v=c(E[G],w),j>v&&(j=v,r=w,q=H))),t(y(E,G+1),y(E,G),y(E,H+1))&&p(y(E,G+1),y(E,G),y(E,H))&&(w=z(y(E,G+1),y(E,G),y(E,H),y(E,H+1)),t(y(E,G-1),y(E,G),w)&&(v=c(E[G],w),g>v&&(g=v,a=w,k=H)));if(q===(k+1)%e.length)w[0]=(r[0]+a[0])/2,w[1]=(r[1]+a[1])/2,n.push(w),k>G?(m(C,E,G,k+1),C.push(w),D.push(w),0!==q&&m(D,E,q,E.length),m(D,E,0,G+1)):(0!==G&&m(C,E,G,E.length),m(C,E,0,k+1),C.push(w),D.push(w),m(D,E,q,G+1));else{if(q>k&&(k+=e.length),h=Number.MAX_VALUE,q>k)return f;for(var H=q;k>=H;++H)l(y(E,G-1),y(E,G),y(E,H))&&p(y(E,G+1),y(E,G),y(E,H))&&(v=c(y(E,G),y(E,H)),h>v&&x(E,G,H)&&(h=v,B=H%e.length));B>G?(m(C,E,G,B+1),0!==B&&m(D,E,B,F.length),m(D,E,0,G+1)):(0!==G&&m(C,E,G,F.length),m(C,E,0,B+1),m(D,E,B,G+1))}return C.length<D.length?(A(C,f,o,n,d,i,s),A(D,f,o,n,d,i,s)):(A(D,f,o,n,d,i,s),A(C,f,o,n,d,i,s)),f}return f.push(e),f}function B(e,f){for(var o=0,n=e.length-1;e.length>3&&n>=0;--n)s(y(e,n-1),y(e,n),y(e,n+1),f)&&(e.splice(n%e.length,1),o++);return o}function C(e,f){for(var o=e.length-1;o>=1;--o)for(var n=e[o],d=o-1;d>=0;--d)E(n,e[d],f)&&e.splice(o,1)}function D(e,f,o){return o=o||0,Math.abs(e-f)<=o}function E(e,f,o){return D(e[0],f[0],o)&&D(e[1],f[1],o)}f.exports={decomp:h,quickDecomp:A,isSimple:q,removeCollinearPoints:B,removeDuplicatePoints:C,makeCCW:r};var F=[],G=[],H=[],I=[]},{}]},{},[1])(1)});
/**
* matter-js 0.14.2 by @liabru 2018-06-11
* http://brm.io/matter-js/
* License MIT
*/

/**
 * The MIT License (MIT)
 * 
 * Copyright (c) Liam Brummitt and contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Matter = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(_dereq_,module,exports){
/**
* The `Matter.Body` module contains methods for creating and manipulating body models.
* A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.
* Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).

* @class Body
*/

var Body = {};

module.exports = Body;

var Vertices = _dereq_('../geometry/Vertices');
var Vector = _dereq_('../geometry/Vector');
var Sleeping = _dereq_('../core/Sleeping');
var Render = _dereq_('../render/Render');
var Common = _dereq_('../core/Common');
var Bounds = _dereq_('../geometry/Bounds');
var Axes = _dereq_('../geometry/Axes');

(function() {

    Body._inertiaScale = 4;
    Body._nextCollidingGroupId = 1;
    Body._nextNonCollidingGroupId = -1;
    Body._nextCategory = 0x0001;

    /**
     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * Vertices must be specified in clockwise order.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {body} body
     */
    Body.create = function(options) {
        var defaults = {
            id: Common.nextId(),
            type: 'body',
            label: 'Body',
            parts: [],
            plugin: {},
            angle: 0,
            vertices: Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),
            position: { x: 0, y: 0 },
            force: { x: 0, y: 0 },
            torque: 0,
            positionImpulse: { x: 0, y: 0 },
            constraintImpulse: { x: 0, y: 0, angle: 0 },
            totalContacts: 0,
            speed: 0,
            angularSpeed: 0,
            velocity: { x: 0, y: 0 },
            angularVelocity: 0,
            isSensor: false,
            isStatic: false,
            isSleeping: false,
            motion: 0,
            sleepThreshold: 60,
            density: 0.001,
            restitution: 0,
            friction: 0.1,
            frictionStatic: 0.5,
            frictionAir: 0.01,
            collisionFilter: {
                category: 0x0001,
                mask: 0xFFFFFFFF,
                group: 0
            },
            slop: 0.05,
            timeScale: 1,
            render: {
                visible: true,
                opacity: 1,
                sprite: {
                    xScale: 1,
                    yScale: 1,
                    xOffset: 0,
                    yOffset: 0
                },
                lineWidth: 0
            }
        };

        var body = Common.extend(defaults, options);

        _initProperties(body, options);

        return body;
    };

    /**
     * Returns the next unique group index for which bodies will collide.
     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.
     * See `body.collisionFilter` for more information.
     * @method nextGroup
     * @param {bool} [isNonColliding=false]
     * @return {Number} Unique group index
     */
    Body.nextGroup = function(isNonColliding) {
        if (isNonColliding)
            return Body._nextNonCollidingGroupId--;

        return Body._nextCollidingGroupId++;
    };

    /**
     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).
     * There are 32 available. See `body.collisionFilter` for more information.
     * @method nextCategory
     * @return {Number} Unique category bitfield
     */
    Body.nextCategory = function() {
        Body._nextCategory = Body._nextCategory << 1;
        return Body._nextCategory;
    };

    /**
     * Initialises body properties.
     * @method _initProperties
     * @private
     * @param {body} body
     * @param {} [options]
     */
    var _initProperties = function(body, options) {
        options = options || {};

        // init required properties (order is important)
        Body.set(body, {
            bounds: body.bounds || Bounds.create(body.vertices),
            positionPrev: body.positionPrev || Vector.clone(body.position),
            anglePrev: body.anglePrev || body.angle,
            vertices: body.vertices,
            parts: body.parts || [body],
            isStatic: body.isStatic,
            isSleeping: body.isSleeping,
            parent: body.parent || body
        });

        Vertices.rotate(body.vertices, body.angle, body.position);
        Axes.rotate(body.axes, body.angle);
        Bounds.update(body.bounds, body.vertices, body.velocity);

        // allow options to override the automatically calculated properties
        Body.set(body, {
            axes: options.axes || body.axes,
            area: options.area || body.area,
            mass: options.mass || body.mass,
            inertia: options.inertia || body.inertia
        });

        // render properties
        var defaultFillStyle = (body.isStatic ? '#2e2b44' : Common.choose(['#006BA6', '#0496FF', '#FFBC42', '#D81159', '#8F2D56'])),
            defaultStrokeStyle = '#000';
        body.render.fillStyle = body.render.fillStyle || defaultFillStyle;
        body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;
        body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);
        body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);
    };

    /**
     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.
     * Prefer to use the actual setter functions in performance critical situations.
     * @method set
     * @param {body} body
     * @param {} settings A property name (or map of properties and values) to set on the body.
     * @param {} value The value to set if `settings` is a single property name.
     */
    Body.set = function(body, settings, value) {
        var property;

        if (typeof settings === 'string') {
            property = settings;
            settings = {};
            settings[property] = value;
        }

        for (property in settings) {
            value = settings[property];

            if (!settings.hasOwnProperty(property))
                continue;

            switch (property) {

            case 'isStatic':
                Body.setStatic(body, value);
                break;
            case 'isSleeping':
                Sleeping.set(body, value);
                break;
            case 'mass':
                Body.setMass(body, value);
                break;
            case 'density':
                Body.setDensity(body, value);
                break;
            case 'inertia':
                Body.setInertia(body, value);
                break;
            case 'vertices':
                Body.setVertices(body, value);
                break;
            case 'position':
                Body.setPosition(body, value);
                break;
            case 'angle':
                Body.setAngle(body, value);
                break;
            case 'velocity':
                Body.setVelocity(body, value);
                break;
            case 'angularVelocity':
                Body.setAngularVelocity(body, value);
                break;
            case 'parts':
                Body.setParts(body, value);
                break;
            default:
                body[property] = value;

            }
        }
    };

    /**
     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
     * @method setStatic
     * @param {body} body
     * @param {bool} isStatic
     */
    Body.setStatic = function(body, isStatic) {
        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];
            part.isStatic = isStatic;

            if (isStatic) {
                part._original = {
                    restitution: part.restitution,
                    friction: part.friction,
                    mass: part.mass,
                    inertia: part.inertia,
                    density: part.density,
                    inverseMass: part.inverseMass,
                    inverseInertia: part.inverseInertia
                };

                part.restitution = 0;
                part.friction = 1;
                part.mass = part.inertia = part.density = Infinity;
                part.inverseMass = part.inverseInertia = 0;

                part.positionPrev.x = part.position.x;
                part.positionPrev.y = part.position.y;
                part.anglePrev = part.angle;
                part.angularVelocity = 0;
                part.speed = 0;
                part.angularSpeed = 0;
                part.motion = 0;
            } else if (part._original) {
                part.restitution = part._original.restitution;
                part.friction = part._original.friction;
                part.mass = part._original.mass;
                part.inertia = part._original.inertia;
                part.density = part._original.density;
                part.inverseMass = part._original.inverseMass;
                part.inverseInertia = part._original.inverseInertia;

                delete part._original;
            }
        }
    };

    /**
     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.
     * @method setMass
     * @param {body} body
     * @param {number} mass
     */
    Body.setMass = function(body, mass) {
        var moment = body.inertia / (body.mass / 6);
        body.inertia = moment * (mass / 6);
        body.inverseInertia = 1 / body.inertia;

        body.mass = mass;
        body.inverseMass = 1 / body.mass;
        body.density = body.mass / body.area;
    };

    /**
     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.
     * @method setDensity
     * @param {body} body
     * @param {number} density
     */
    Body.setDensity = function(body, density) {
        Body.setMass(body, density * body.area);
        body.density = density;
    };

    /**
     * Sets the moment of inertia (i.e. second moment of area) of the body of the body. 
     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
     * @method setInertia
     * @param {body} body
     * @param {number} inertia
     */
    Body.setInertia = function(body, inertia) {
        body.inertia = inertia;
        body.inverseInertia = 1 / body.inertia;
    };

    /**
     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).
     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
     * They are then automatically translated to world space based on `body.position`.
     *
     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).
     * Vertices must form a convex hull, concave hulls are not supported.
     *
     * @method setVertices
     * @param {body} body
     * @param {vector[]} vertices
     */
    Body.setVertices = function(body, vertices) {
        // change vertices
        if (vertices[0].body === body) {
            body.vertices = vertices;
        } else {
            body.vertices = Vertices.create(vertices, body);
        }

        // update properties
        body.axes = Axes.fromVertices(body.vertices);
        body.area = Vertices.area(body.vertices);
        Body.setMass(body, body.density * body.area);

        // orient vertices around the centre of mass at origin (0, 0)
        var centre = Vertices.centre(body.vertices);
        Vertices.translate(body.vertices, centre, -1);

        // update inertia while vertices are at origin (0, 0)
        Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));

        // update geometry
        Vertices.translate(body.vertices, body.position);
        Bounds.update(body.bounds, body.vertices, body.velocity);
    };

    /**
     * Sets the parts of the `body` and updates mass, inertia and centroid.
     * Each part will have its parent set to `body`.
     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.
     * @method setParts
     * @param {body} body
     * @param [body] parts
     * @param {bool} [autoHull=true]
     */
    Body.setParts = function(body, parts, autoHull) {
        var i;

        // add all the parts, ensuring that the first part is always the parent body
        parts = parts.slice(0);
        body.parts.length = 0;
        body.parts.push(body);
        body.parent = body;

        for (i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part !== body) {
                part.parent = body;
                body.parts.push(part);
            }
        }

        if (body.parts.length === 1)
            return;

        autoHull = typeof autoHull !== 'undefined' ? autoHull : true;

        // find the convex hull of all parts to set on the parent body
        if (autoHull) {
            var vertices = [];
            for (i = 0; i < parts.length; i++) {
                vertices = vertices.concat(parts[i].vertices);
            }

            Vertices.clockwiseSort(vertices);

            var hull = Vertices.hull(vertices),
                hullCentre = Vertices.centre(hull);

            Body.setVertices(body, hull);
            Vertices.translate(body.vertices, hullCentre);
        }

        // sum the properties of all compound parts of the parent body
        var total = Body._totalProperties(body);

        body.area = total.area;
        body.parent = body;
        body.position.x = total.centre.x;
        body.position.y = total.centre.y;
        body.positionPrev.x = total.centre.x;
        body.positionPrev.y = total.centre.y;

        Body.setMass(body, total.mass);
        Body.setInertia(body, total.inertia);
        Body.setPosition(body, total.centre);
    };

    /**
     * Sets the position of the body instantly. Velocity, angle, force etc. are unchanged.
     * @method setPosition
     * @param {body} body
     * @param {vector} position
     */
    Body.setPosition = function(body, position) {
        var delta = Vector.sub(position, body.position);
        body.positionPrev.x += delta.x;
        body.positionPrev.y += delta.y;

        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];
            part.position.x += delta.x;
            part.position.y += delta.y;
            Vertices.translate(part.vertices, delta);
            Bounds.update(part.bounds, part.vertices, body.velocity);
        }
    };

    /**
     * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.
     * @method setAngle
     * @param {body} body
     * @param {number} angle
     */
    Body.setAngle = function(body, angle) {
        var delta = angle - body.angle;
        body.anglePrev += delta;

        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];
            part.angle += delta;
            Vertices.rotate(part.vertices, delta, body.position);
            Axes.rotate(part.axes, delta);
            Bounds.update(part.bounds, part.vertices, body.velocity);
            if (i > 0) {
                Vector.rotateAbout(part.position, delta, body.position, part.position);
            }
        }
    };

    /**
     * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setVelocity
     * @param {body} body
     * @param {vector} velocity
     */
    Body.setVelocity = function(body, velocity) {
        body.positionPrev.x = body.position.x - velocity.x;
        body.positionPrev.y = body.position.y - velocity.y;
        body.velocity.x = velocity.x;
        body.velocity.y = velocity.y;
        body.speed = Vector.magnitude(body.velocity);
    };

    /**
     * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
     * @method setAngularVelocity
     * @param {body} body
     * @param {number} velocity
     */
    Body.setAngularVelocity = function(body, velocity) {
        body.anglePrev = body.angle - velocity;
        body.angularVelocity = velocity;
        body.angularSpeed = Math.abs(body.angularVelocity);
    };

    /**
     * Moves a body by a given vector relative to its current position, without imparting any velocity.
     * @method translate
     * @param {body} body
     * @param {vector} translation
     */
    Body.translate = function(body, translation) {
        Body.setPosition(body, Vector.add(body.position, translation));
    };

    /**
     * Rotates a body by a given angle relative to its current angle, without imparting any angular velocity.
     * @method rotate
     * @param {body} body
     * @param {number} rotation
     * @param {vector} [point]
     */
    Body.rotate = function(body, rotation, point) {
        if (!point) {
            Body.setAngle(body, body.angle + rotation);
        } else {
            var cos = Math.cos(rotation),
                sin = Math.sin(rotation),
                dx = body.position.x - point.x,
                dy = body.position.y - point.y;
                
            Body.setPosition(body, {
                x: point.x + (dx * cos - dy * sin),
                y: point.y + (dx * sin + dy * cos)
            });

            Body.setAngle(body, body.angle + rotation);
        }
    };

    /**
     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).
     * @method scale
     * @param {body} body
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} [point]
     */
    Body.scale = function(body, scaleX, scaleY, point) {
        var totalArea = 0,
            totalInertia = 0;

        point = point || body.position;

        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];

            // scale vertices
            Vertices.scale(part.vertices, scaleX, scaleY, point);

            // update properties
            part.axes = Axes.fromVertices(part.vertices);
            part.area = Vertices.area(part.vertices);
            Body.setMass(part, body.density * part.area);

            // update inertia (requires vertices to be at origin)
            Vertices.translate(part.vertices, { x: -part.position.x, y: -part.position.y });
            Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));
            Vertices.translate(part.vertices, { x: part.position.x, y: part.position.y });

            if (i > 0) {
                totalArea += part.area;
                totalInertia += part.inertia;
            }

            // scale position
            part.position.x = point.x + (part.position.x - point.x) * scaleX;
            part.position.y = point.y + (part.position.y - point.y) * scaleY;

            // update bounds
            Bounds.update(part.bounds, part.vertices, body.velocity);
        }

        // handle parent body
        if (body.parts.length > 1) {
            body.area = totalArea;

            if (!body.isStatic) {
                Body.setMass(body, body.density * totalArea);
                Body.setInertia(body, totalInertia);
            }
        }

        // handle circles
        if (body.circleRadius) { 
            if (scaleX === scaleY) {
                body.circleRadius *= scaleX;
            } else {
                // body is no longer a circle
                body.circleRadius = null;
            }
        }
    };

    /**
     * Performs a simulation step for the given `body`, including updating position and angle using Verlet integration.
     * @method update
     * @param {body} body
     * @param {number} deltaTime
     * @param {number} timeScale
     * @param {number} correction
     */
    Body.update = function(body, deltaTime, timeScale, correction) {
        var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);

        // from the previous step
        var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale,
            velocityPrevX = body.position.x - body.positionPrev.x,
            velocityPrevY = body.position.y - body.positionPrev.y;

        // update velocity with Verlet integration
        body.velocity.x = (velocityPrevX * frictionAir * correction) + (body.force.x / body.mass) * deltaTimeSquared;
        body.velocity.y = (velocityPrevY * frictionAir * correction) + (body.force.y / body.mass) * deltaTimeSquared;

        body.positionPrev.x = body.position.x;
        body.positionPrev.y = body.position.y;
        body.position.x += body.velocity.x;
        body.position.y += body.velocity.y;

        // update angular velocity with Verlet integration
        body.angularVelocity = ((body.angle - body.anglePrev) * frictionAir * correction) + (body.torque / body.inertia) * deltaTimeSquared;
        body.anglePrev = body.angle;
        body.angle += body.angularVelocity;

        // track speed and acceleration
        body.speed = Vector.magnitude(body.velocity);
        body.angularSpeed = Math.abs(body.angularVelocity);

        // transform the body geometry
        for (var i = 0; i < body.parts.length; i++) {
            var part = body.parts[i];

            Vertices.translate(part.vertices, body.velocity);
            
            if (i > 0) {
                part.position.x += body.velocity.x;
                part.position.y += body.velocity.y;
            }

            if (body.angularVelocity !== 0) {
                Vertices.rotate(part.vertices, body.angularVelocity, body.position);
                Axes.rotate(part.axes, body.angularVelocity);
                if (i > 0) {
                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);
                }
            }

            Bounds.update(part.bounds, part.vertices, body.velocity);
        }
    };

    /**
     * Applies a force to a body from a given world-space position, including resulting torque.
     * @method applyForce
     * @param {body} body
     * @param {vector} position
     * @param {vector} force
     */
    Body.applyForce = function(body, position, force) {
        body.force.x += force.x;
        body.force.y += force.y;
        var offset = { x: position.x - body.position.x, y: position.y - body.position.y };
        body.torque += offset.x * force.y - offset.y * force.x;
    };

    /**
     * Returns the sums of the properties of all compound parts of the parent body.
     * @method _totalProperties
     * @private
     * @param {body} body
     * @return {}
     */
    Body._totalProperties = function(body) {
        // from equations at:
        // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory
        // http://output.to/sideway/default.asp?qno=121100087

        var properties = {
            mass: 0,
            area: 0,
            inertia: 0,
            centre: { x: 0, y: 0 }
        };

        // sum the properties of all compound parts of the parent body
        for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {
            var part = body.parts[i],
                mass = part.mass !== Infinity ? part.mass : 1;

            properties.mass += mass;
            properties.area += part.area;
            properties.inertia += part.inertia;
            properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));
        }

        properties.centre = Vector.div(properties.centre, properties.mass);

        return properties;
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired when a body starts sleeping (where `this` is the body).
    *
    * @event sleepStart
    * @this {body} The body that has started sleeping
    * @param {} event An event object
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a body ends sleeping (where `this` is the body).
    *
    * @event sleepEnd
    * @this {body} The body that has ended sleeping
    * @param {} event An event object
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "body"
     * @readOnly
     */

    /**
     * An arbitrary `String` name to help the user identify and manage bodies.
     *
     * @property label
     * @type string
     * @default "Body"
     */

    /**
     * An array of bodies that make up this body. 
     * The first body in the array must always be a self reference to the current body instance.
     * All bodies in the `parts` array together form a single rigid compound body.
     * Parts are allowed to overlap, have gaps or holes or even form concave bodies.
     * Parts themselves should never be added to a `World`, only the parent body should be.
     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.
     *
     * @property parts
     * @type body[]
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

    /**
     * A self reference if the body is _not_ a part of another body.
     * Otherwise this is a reference to the body that this is a part of.
     * See `body.parts`.
     *
     * @property parent
     * @type body
     */

    /**
     * A `Number` specifying the angle of the body, in radians.
     *
     * @property angle
     * @type number
     * @default 0
     */

    /**
     * An array of `Vector` objects that specify the convex hull of the rigid body.
     * These should be provided about the origin `(0, 0)`. E.g.
     *
     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
     *
     * When passed via `Body.create`, the vertices are translated relative to `body.position` (i.e. world-space, and constantly updated by `Body.update` during simulation).
     * The `Vector` objects are also augmented with additional properties required for efficient collision detection. 
     *
     * Other properties such as `inertia` and `bounds` are automatically calculated from the passed vertices (unless provided via `options`).
     * Concave hulls are not currently supported. The module `Matter.Vertices` contains useful methods for working with vertices.
     *
     * @property vertices
     * @type vector[]
     */

    /**
     * A `Vector` that specifies the current world-space position of the body.
     *
     * @property position
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Vector` that specifies the force to apply in the current step. It is zeroed after every `Body.update`. See also `Body.applyForce`.
     *
     * @property force
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Number` that specifies the torque (turning force) to apply in the current step. It is zeroed after every `Body.update`.
     *
     * @property torque
     * @type number
     * @default 0
     */

    /**
     * A `Number` that _measures_ the current speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.velocity`).
     *
     * @readOnly
     * @property speed
     * @type number
     * @default 0
     */

    /**
     * A `Number` that _measures_ the current angular speed of the body after the last `Body.update`. It is read-only and always positive (it's the magnitude of `body.angularVelocity`).
     *
     * @readOnly
     * @property angularSpeed
     * @type number
     * @default 0
     */

    /**
     * A `Vector` that _measures_ the current velocity of the body after the last `Body.update`. It is read-only. 
     * If you need to modify a body's velocity directly, you should either apply a force or simply change the body's `position` (as the engine uses position-Verlet integration).
     *
     * @readOnly
     * @property velocity
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Number` that _measures_ the current angular velocity of the body after the last `Body.update`. It is read-only. 
     * If you need to modify a body's angular velocity directly, you should apply a torque or simply change the body's `angle` (as the engine uses position-Verlet integration).
     *
     * @readOnly
     * @property angularVelocity
     * @type number
     * @default 0
     */

    /**
     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.
     * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.
     *
     * @property isStatic
     * @type boolean
     * @default false
     */

    /**
     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.
     *
     * @property isSensor
     * @type boolean
     * @default false
     */

    /**
     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.
     * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.
     *
     * @property isSleeping
     * @type boolean
     * @default false
     */

    /**
     * A `Number` that _measures_ the amount of movement a body currently has (a combination of `speed` and `angularSpeed`). It is read-only and always positive.
     * It is used and updated by the `Matter.Sleeping` module during simulation to decide if a body has come to rest.
     *
     * @readOnly
     * @property motion
     * @type number
     * @default 0
     */

    /**
     * A `Number` that defines the number of updates in which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).
     *
     * @property sleepThreshold
     * @type number
     * @default 60
     */

    /**
     * A `Number` that defines the density of the body, that is its mass per unit area.
     * If you pass the density via `Body.create` the `mass` property is automatically calculated for you based on the size (area) of the object.
     * This is generally preferable to simply setting mass and allows for more intuitive definition of materials (e.g. rock has a higher density than wood).
     *
     * @property density
     * @type number
     * @default 0.001
     */

    /**
     * A `Number` that defines the mass of the body, although it may be more appropriate to specify the `density` property instead.
     * If you modify this value, you must also modify the `body.inverseMass` property (`1 / mass`).
     *
     * @property mass
     * @type number
     */

    /**
     * A `Number` that defines the inverse mass of the body (`1 / mass`).
     * If you modify this value, you must also modify the `body.mass` property.
     *
     * @property inverseMass
     * @type number
     */

    /**
     * A `Number` that defines the moment of inertia (i.e. second moment of area) of the body.
     * It is automatically calculated from the given convex hull (`vertices` array) and density in `Body.create`.
     * If you modify this value, you must also modify the `body.inverseInertia` property (`1 / inertia`).
     *
     * @property inertia
     * @type number
     */

    /**
     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).
     * If you modify this value, you must also modify the `body.inertia` property.
     *
     * @property inverseInertia
     * @type number
     */

    /**
     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.
     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. 
     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.
     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:
     *
     *     Math.max(bodyA.restitution, bodyB.restitution)
     *
     * @property restitution
     * @type number
     * @default 0
     */

    /**
     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.
     * A value of `0` means that the body may slide indefinitely.
     * A value of `1` means the body may come to a stop almost instantly after a force is applied.
     *
     * The effects of the value may be non-linear. 
     * High values may be unstable depending on the body.
     * The engine uses a Coulomb friction model including static and kinetic friction.
     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:
     *
     *     Math.min(bodyA.friction, bodyB.friction)
     *
     * @property friction
     * @type number
     * @default 0.1
     */

    /**
     * A `Number` that defines the static friction of the body (in the Coulomb friction model). 
     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.
     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.
     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.
     *
     * @property frictionStatic
     * @type number
     * @default 0.5
     */

    /**
     * A `Number` that defines the air friction of the body (air resistance). 
     * A value of `0` means the body will never slow as it moves through space.
     * The higher the value, the faster a body slows when moving through space.
     * The effects of the value are non-linear. 
     *
     * @property frictionAir
     * @type number
     * @default 0.01
     */

    /**
     * An `Object` that specifies the collision filtering properties of this body.
     *
     * Collisions between two bodies will obey the following rules:
     * - If the two bodies have the same non-zero value of `collisionFilter.group`,
     *   they will always collide if the value is positive, and they will never collide
     *   if the value is negative.
     * - If the two bodies have different values of `collisionFilter.group` or if one
     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:
     *
     * Each body belongs to a collision category, given by `collisionFilter.category`. This
     * value is used as a bit field and the category should have only one bit set, meaning that
     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32
     * different collision categories available.
     *
     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies
     * the categories it collides with (the value is the bitwise AND value of all these categories).
     *
     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's
     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`
     * are both true.
     *
     * @property collisionFilter
     * @type object
     */

    /**
     * An Integer `Number`, that specifies the collision group this body belongs to.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.group
     * @type object
     * @default 0
     */

    /**
     * A bit field that specifies the collision category this body belongs to.
     * The category value should have only one bit set, for example `0x0001`.
     * This means there are up to 32 unique collision categories available.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.category
     * @type object
     * @default 1
     */

    /**
     * A bit mask that specifies the collision categories this body may collide with.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter.mask
     * @type object
     * @default -1
     */

    /**
     * A `Number` that specifies a tolerance on how far a body is allowed to 'sink' or rotate into other bodies.
     * Avoid changing this value unless you understand the purpose of `slop` in physics engines.
     * The default should generally suffice, although very large bodies may require larger values for stable stacking.
     *
     * @property slop
     * @type number
     * @default 0.05
     */

    /**
     * A `Number` that allows per-body time scaling, e.g. a force-field where bodies inside are in slow-motion, while others are at full speed.
     *
     * @property timeScale
     * @type number
     * @default 1
     */

    /**
     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
     *
     * @property render
     * @type object
     */

    /**
     * A flag that indicates if the body should be rendered.
     *
     * @property render.visible
     * @type boolean
     * @default true
     */

    /**
     * Sets the opacity to use when rendering.
     *
     * @property render.opacity
     * @type number
     * @default 1
    */

    /**
     * An `Object` that defines the sprite properties to use when rendering, if any.
     *
     * @property render.sprite
     * @type object
     */

    /**
     * An `String` that defines the path to the image to use as the sprite texture, if any.
     *
     * @property render.sprite.texture
     * @type string
     */
     
    /**
     * A `Number` that defines the scaling in the x-axis for the sprite, if any.
     *
     * @property render.sprite.xScale
     * @type number
     * @default 1
     */

    /**
     * A `Number` that defines the scaling in the y-axis for the sprite, if any.
     *
     * @property render.sprite.yScale
     * @type number
     * @default 1
     */

     /**
      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).
      *
      * @property render.sprite.xOffset
      * @type number
      * @default 0
      */

     /**
      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).
      *
      * @property render.sprite.yOffset
      * @type number
      * @default 0
      */

    /**
     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).
     * A value of `0` means no outline will be rendered.
     *
     * @property render.lineWidth
     * @type number
     * @default 0
     */

    /**
     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.fillStyle
     * @type string
     * @default a random colour
     */

    /**
     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.strokeStyle
     * @type string
     * @default a random colour
     */

    /**
     * An array of unique axis vectors (edge normals) used for collision detection.
     * These are automatically calculated from the given convex hull (`vertices` array) in `Body.create`.
     * They are constantly updated by `Body.update` during the simulation.
     *
     * @property axes
     * @type vector[]
     */
     
    /**
     * A `Number` that _measures_ the area of the body's convex hull, calculated at creation by `Body.create`.
     *
     * @property area
     * @type string
     * @default 
     */

    /**
     * A `Bounds` object that defines the AABB region for the body.
     * It is automatically calculated from the given convex hull (`vertices` array) in `Body.create` and constantly updated by `Body.update` during simulation.
     *
     * @property bounds
     * @type bounds
     */

})();

},{"../core/Common":14,"../core/Sleeping":22,"../geometry/Axes":25,"../geometry/Bounds":26,"../geometry/Vector":28,"../geometry/Vertices":29,"../render/Render":31}],2:[function(_dereq_,module,exports){
/**
* The `Matter.Composite` module contains methods for creating and manipulating composite bodies.
* A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.
* It is important to use the functions in this module to modify composites, rather than directly modifying their properties.
* Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composite
*/

var Composite = {};

module.exports = Composite;

var Events = _dereq_('../core/Events');
var Common = _dereq_('../core/Common');
var Bounds = _dereq_('../geometry/Bounds');
var Body = _dereq_('./Body');

(function() {

    /**
     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properites section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} [options]
     * @return {composite} A new composite
     */
    Composite.create = function(options) {
        return Common.extend({ 
            id: Common.nextId(),
            type: 'composite',
            parent: null,
            isModified: false,
            bodies: [], 
            constraints: [], 
            composites: [],
            label: 'Composite',
            plugin: {}
        }, options);
    };

    /**
     * Sets the composite's `isModified` flag. 
     * If `updateParents` is true, all parents will be set (default: false).
     * If `updateChildren` is true, all children will be set (default: false).
     * @method setModified
     * @param {composite} composite
     * @param {boolean} isModified
     * @param {boolean} [updateParents=false]
     * @param {boolean} [updateChildren=false]
     */
    Composite.setModified = function(composite, isModified, updateParents, updateChildren) {
        composite.isModified = isModified;

        if (updateParents && composite.parent) {
            Composite.setModified(composite.parent, isModified, updateParents, updateChildren);
        }

        if (updateChildren) {
            for(var i = 0; i < composite.composites.length; i++) {
                var childComposite = composite.composites[i];
                Composite.setModified(childComposite, isModified, updateParents, updateChildren);
            }
        }
    };

    /**
     * Generic add function. Adds one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.
     * @method add
     * @param {composite} composite
     * @param {} object
     * @return {composite} The original composite with the objects added
     */
    Composite.add = function(composite, object) {
        var objects = [].concat(object);

        Events.trigger(composite, 'beforeAdd', { object: object });

        for (var i = 0; i < objects.length; i++) {
            var obj = objects[i];

            switch (obj.type) {

            case 'body':
                // skip adding compound parts
                if (obj.parent !== obj) {
                    Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');
                    break;
                }

                Composite.addBody(composite, obj);
                break;
            case 'constraint':
                Composite.addConstraint(composite, obj);
                break;
            case 'composite':
                Composite.addComposite(composite, obj);
                break;
            case 'mouseConstraint':
                Composite.addConstraint(composite, obj.constraint);
                break;

            }
        }

        Events.trigger(composite, 'afterAdd', { object: object });

        return composite;
    };

    /**
     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.
     * Optionally searching its children recursively.
     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.
     * @method remove
     * @param {composite} composite
     * @param {} object
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the objects removed
     */
    Composite.remove = function(composite, object, deep) {
        var objects = [].concat(object);

        Events.trigger(composite, 'beforeRemove', { object: object });

        for (var i = 0; i < objects.length; i++) {
            var obj = objects[i];

            switch (obj.type) {

            case 'body':
                Composite.removeBody(composite, obj, deep);
                break;
            case 'constraint':
                Composite.removeConstraint(composite, obj, deep);
                break;
            case 'composite':
                Composite.removeComposite(composite, obj, deep);
                break;
            case 'mouseConstraint':
                Composite.removeConstraint(composite, obj.constraint);
                break;

            }
        }

        Events.trigger(composite, 'afterRemove', { object: object });

        return composite;
    };

    /**
     * Adds a composite to the given composite.
     * @private
     * @method addComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @return {composite} The original compositeA with the objects from compositeB added
     */
    Composite.addComposite = function(compositeA, compositeB) {
        compositeA.composites.push(compositeB);
        compositeB.parent = compositeA;
        Composite.setModified(compositeA, true, true, false);
        return compositeA;
    };

    /**
     * Removes a composite from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeComposite
     * @param {composite} compositeA
     * @param {composite} compositeB
     * @param {boolean} [deep=false]
     * @return {composite} The original compositeA with the composite removed
     */
    Composite.removeComposite = function(compositeA, compositeB, deep) {
        var position = Common.indexOf(compositeA.composites, compositeB);
        if (position !== -1) {
            Composite.removeCompositeAt(compositeA, position);
            Composite.setModified(compositeA, true, true, false);
        }

        if (deep) {
            for (var i = 0; i < compositeA.composites.length; i++){
                Composite.removeComposite(compositeA.composites[i], compositeB, true);
            }
        }

        return compositeA;
    };

    /**
     * Removes a composite from the given composite.
     * @private
     * @method removeCompositeAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the composite removed
     */
    Composite.removeCompositeAt = function(composite, position) {
        composite.composites.splice(position, 1);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Adds a body to the given composite.
     * @private
     * @method addBody
     * @param {composite} composite
     * @param {body} body
     * @return {composite} The original composite with the body added
     */
    Composite.addBody = function(composite, body) {
        composite.bodies.push(body);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Removes a body from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeBody
     * @param {composite} composite
     * @param {body} body
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the body removed
     */
    Composite.removeBody = function(composite, body, deep) {
        var position = Common.indexOf(composite.bodies, body);
        if (position !== -1) {
            Composite.removeBodyAt(composite, position);
            Composite.setModified(composite, true, true, false);
        }

        if (deep) {
            for (var i = 0; i < composite.composites.length; i++){
                Composite.removeBody(composite.composites[i], body, true);
            }
        }

        return composite;
    };

    /**
     * Removes a body from the given composite.
     * @private
     * @method removeBodyAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the body removed
     */
    Composite.removeBodyAt = function(composite, position) {
        composite.bodies.splice(position, 1);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Adds a constraint to the given composite.
     * @private
     * @method addConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @return {composite} The original composite with the constraint added
     */
    Composite.addConstraint = function(composite, constraint) {
        composite.constraints.push(constraint);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Removes a constraint from the given composite, and optionally searching its children recursively.
     * @private
     * @method removeConstraint
     * @param {composite} composite
     * @param {constraint} constraint
     * @param {boolean} [deep=false]
     * @return {composite} The original composite with the constraint removed
     */
    Composite.removeConstraint = function(composite, constraint, deep) {
        var position = Common.indexOf(composite.constraints, constraint);
        if (position !== -1) {
            Composite.removeConstraintAt(composite, position);
        }

        if (deep) {
            for (var i = 0; i < composite.composites.length; i++){
                Composite.removeConstraint(composite.composites[i], constraint, true);
            }
        }

        return composite;
    };

    /**
     * Removes a body from the given composite.
     * @private
     * @method removeConstraintAt
     * @param {composite} composite
     * @param {number} position
     * @return {composite} The original composite with the constraint removed
     */
    Composite.removeConstraintAt = function(composite, position) {
        composite.constraints.splice(position, 1);
        Composite.setModified(composite, true, true, false);
        return composite;
    };

    /**
     * Removes all bodies, constraints and composites from the given composite.
     * Optionally clearing its children recursively.
     * @method clear
     * @param {composite} composite
     * @param {boolean} keepStatic
     * @param {boolean} [deep=false]
     */
    Composite.clear = function(composite, keepStatic, deep) {
        if (deep) {
            for (var i = 0; i < composite.composites.length; i++){
                Composite.clear(composite.composites[i], keepStatic, true);
            }
        }
        
        if (keepStatic) {
            composite.bodies = composite.bodies.filter(function(body) { return body.isStatic; });
        } else {
            composite.bodies.length = 0;
        }

        composite.constraints.length = 0;
        composite.composites.length = 0;
        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Returns all bodies in the given composite, including all bodies in its children, recursively.
     * @method allBodies
     * @param {composite} composite
     * @return {body[]} All the bodies
     */
    Composite.allBodies = function(composite) {
        var bodies = [].concat(composite.bodies);

        for (var i = 0; i < composite.composites.length; i++)
            bodies = bodies.concat(Composite.allBodies(composite.composites[i]));

        return bodies;
    };

    /**
     * Returns all constraints in the given composite, including all constraints in its children, recursively.
     * @method allConstraints
     * @param {composite} composite
     * @return {constraint[]} All the constraints
     */
    Composite.allConstraints = function(composite) {
        var constraints = [].concat(composite.constraints);

        for (var i = 0; i < composite.composites.length; i++)
            constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));

        return constraints;
    };

    /**
     * Returns all composites in the given composite, including all composites in its children, recursively.
     * @method allComposites
     * @param {composite} composite
     * @return {composite[]} All the composites
     */
    Composite.allComposites = function(composite) {
        var composites = [].concat(composite.composites);

        for (var i = 0; i < composite.composites.length; i++)
            composites = composites.concat(Composite.allComposites(composite.composites[i]));

        return composites;
    };

    /**
     * Searches the composite recursively for an object matching the type and id supplied, null if not found.
     * @method get
     * @param {composite} composite
     * @param {number} id
     * @param {string} type
     * @return {object} The requested object, if found
     */
    Composite.get = function(composite, id, type) {
        var objects,
            object;

        switch (type) {
        case 'body':
            objects = Composite.allBodies(composite);
            break;
        case 'constraint':
            objects = Composite.allConstraints(composite);
            break;
        case 'composite':
            objects = Composite.allComposites(composite).concat(composite);
            break;
        }

        if (!objects)
            return null;

        object = objects.filter(function(object) { 
            return object.id.toString() === id.toString(); 
        });

        return object.length === 0 ? null : object[0];
    };

    /**
     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).
     * @method move
     * @param {compositeA} compositeA
     * @param {object[]} objects
     * @param {compositeB} compositeB
     * @return {composite} Returns compositeA
     */
    Composite.move = function(compositeA, objects, compositeB) {
        Composite.remove(compositeA, objects);
        Composite.add(compositeB, objects);
        return compositeA;
    };

    /**
     * Assigns new ids for all objects in the composite, recursively.
     * @method rebase
     * @param {composite} composite
     * @return {composite} Returns composite
     */
    Composite.rebase = function(composite) {
        var objects = Composite.allBodies(composite)
                        .concat(Composite.allConstraints(composite))
                        .concat(Composite.allComposites(composite));

        for (var i = 0; i < objects.length; i++) {
            objects[i].id = Common.nextId();
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Translates all children in the composite by a given vector relative to their current positions, 
     * without imparting any velocity.
     * @method translate
     * @param {composite} composite
     * @param {vector} translation
     * @param {bool} [recursive=true]
     */
    Composite.translate = function(composite, translation, recursive) {
        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;

        for (var i = 0; i < bodies.length; i++) {
            Body.translate(bodies[i], translation);
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.
     * @method rotate
     * @param {composite} composite
     * @param {number} rotation
     * @param {vector} point
     * @param {bool} [recursive=true]
     */
    Composite.rotate = function(composite, rotation, point, recursive) {
        var cos = Math.cos(rotation),
            sin = Math.sin(rotation),
            bodies = recursive ? Composite.allBodies(composite) : composite.bodies;

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                dx = body.position.x - point.x,
                dy = body.position.y - point.y;
                
            Body.setPosition(body, {
                x: point.x + (dx * cos - dy * sin),
                y: point.y + (dx * sin + dy * cos)
            });

            Body.rotate(body, rotation);
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.
     * @method scale
     * @param {composite} composite
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     * @param {bool} [recursive=true]
     */
    Composite.scale = function(composite, scaleX, scaleY, point, recursive) {
        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                dx = body.position.x - point.x,
                dy = body.position.y - point.y;
                
            Body.setPosition(body, {
                x: point.x + dx * scaleX,
                y: point.y + dy * scaleY
            });

            Body.scale(body, scaleX, scaleY);
        }

        Composite.setModified(composite, true, true, false);

        return composite;
    };

    /**
     * Returns the union of the bounds of all of the composite's bodies.
     * @method bounds
     * @param {composite} composite The composite.
     * @returns {bounds} The composite bounds.
     */
    Composite.bounds = function(composite) {
        var bodies = Composite.allBodies(composite),
            vertices = [];

        for (var i = 0; i < bodies.length; i += 1) {
            var body = bodies[i];
            vertices.push(body.bounds.min, body.bounds.max);
        }

        return Bounds.create(vertices);
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired when a call to `Composite.add` is made, before objects have been added.
    *
    * @event beforeAdd
    * @param {} event An event object
    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a call to `Composite.add` is made, after objects have been added.
    *
    * @event afterAdd
    * @param {} event An event object
    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a call to `Composite.remove` is made, before objects have been removed.
    *
    * @event beforeRemove
    * @param {} event An event object
    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when a call to `Composite.remove` is made, after objects have been removed.
    *
    * @event afterRemove
    * @param {} event An event object
    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "composite"
     * @readOnly
     */

    /**
     * An arbitrary `String` name to help the user identify and manage composites.
     *
     * @property label
     * @type string
     * @default "Composite"
     */

    /**
     * A flag that specifies whether the composite has been modified during the current step.
     * Most `Matter.Composite` methods will automatically set this flag to `true` to inform the engine of changes to be handled.
     * If you need to change it manually, you should use the `Composite.setModified` method.
     *
     * @property isModified
     * @type boolean
     * @default false
     */

    /**
     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.
     *
     * @property parent
     * @type composite
     * @default null
     */

    /**
     * An array of `Body` that are _direct_ children of this composite.
     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.
     *
     * @property bodies
     * @type body[]
     * @default []
     */

    /**
     * An array of `Constraint` that are _direct_ children of this composite.
     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.
     *
     * @property constraints
     * @type constraint[]
     * @default []
     */

    /**
     * An array of `Composite` that are _direct_ children of this composite.
     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.
     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.
     *
     * @property composites
     * @type composite[]
     * @default []
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

})();

},{"../core/Common":14,"../core/Events":16,"../geometry/Bounds":26,"./Body":1}],3:[function(_dereq_,module,exports){
/**
* The `Matter.World` module contains methods for creating and manipulating the world composite.
* A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.
* A `Matter.World` has a few additional properties including `gravity` and `bounds`.
* It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.
* There are also a few methods here that alias those in `Matter.Composite` for easier readability.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class World
* @extends Composite
*/

var World = {};

module.exports = World;

var Composite = _dereq_('./Composite');
var Constraint = _dereq_('../constraint/Constraint');
var Common = _dereq_('../core/Common');

(function() {

    /**
     * Creates a new world composite. The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @constructor
     * @param {} options
     * @return {world} A new world
     */
    World.create = function(options) {
        var composite = Composite.create();

        var defaults = {
            label: 'World',
            gravity: {
                x: 0,
                y: 1,
                scale: 0.001
            },
            bounds: { 
                min: { x: -Infinity, y: -Infinity }, 
                max: { x: Infinity, y: Infinity } 
            }
        };
        
        return Common.extend(composite, defaults, options);
    };

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * The gravity to apply on the world.
     *
     * @property gravity
     * @type object
     */

    /**
     * The gravity x component.
     *
     * @property gravity.x
     * @type object
     * @default 0
     */

    /**
     * The gravity y component.
     *
     * @property gravity.y
     * @type object
     * @default 1
     */

    /**
     * The gravity scale factor.
     *
     * @property gravity.scale
     * @type object
     * @default 0.001
     */

    /**
     * A `Bounds` object that defines the world bounds for collision detection.
     *
     * @property bounds
     * @type bounds
     * @default { min: { x: -Infinity, y: -Infinity }, max: { x: Infinity, y: Infinity } }
     */

    // World is a Composite body
    // see src/module/Outro.js for these aliases:
    
    /**
     * An alias for Composite.add
     * @method add
     * @param {world} world
     * @param {} object
     * @return {composite} The original world with the objects added
     */

    /**
     * An alias for Composite.remove
     * @method remove
     * @param {world} world
     * @param {} object
     * @param {boolean} [deep=false]
     * @return {composite} The original world with the objects removed
     */

    /**
     * An alias for Composite.clear
     * @method clear
     * @param {world} world
     * @param {boolean} keepStatic
     */

    /**
     * An alias for Composite.addComposite
     * @method addComposite
     * @param {world} world
     * @param {composite} composite
     * @return {world} The original world with the objects from composite added
     */
    
     /**
      * An alias for Composite.addBody
      * @method addBody
      * @param {world} world
      * @param {body} body
      * @return {world} The original world with the body added
      */

     /**
      * An alias for Composite.addConstraint
      * @method addConstraint
      * @param {world} world
      * @param {constraint} constraint
      * @return {world} The original world with the constraint added
      */

})();

},{"../constraint/Constraint":12,"../core/Common":14,"./Composite":2}],4:[function(_dereq_,module,exports){
/**
* The `Matter.Contact` module contains methods for creating and manipulating collision contacts.
*
* @class Contact
*/

var Contact = {};

module.exports = Contact;

(function() {

    /**
     * Creates a new contact.
     * @method create
     * @param {vertex} vertex
     * @return {contact} A new contact
     */
    Contact.create = function(vertex) {
        return {
            id: Contact.id(vertex),
            vertex: vertex,
            normalImpulse: 0,
            tangentImpulse: 0
        };
    };
    
    /**
     * Generates a contact id.
     * @method id
     * @param {vertex} vertex
     * @return {string} Unique contactID
     */
    Contact.id = function(vertex) {
        return vertex.body.id + '_' + vertex.index;
    };

})();

},{}],5:[function(_dereq_,module,exports){
/**
* The `Matter.Detector` module contains methods for detecting collisions given a set of pairs.
*
* @class Detector
*/

// TODO: speculative contacts

var Detector = {};

module.exports = Detector;

var SAT = _dereq_('./SAT');
var Pair = _dereq_('./Pair');
var Bounds = _dereq_('../geometry/Bounds');

(function() {

    /**
     * Finds all collisions given a list of pairs.
     * @method collisions
     * @param {pair[]} broadphasePairs
     * @param {engine} engine
     * @return {array} collisions
     */
    Detector.collisions = function(broadphasePairs, engine) {
        var collisions = [],
            pairsTable = engine.pairs.table;

        
        for (var i = 0; i < broadphasePairs.length; i++) {
            var bodyA = broadphasePairs[i][0], 
                bodyB = broadphasePairs[i][1];

            if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))
                continue;
            
            if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))
                continue;


            // mid phase
            if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {
                for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {
                    var partA = bodyA.parts[j];

                    for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {
                        var partB = bodyB.parts[k];

                        if ((partA === bodyA && partB === bodyB) || Bounds.overlaps(partA.bounds, partB.bounds)) {
                            // find a previous collision we could reuse
                            var pairId = Pair.id(partA, partB),
                                pair = pairsTable[pairId],
                                previousCollision;

                            if (pair && pair.isActive) {
                                previousCollision = pair.collision;
                            } else {
                                previousCollision = null;
                            }

                            // narrow phase
                            var collision = SAT.collides(partA, partB, previousCollision);


                            if (collision.collided) {
                                collisions.push(collision);
                            }
                        }
                    }
                }
            }
        }

        return collisions;
    };

    /**
     * Returns `true` if both supplied collision filters will allow a collision to occur.
     * See `body.collisionFilter` for more information.
     * @method canCollide
     * @param {} filterA
     * @param {} filterB
     * @return {bool} `true` if collision can occur
     */
    Detector.canCollide = function(filterA, filterB) {
        if (filterA.group === filterB.group && filterA.group !== 0)
            return filterA.group > 0;

        return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;
    };

})();

},{"../geometry/Bounds":26,"./Pair":7,"./SAT":11}],6:[function(_dereq_,module,exports){
/**
* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.
*
* @class Grid
*/

var Grid = {};

module.exports = Grid;

var Pair = _dereq_('./Pair');
var Detector = _dereq_('./Detector');
var Common = _dereq_('../core/Common');

(function() {

    /**
     * Creates a new grid.
     * @method create
     * @param {} options
     * @return {grid} A new grid
     */
    Grid.create = function(options) {
        var defaults = {
            controller: Grid,
            detector: Detector.collisions,
            buckets: {},
            pairs: {},
            pairsList: [],
            bucketWidth: 48,
            bucketHeight: 48
        };

        return Common.extend(defaults, options);
    };

    /**
     * The width of a single grid bucket.
     *
     * @property bucketWidth
     * @type number
     * @default 48
     */

    /**
     * The height of a single grid bucket.
     *
     * @property bucketHeight
     * @type number
     * @default 48
     */

    /**
     * Updates the grid.
     * @method update
     * @param {grid} grid
     * @param {body[]} bodies
     * @param {engine} engine
     * @param {boolean} forceUpdate
     */
    Grid.update = function(grid, bodies, engine, forceUpdate) {
        var i, col, row,
            world = engine.world,
            buckets = grid.buckets,
            bucket,
            bucketId,
            gridChanged = false;


        for (i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.isSleeping && !forceUpdate)
                continue;

            // don't update out of world bodies
            if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x
                || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)
                continue;

            var newRegion = Grid._getRegion(grid, body);

            // if the body has changed grid region
            if (!body.region || newRegion.id !== body.region.id || forceUpdate) {


                if (!body.region || forceUpdate)
                    body.region = newRegion;

                var union = Grid._regionUnion(newRegion, body.region);

                // update grid buckets affected by region change
                // iterate over the union of both regions
                for (col = union.startCol; col <= union.endCol; col++) {
                    for (row = union.startRow; row <= union.endRow; row++) {
                        bucketId = Grid._getBucketId(col, row);
                        bucket = buckets[bucketId];

                        var isInsideNewRegion = (col >= newRegion.startCol && col <= newRegion.endCol
                                                && row >= newRegion.startRow && row <= newRegion.endRow);

                        var isInsideOldRegion = (col >= body.region.startCol && col <= body.region.endCol
                                                && row >= body.region.startRow && row <= body.region.endRow);

                        // remove from old region buckets
                        if (!isInsideNewRegion && isInsideOldRegion) {
                            if (isInsideOldRegion) {
                                if (bucket)
                                    Grid._bucketRemoveBody(grid, bucket, body);
                            }
                        }

                        // add to new region buckets
                        if (body.region === newRegion || (isInsideNewRegion && !isInsideOldRegion) || forceUpdate) {
                            if (!bucket)
                                bucket = Grid._createBucket(buckets, bucketId);
                            Grid._bucketAddBody(grid, bucket, body);
                        }
                    }
                }

                // set the new region
                body.region = newRegion;

                // flag changes so we can update pairs
                gridChanged = true;
            }
        }

        // update pairs list only if pairs changed (i.e. a body changed region)
        if (gridChanged)
            grid.pairsList = Grid._createActivePairsList(grid);
    };

    /**
     * Clears the grid.
     * @method clear
     * @param {grid} grid
     */
    Grid.clear = function(grid) {
        grid.buckets = {};
        grid.pairs = {};
        grid.pairsList = [];
    };

    /**
     * Finds the union of two regions.
     * @method _regionUnion
     * @private
     * @param {} regionA
     * @param {} regionB
     * @return {} region
     */
    Grid._regionUnion = function(regionA, regionB) {
        var startCol = Math.min(regionA.startCol, regionB.startCol),
            endCol = Math.max(regionA.endCol, regionB.endCol),
            startRow = Math.min(regionA.startRow, regionB.startRow),
            endRow = Math.max(regionA.endRow, regionB.endRow);

        return Grid._createRegion(startCol, endCol, startRow, endRow);
    };

    /**
     * Gets the region a given body falls in for a given grid.
     * @method _getRegion
     * @private
     * @param {} grid
     * @param {} body
     * @return {} region
     */
    Grid._getRegion = function(grid, body) {
        var bounds = body.bounds,
            startCol = Math.floor(bounds.min.x / grid.bucketWidth),
            endCol = Math.floor(bounds.max.x / grid.bucketWidth),
            startRow = Math.floor(bounds.min.y / grid.bucketHeight),
            endRow = Math.floor(bounds.max.y / grid.bucketHeight);

        return Grid._createRegion(startCol, endCol, startRow, endRow);
    };

    /**
     * Creates a region.
     * @method _createRegion
     * @private
     * @param {} startCol
     * @param {} endCol
     * @param {} startRow
     * @param {} endRow
     * @return {} region
     */
    Grid._createRegion = function(startCol, endCol, startRow, endRow) {
        return { 
            id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,
            startCol: startCol, 
            endCol: endCol, 
            startRow: startRow, 
            endRow: endRow 
        };
    };

    /**
     * Gets the bucket id at the given position.
     * @method _getBucketId
     * @private
     * @param {} column
     * @param {} row
     * @return {string} bucket id
     */
    Grid._getBucketId = function(column, row) {
        return 'C' + column + 'R' + row;
    };

    /**
     * Creates a bucket.
     * @method _createBucket
     * @private
     * @param {} buckets
     * @param {} bucketId
     * @return {} bucket
     */
    Grid._createBucket = function(buckets, bucketId) {
        var bucket = buckets[bucketId] = [];
        return bucket;
    };

    /**
     * Adds a body to a bucket.
     * @method _bucketAddBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */
    Grid._bucketAddBody = function(grid, bucket, body) {
        // add new pairs
        for (var i = 0; i < bucket.length; i++) {
            var bodyB = bucket[i];

            if (body.id === bodyB.id || (body.isStatic && bodyB.isStatic))
                continue;

            // keep track of the number of buckets the pair exists in
            // important for Grid.update to work
            var pairId = Pair.id(body, bodyB),
                pair = grid.pairs[pairId];

            if (pair) {
                pair[2] += 1;
            } else {
                grid.pairs[pairId] = [body, bodyB, 1];
            }
        }

        // add to bodies (after pairs, otherwise pairs with self)
        bucket.push(body);
    };

    /**
     * Removes a body from a bucket.
     * @method _bucketRemoveBody
     * @private
     * @param {} grid
     * @param {} bucket
     * @param {} body
     */
    Grid._bucketRemoveBody = function(grid, bucket, body) {
        // remove from bucket
        bucket.splice(Common.indexOf(bucket, body), 1);

        // update pair counts
        for (var i = 0; i < bucket.length; i++) {
            // keep track of the number of buckets the pair exists in
            // important for _createActivePairsList to work
            var bodyB = bucket[i],
                pairId = Pair.id(body, bodyB),
                pair = grid.pairs[pairId];

            if (pair)
                pair[2] -= 1;
        }
    };

    /**
     * Generates a list of the active pairs in the grid.
     * @method _createActivePairsList
     * @private
     * @param {} grid
     * @return [] pairs
     */
    Grid._createActivePairsList = function(grid) {
        var pairKeys,
            pair,
            pairs = [];

        // grid.pairs is used as a hashmap
        pairKeys = Common.keys(grid.pairs);

        // iterate over grid.pairs
        for (var k = 0; k < pairKeys.length; k++) {
            pair = grid.pairs[pairKeys[k]];

            // if pair exists in at least one bucket
            // it is a pair that needs further collision testing so push it
            if (pair[2] > 0) {
                pairs.push(pair);
            } else {
                delete grid.pairs[pairKeys[k]];
            }
        }

        return pairs;
    };
    
})();

},{"../core/Common":14,"./Detector":5,"./Pair":7}],7:[function(_dereq_,module,exports){
/**
* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.
*
* @class Pair
*/

var Pair = {};

module.exports = Pair;

var Contact = _dereq_('./Contact');

(function() {
    
    /**
     * Creates a pair.
     * @method create
     * @param {collision} collision
     * @param {number} timestamp
     * @return {pair} A new pair
     */
    Pair.create = function(collision, timestamp) {
        var bodyA = collision.bodyA,
            bodyB = collision.bodyB,
            parentA = collision.parentA,
            parentB = collision.parentB;

        var pair = {
            id: Pair.id(bodyA, bodyB),
            bodyA: bodyA,
            bodyB: bodyB,
            contacts: {},
            activeContacts: [],
            separation: 0,
            isActive: true,
            isSensor: bodyA.isSensor || bodyB.isSensor,
            timeCreated: timestamp,
            timeUpdated: timestamp,
            inverseMass: parentA.inverseMass + parentB.inverseMass,
            friction: Math.min(parentA.friction, parentB.friction),
            frictionStatic: Math.max(parentA.frictionStatic, parentB.frictionStatic),
            restitution: Math.max(parentA.restitution, parentB.restitution),
            slop: Math.max(parentA.slop, parentB.slop)
        };

        Pair.update(pair, collision, timestamp);

        return pair;
    };

    /**
     * Updates a pair given a collision.
     * @method update
     * @param {pair} pair
     * @param {collision} collision
     * @param {number} timestamp
     */
    Pair.update = function(pair, collision, timestamp) {
        var contacts = pair.contacts,
            supports = collision.supports,
            activeContacts = pair.activeContacts,
            parentA = collision.parentA,
            parentB = collision.parentB;
        
        pair.collision = collision;
        pair.inverseMass = parentA.inverseMass + parentB.inverseMass;
        pair.friction = Math.min(parentA.friction, parentB.friction);
        pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);
        pair.restitution = Math.max(parentA.restitution, parentB.restitution);
        pair.slop = Math.max(parentA.slop, parentB.slop);
        activeContacts.length = 0;
        
        if (collision.collided) {
            for (var i = 0; i < supports.length; i++) {
                var support = supports[i],
                    contactId = Contact.id(support),
                    contact = contacts[contactId];

                if (contact) {
                    activeContacts.push(contact);
                } else {
                    activeContacts.push(contacts[contactId] = Contact.create(support));
                }
            }

            pair.separation = collision.depth;
            Pair.setActive(pair, true, timestamp);
        } else {
            if (pair.isActive === true)
                Pair.setActive(pair, false, timestamp);
        }
    };
    
    /**
     * Set a pair as active or inactive.
     * @method setActive
     * @param {pair} pair
     * @param {bool} isActive
     * @param {number} timestamp
     */
    Pair.setActive = function(pair, isActive, timestamp) {
        if (isActive) {
            pair.isActive = true;
            pair.timeUpdated = timestamp;
        } else {
            pair.isActive = false;
            pair.activeContacts.length = 0;
        }
    };

    /**
     * Get the id for the given pair.
     * @method id
     * @param {body} bodyA
     * @param {body} bodyB
     * @return {string} Unique pairId
     */
    Pair.id = function(bodyA, bodyB) {
        if (bodyA.id < bodyB.id) {
            return 'A' + bodyA.id + 'B' + bodyB.id;
        } else {
            return 'A' + bodyB.id + 'B' + bodyA.id;
        }
    };

})();

},{"./Contact":4}],8:[function(_dereq_,module,exports){
/**
* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.
*
* @class Pairs
*/

var Pairs = {};

module.exports = Pairs;

var Pair = _dereq_('./Pair');
var Common = _dereq_('../core/Common');

(function() {
    
    Pairs._pairMaxIdleLife = 1000;

    /**
     * Creates a new pairs structure.
     * @method create
     * @param {object} options
     * @return {pairs} A new pairs structure
     */
    Pairs.create = function(options) {
        return Common.extend({ 
            table: {},
            list: [],
            collisionStart: [],
            collisionActive: [],
            collisionEnd: []
        }, options);
    };

    /**
     * Updates pairs given a list of collisions.
     * @method update
     * @param {object} pairs
     * @param {collision[]} collisions
     * @param {number} timestamp
     */
    Pairs.update = function(pairs, collisions, timestamp) {
        var pairsList = pairs.list,
            pairsTable = pairs.table,
            collisionStart = pairs.collisionStart,
            collisionEnd = pairs.collisionEnd,
            collisionActive = pairs.collisionActive,
            activePairIds = [],
            collision,
            pairId,
            pair,
            i;

        // clear collision state arrays, but maintain old reference
        collisionStart.length = 0;
        collisionEnd.length = 0;
        collisionActive.length = 0;

        for (i = 0; i < collisions.length; i++) {
            collision = collisions[i];

            if (collision.collided) {
                pairId = Pair.id(collision.bodyA, collision.bodyB);
                activePairIds.push(pairId);

                pair = pairsTable[pairId];
                
                if (pair) {
                    // pair already exists (but may or may not be active)
                    if (pair.isActive) {
                        // pair exists and is active
                        collisionActive.push(pair);
                    } else {
                        // pair exists but was inactive, so a collision has just started again
                        collisionStart.push(pair);
                    }

                    // update the pair
                    Pair.update(pair, collision, timestamp);
                } else {
                    // pair did not exist, create a new pair
                    pair = Pair.create(collision, timestamp);
                    pairsTable[pairId] = pair;

                    // push the new pair
                    collisionStart.push(pair);
                    pairsList.push(pair);
                }
            }
        }

        // deactivate previously active pairs that are now inactive
        for (i = 0; i < pairsList.length; i++) {
            pair = pairsList[i];
            if (pair.isActive && Common.indexOf(activePairIds, pair.id) === -1) {
                Pair.setActive(pair, false, timestamp);
                collisionEnd.push(pair);
            }
        }
    };
    
    /**
     * Finds and removes pairs that have been inactive for a set amount of time.
     * @method removeOld
     * @param {object} pairs
     * @param {number} timestamp
     */
    Pairs.removeOld = function(pairs, timestamp) {
        var pairsList = pairs.list,
            pairsTable = pairs.table,
            indexesToRemove = [],
            pair,
            collision,
            pairIndex,
            i;

        for (i = 0; i < pairsList.length; i++) {
            pair = pairsList[i];
            collision = pair.collision;
            
            // never remove sleeping pairs
            if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {
                pair.timeUpdated = timestamp;
                continue;
            }

            // if pair is inactive for too long, mark it to be removed
            if (timestamp - pair.timeUpdated > Pairs._pairMaxIdleLife) {
                indexesToRemove.push(i);
            }
        }

        // remove marked pairs
        for (i = 0; i < indexesToRemove.length; i++) {
            pairIndex = indexesToRemove[i] - i;
            pair = pairsList[pairIndex];
            delete pairsTable[pair.id];
            pairsList.splice(pairIndex, 1);
        }
    };

    /**
     * Clears the given pairs structure.
     * @method clear
     * @param {pairs} pairs
     * @return {pairs} pairs
     */
    Pairs.clear = function(pairs) {
        pairs.table = {};
        pairs.list.length = 0;
        pairs.collisionStart.length = 0;
        pairs.collisionActive.length = 0;
        pairs.collisionEnd.length = 0;
        return pairs;
    };

})();

},{"../core/Common":14,"./Pair":7}],9:[function(_dereq_,module,exports){
/**
* The `Matter.Query` module contains methods for performing collision queries.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Query
*/

var Query = {};

module.exports = Query;

var Vector = _dereq_('../geometry/Vector');
var SAT = _dereq_('./SAT');
var Bounds = _dereq_('../geometry/Bounds');
var Bodies = _dereq_('../factory/Bodies');
var Vertices = _dereq_('../geometry/Vertices');

(function() {

    /**
     * Returns a list of collisions between `body` and `bodies`.
     * @method collides
     * @param {body} body
     * @param {body[]} bodies
     * @return {object[]} Collisions
     */
    Query.collides = function(body, bodies) {
        var collisions = [];

        for (var i = 0; i < bodies.length; i++) {
            var bodyA = bodies[i];
            
            if (Bounds.overlaps(bodyA.bounds, body.bounds)) {
                for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {
                    var part = bodyA.parts[j];

                    if (Bounds.overlaps(part.bounds, body.bounds)) {
                        var collision = SAT.collides(part, body);

                        if (collision.collided) {
                            collisions.push(collision);
                            break;
                        }
                    }
                }
            }
        }

        return collisions;
    };

    /**
     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.
     * @method ray
     * @param {body[]} bodies
     * @param {vector} startPoint
     * @param {vector} endPoint
     * @param {number} [rayWidth]
     * @return {object[]} Collisions
     */
    Query.ray = function(bodies, startPoint, endPoint, rayWidth) {
        rayWidth = rayWidth || 1e-100;

        var rayAngle = Vector.angle(startPoint, endPoint),
            rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),
            rayX = (endPoint.x + startPoint.x) * 0.5,
            rayY = (endPoint.y + startPoint.y) * 0.5,
            ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, { angle: rayAngle }),
            collisions = Query.collides(ray, bodies);

        for (var i = 0; i < collisions.length; i += 1) {
            var collision = collisions[i];
            collision.body = collision.bodyB = collision.bodyA;            
        }

        return collisions;
    };

    /**
     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.
     * @method region
     * @param {body[]} bodies
     * @param {bounds} bounds
     * @param {bool} [outside=false]
     * @return {body[]} The bodies matching the query
     */
    Query.region = function(bodies, bounds, outside) {
        var result = [];

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                overlaps = Bounds.overlaps(body.bounds, bounds);
            if ((overlaps && !outside) || (!overlaps && outside))
                result.push(body);
        }

        return result;
    };

    /**
     * Returns all bodies whose vertices contain the given point, from the given set of bodies.
     * @method point
     * @param {body[]} bodies
     * @param {vector} point
     * @return {body[]} The bodies matching the query
     */
    Query.point = function(bodies, point) {
        var result = [];

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];
            
            if (Bounds.contains(body.bounds, point)) {
                for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {
                    var part = body.parts[j];

                    if (Bounds.contains(part.bounds, point)
                        && Vertices.contains(part.vertices, point)) {
                        result.push(body);
                        break;
                    }
                }
            }
        }

        return result;
    };

})();

},{"../factory/Bodies":23,"../geometry/Bounds":26,"../geometry/Vector":28,"../geometry/Vertices":29,"./SAT":11}],10:[function(_dereq_,module,exports){
/**
* The `Matter.Resolver` module contains methods for resolving collision pairs.
*
* @class Resolver
*/

var Resolver = {};

module.exports = Resolver;

var Vertices = _dereq_('../geometry/Vertices');
var Vector = _dereq_('../geometry/Vector');
var Common = _dereq_('../core/Common');
var Bounds = _dereq_('../geometry/Bounds');

(function() {

    Resolver._restingThresh = 4;
    Resolver._restingThreshTangent = 6;
    Resolver._positionDampen = 0.9;
    Resolver._positionWarming = 0.8;
    Resolver._frictionNormalMultiplier = 5;

    /**
     * Prepare pairs for position solving.
     * @method preSolvePosition
     * @param {pair[]} pairs
     */
    Resolver.preSolvePosition = function(pairs) {
        var i,
            pair,
            activeCount;

        // find total contacts on each body
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];
            
            if (!pair.isActive)
                continue;
            
            activeCount = pair.activeContacts.length;
            pair.collision.parentA.totalContacts += activeCount;
            pair.collision.parentB.totalContacts += activeCount;
        }
    };

    /**
     * Find a solution for pair positions.
     * @method solvePosition
     * @param {pair[]} pairs
     * @param {number} timeScale
     */
    Resolver.solvePosition = function(pairs, timeScale) {
        var i,
            pair,
            collision,
            bodyA,
            bodyB,
            normal,
            bodyBtoA,
            contactShare,
            positionImpulse,
            contactCount = {},
            tempA = Vector._temp[0],
            tempB = Vector._temp[1],
            tempC = Vector._temp[2],
            tempD = Vector._temp[3];

        // find impulses required to resolve penetration
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];
            
            if (!pair.isActive || pair.isSensor)
                continue;

            collision = pair.collision;
            bodyA = collision.parentA;
            bodyB = collision.parentB;
            normal = collision.normal;

            // get current separation between body edges involved in collision
            bodyBtoA = Vector.sub(Vector.add(bodyB.positionImpulse, bodyB.position, tempA), 
                                    Vector.add(bodyA.positionImpulse, 
                                        Vector.sub(bodyB.position, collision.penetration, tempB), tempC), tempD);

            pair.separation = Vector.dot(normal, bodyBtoA);
        }
        
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive || pair.isSensor)
                continue;
            
            collision = pair.collision;
            bodyA = collision.parentA;
            bodyB = collision.parentB;
            normal = collision.normal;
            positionImpulse = (pair.separation - pair.slop) * timeScale;

            if (bodyA.isStatic || bodyB.isStatic)
                positionImpulse *= 2;
            
            if (!(bodyA.isStatic || bodyA.isSleeping)) {
                contactShare = Resolver._positionDampen / bodyA.totalContacts;
                bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;
                bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;
            }

            if (!(bodyB.isStatic || bodyB.isSleeping)) {
                contactShare = Resolver._positionDampen / bodyB.totalContacts;
                bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;
                bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;
            }
        }
    };

    /**
     * Apply position resolution.
     * @method postSolvePosition
     * @param {body[]} bodies
     */
    Resolver.postSolvePosition = function(bodies) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            // reset contact count
            body.totalContacts = 0;

            if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {
                // update body geometry
                for (var j = 0; j < body.parts.length; j++) {
                    var part = body.parts[j];
                    Vertices.translate(part.vertices, body.positionImpulse);
                    Bounds.update(part.bounds, part.vertices, body.velocity);
                    part.position.x += body.positionImpulse.x;
                    part.position.y += body.positionImpulse.y;
                }

                // move the body without changing velocity
                body.positionPrev.x += body.positionImpulse.x;
                body.positionPrev.y += body.positionImpulse.y;

                if (Vector.dot(body.positionImpulse, body.velocity) < 0) {
                    // reset cached impulse if the body has velocity along it
                    body.positionImpulse.x = 0;
                    body.positionImpulse.y = 0;
                } else {
                    // warm the next iteration
                    body.positionImpulse.x *= Resolver._positionWarming;
                    body.positionImpulse.y *= Resolver._positionWarming;
                }
            }
        }
    };

    /**
     * Prepare pairs for velocity solving.
     * @method preSolveVelocity
     * @param {pair[]} pairs
     */
    Resolver.preSolveVelocity = function(pairs) {
        var i,
            j,
            pair,
            contacts,
            collision,
            bodyA,
            bodyB,
            normal,
            tangent,
            contact,
            contactVertex,
            normalImpulse,
            tangentImpulse,
            offset,
            impulse = Vector._temp[0],
            tempA = Vector._temp[1];
        
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];
            
            if (!pair.isActive || pair.isSensor)
                continue;
            
            contacts = pair.activeContacts;
            collision = pair.collision;
            bodyA = collision.parentA;
            bodyB = collision.parentB;
            normal = collision.normal;
            tangent = collision.tangent;

            // resolve each contact
            for (j = 0; j < contacts.length; j++) {
                contact = contacts[j];
                contactVertex = contact.vertex;
                normalImpulse = contact.normalImpulse;
                tangentImpulse = contact.tangentImpulse;

                if (normalImpulse !== 0 || tangentImpulse !== 0) {
                    // total impulse from contact
                    impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);
                    impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);
                    
                    // apply impulse from contact
                    if (!(bodyA.isStatic || bodyA.isSleeping)) {
                        offset = Vector.sub(contactVertex, bodyA.position, tempA);
                        bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                        bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                        bodyA.anglePrev += Vector.cross(offset, impulse) * bodyA.inverseInertia;
                    }

                    if (!(bodyB.isStatic || bodyB.isSleeping)) {
                        offset = Vector.sub(contactVertex, bodyB.position, tempA);
                        bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                        bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                        bodyB.anglePrev -= Vector.cross(offset, impulse) * bodyB.inverseInertia;
                    }
                }
            }
        }
    };

    /**
     * Find a solution for pair velocities.
     * @method solveVelocity
     * @param {pair[]} pairs
     * @param {number} timeScale
     */
    Resolver.solveVelocity = function(pairs, timeScale) {
        var timeScaleSquared = timeScale * timeScale,
            impulse = Vector._temp[0],
            tempA = Vector._temp[1],
            tempB = Vector._temp[2],
            tempC = Vector._temp[3],
            tempD = Vector._temp[4],
            tempE = Vector._temp[5];
        
        for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            
            if (!pair.isActive || pair.isSensor)
                continue;
            
            var collision = pair.collision,
                bodyA = collision.parentA,
                bodyB = collision.parentB,
                normal = collision.normal,
                tangent = collision.tangent,
                contacts = pair.activeContacts,
                contactShare = 1 / contacts.length;

            // update body velocities
            bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;
            bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;
            bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;
            bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;
            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;

            // resolve each contact
            for (var j = 0; j < contacts.length; j++) {
                var contact = contacts[j],
                    contactVertex = contact.vertex,
                    offsetA = Vector.sub(contactVertex, bodyA.position, tempA),
                    offsetB = Vector.sub(contactVertex, bodyB.position, tempB),
                    velocityPointA = Vector.add(bodyA.velocity, Vector.mult(Vector.perp(offsetA), bodyA.angularVelocity), tempC),
                    velocityPointB = Vector.add(bodyB.velocity, Vector.mult(Vector.perp(offsetB), bodyB.angularVelocity), tempD), 
                    relativeVelocity = Vector.sub(velocityPointA, velocityPointB, tempE),
                    normalVelocity = Vector.dot(normal, relativeVelocity);

                var tangentVelocity = Vector.dot(tangent, relativeVelocity),
                    tangentSpeed = Math.abs(tangentVelocity),
                    tangentVelocityDirection = Common.sign(tangentVelocity);

                // raw impulses
                var normalImpulse = (1 + pair.restitution) * normalVelocity,
                    normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;

                // coulomb friction
                var tangentImpulse = tangentVelocity,
                    maxFriction = Infinity;

                if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {
                    maxFriction = tangentSpeed;
                    tangentImpulse = Common.clamp(
                        pair.friction * tangentVelocityDirection * timeScaleSquared,
                        -maxFriction, maxFriction
                    );
                }

                // modify impulses accounting for mass, inertia and offset
                var oAcN = Vector.cross(offsetA, normal),
                    oBcN = Vector.cross(offsetB, normal),
                    share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN  + bodyB.inverseInertia * oBcN * oBcN);

                normalImpulse *= share;
                tangentImpulse *= share;

                // handle high velocity and resting collisions separately
                if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {
                    // high normal velocity so clear cached contact normal impulse
                    contact.normalImpulse = 0;
                } else {
                    // solve resting collision constraints using Erin Catto's method (GDC08)
                    // impulse constraint tends to 0
                    var contactNormalImpulse = contact.normalImpulse;
                    contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);
                    normalImpulse = contact.normalImpulse - contactNormalImpulse;
                }

                // handle high velocity and resting collisions separately
                if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {
                    // high tangent velocity so clear cached contact tangent impulse
                    contact.tangentImpulse = 0;
                } else {
                    // solve resting collision constraints using Erin Catto's method (GDC08)
                    // tangent impulse tends to -tangentSpeed or +tangentSpeed
                    var contactTangentImpulse = contact.tangentImpulse;
                    contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);
                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;
                }

                // total impulse from contact
                impulse.x = (normal.x * normalImpulse) + (tangent.x * tangentImpulse);
                impulse.y = (normal.y * normalImpulse) + (tangent.y * tangentImpulse);
                
                // apply impulse from contact
                if (!(bodyA.isStatic || bodyA.isSleeping)) {
                    bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                    bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                    bodyA.anglePrev += Vector.cross(offsetA, impulse) * bodyA.inverseInertia;
                }

                if (!(bodyB.isStatic || bodyB.isSleeping)) {
                    bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                    bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                    bodyB.anglePrev -= Vector.cross(offsetB, impulse) * bodyB.inverseInertia;
                }
            }
        }
    };

})();

},{"../core/Common":14,"../geometry/Bounds":26,"../geometry/Vector":28,"../geometry/Vertices":29}],11:[function(_dereq_,module,exports){
/**
* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.
*
* @class SAT
*/

// TODO: true circles and curves

var SAT = {};

module.exports = SAT;

var Vertices = _dereq_('../geometry/Vertices');
var Vector = _dereq_('../geometry/Vector');

(function() {

    /**
     * Detect collision between two bodies using the Separating Axis Theorem.
     * @method collides
     * @param {body} bodyA
     * @param {body} bodyB
     * @param {collision} previousCollision
     * @return {collision} collision
     */
    SAT.collides = function(bodyA, bodyB, previousCollision) {
        var overlapAB,
            overlapBA, 
            minOverlap,
            collision,
            canReusePrevCol = false;

        if (previousCollision) {
            // estimate total motion
            var parentA = bodyA.parent,
                parentB = bodyB.parent,
                motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed
                       + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;

            // we may be able to (partially) reuse collision result 
            // but only safe if collision was resting
            canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;

            // reuse collision object
            collision = previousCollision;
        } else {
            collision = { collided: false, bodyA: bodyA, bodyB: bodyB };
        }

        if (previousCollision && canReusePrevCol) {
            // if we can reuse the collision result
            // we only need to test the previously found axis
            var axisBodyA = collision.axisBody,
                axisBodyB = axisBodyA === bodyA ? bodyB : bodyA,
                axes = [axisBodyA.axes[previousCollision.axisNumber]];

            minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);
            collision.reused = true;

            if (minOverlap.overlap <= 0) {
                collision.collided = false;
                return collision;
            }
        } else {
            // if we can't reuse a result, perform a full SAT test

            overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);

            if (overlapAB.overlap <= 0) {
                collision.collided = false;
                return collision;
            }

            overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);

            if (overlapBA.overlap <= 0) {
                collision.collided = false;
                return collision;
            }

            if (overlapAB.overlap < overlapBA.overlap) {
                minOverlap = overlapAB;
                collision.axisBody = bodyA;
            } else {
                minOverlap = overlapBA;
                collision.axisBody = bodyB;
            }

            // important for reuse later
            collision.axisNumber = minOverlap.axisNumber;
        }

        collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;
        collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;
        collision.collided = true;
        collision.depth = minOverlap.overlap;
        collision.parentA = collision.bodyA.parent;
        collision.parentB = collision.bodyB.parent;
        
        bodyA = collision.bodyA;
        bodyB = collision.bodyB;

        // ensure normal is facing away from bodyA
        if (Vector.dot(minOverlap.axis, Vector.sub(bodyB.position, bodyA.position)) < 0) {
            collision.normal = {
                x: minOverlap.axis.x,
                y: minOverlap.axis.y
            };
        } else {
            collision.normal = {
                x: -minOverlap.axis.x,
                y: -minOverlap.axis.y
            };
        }

        collision.tangent = Vector.perp(collision.normal);

        collision.penetration = collision.penetration || {};
        collision.penetration.x = collision.normal.x * collision.depth;
        collision.penetration.y = collision.normal.y * collision.depth; 

        // find support points, there is always either exactly one or two
        var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal),
            supports = [];

        // find the supports from bodyB that are inside bodyA
        if (Vertices.contains(bodyA.vertices, verticesB[0]))
            supports.push(verticesB[0]);

        if (Vertices.contains(bodyA.vertices, verticesB[1]))
            supports.push(verticesB[1]);

        // find the supports from bodyA that are inside bodyB
        if (supports.length < 2) {
            var verticesA = SAT._findSupports(bodyB, bodyA, Vector.neg(collision.normal));
                
            if (Vertices.contains(bodyB.vertices, verticesA[0]))
                supports.push(verticesA[0]);

            if (supports.length < 2 && Vertices.contains(bodyB.vertices, verticesA[1]))
                supports.push(verticesA[1]);
        }

        // account for the edge case of overlapping but no vertex containment
        if (supports.length < 1)
            supports = [verticesB[0]];
        
        collision.supports = supports;

        return collision;
    };

    /**
     * Find the overlap between two sets of vertices.
     * @method _overlapAxes
     * @private
     * @param {} verticesA
     * @param {} verticesB
     * @param {} axes
     * @return result
     */
    SAT._overlapAxes = function(verticesA, verticesB, axes) {
        var projectionA = Vector._temp[0], 
            projectionB = Vector._temp[1],
            result = { overlap: Number.MAX_VALUE },
            overlap,
            axis;

        for (var i = 0; i < axes.length; i++) {
            axis = axes[i];

            SAT._projectToAxis(projectionA, verticesA, axis);
            SAT._projectToAxis(projectionB, verticesB, axis);

            overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);

            if (overlap <= 0) {
                result.overlap = overlap;
                return result;
            }

            if (overlap < result.overlap) {
                result.overlap = overlap;
                result.axis = axis;
                result.axisNumber = i;
            }
        }

        return result;
    };

    /**
     * Projects vertices on an axis and returns an interval.
     * @method _projectToAxis
     * @private
     * @param {} projection
     * @param {} vertices
     * @param {} axis
     */
    SAT._projectToAxis = function(projection, vertices, axis) {
        var min = Vector.dot(vertices[0], axis),
            max = min;

        for (var i = 1; i < vertices.length; i += 1) {
            var dot = Vector.dot(vertices[i], axis);

            if (dot > max) { 
                max = dot; 
            } else if (dot < min) { 
                min = dot; 
            }
        }

        projection.min = min;
        projection.max = max;
    };
    
    /**
     * Finds supporting vertices given two bodies along a given direction using hill-climbing.
     * @method _findSupports
     * @private
     * @param {} bodyA
     * @param {} bodyB
     * @param {} normal
     * @return [vector]
     */
    SAT._findSupports = function(bodyA, bodyB, normal) {
        var nearestDistance = Number.MAX_VALUE,
            vertexToBody = Vector._temp[0],
            vertices = bodyB.vertices,
            bodyAPosition = bodyA.position,
            distance,
            vertex,
            vertexA,
            vertexB;

        // find closest vertex on bodyB
        for (var i = 0; i < vertices.length; i++) {
            vertex = vertices[i];
            vertexToBody.x = vertex.x - bodyAPosition.x;
            vertexToBody.y = vertex.y - bodyAPosition.y;
            distance = -Vector.dot(normal, vertexToBody);

            if (distance < nearestDistance) {
                nearestDistance = distance;
                vertexA = vertex;
            }
        }

        // find next closest vertex using the two connected to it
        var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;
        vertex = vertices[prevIndex];
        vertexToBody.x = vertex.x - bodyAPosition.x;
        vertexToBody.y = vertex.y - bodyAPosition.y;
        nearestDistance = -Vector.dot(normal, vertexToBody);
        vertexB = vertex;

        var nextIndex = (vertexA.index + 1) % vertices.length;
        vertex = vertices[nextIndex];
        vertexToBody.x = vertex.x - bodyAPosition.x;
        vertexToBody.y = vertex.y - bodyAPosition.y;
        distance = -Vector.dot(normal, vertexToBody);
        if (distance < nearestDistance) {
            vertexB = vertex;
        }

        return [vertexA, vertexB];
    };

})();

},{"../geometry/Vector":28,"../geometry/Vertices":29}],12:[function(_dereq_,module,exports){
/**
* The `Matter.Constraint` module contains methods for creating and manipulating constraints.
* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).
* The stiffness of constraints can be modified to create springs or elastic.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Constraint
*/

var Constraint = {};

module.exports = Constraint;

var Vertices = _dereq_('../geometry/Vertices');
var Vector = _dereq_('../geometry/Vector');
var Sleeping = _dereq_('../core/Sleeping');
var Bounds = _dereq_('../geometry/Bounds');
var Axes = _dereq_('../geometry/Axes');
var Common = _dereq_('../core/Common');

(function() {

    Constraint._warming = 0.4;
    Constraint._torqueDampen = 1;
    Constraint._minLength = 0.000001;

    /**
     * Creates a new constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * To simulate a revolute constraint (or pin constraint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).
     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.
     * For compound bodies, constraints must be applied to the parent body (not one of its parts).
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {} options
     * @return {constraint} constraint
     */
    Constraint.create = function(options) {
        var constraint = options;

        // if bodies defined but no points, use body centre
        if (constraint.bodyA && !constraint.pointA)
            constraint.pointA = { x: 0, y: 0 };
        if (constraint.bodyB && !constraint.pointB)
            constraint.pointB = { x: 0, y: 0 };

        // calculate static length using initial world space points
        var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA,
            initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB,
            length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));
    
        constraint.length = typeof constraint.length !== 'undefined' ? constraint.length : length;

        // option defaults
        constraint.id = constraint.id || Common.nextId();
        constraint.label = constraint.label || 'Constraint';
        constraint.type = 'constraint';
        constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);
        constraint.damping = constraint.damping || 0;
        constraint.angularStiffness = constraint.angularStiffness || 0;
        constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;
        constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;
        constraint.plugin = {};

        // render
        var render = {
            visible: true,
            lineWidth: 2,
            strokeStyle: '#ffffff',
            type: 'line',
            anchors: true
        };

        if (constraint.length === 0 && constraint.stiffness > 0.1) {
            render.type = 'pin';
            render.anchors = false;
        } else if (constraint.stiffness < 0.9) {
            render.type = 'spring';
        }

        constraint.render = Common.extend(render, constraint.render);

        return constraint;
    };

    /**
     * Prepares for solving by constraint warming.
     * @private
     * @method preSolveAll
     * @param {body[]} bodies
     */
    Constraint.preSolveAll = function(bodies) {
        for (var i = 0; i < bodies.length; i += 1) {
            var body = bodies[i],
                impulse = body.constraintImpulse;

            if (body.isStatic || (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0)) {
                continue;
            }

            body.position.x += impulse.x;
            body.position.y += impulse.y;
            body.angle += impulse.angle;
        }
    };

    /**
     * Solves all constraints in a list of collisions.
     * @private
     * @method solveAll
     * @param {constraint[]} constraints
     * @param {number} timeScale
     */
    Constraint.solveAll = function(constraints, timeScale) {
        // Solve fixed constraints first.
        for (var i = 0; i < constraints.length; i += 1) {
            var constraint = constraints[i],
                fixedA = !constraint.bodyA || (constraint.bodyA && constraint.bodyA.isStatic),
                fixedB = !constraint.bodyB || (constraint.bodyB && constraint.bodyB.isStatic);

            if (fixedA || fixedB) {
                Constraint.solve(constraints[i], timeScale);
            }
        }

        // Solve free constraints last.
        for (i = 0; i < constraints.length; i += 1) {
            constraint = constraints[i];
            fixedA = !constraint.bodyA || (constraint.bodyA && constraint.bodyA.isStatic);
            fixedB = !constraint.bodyB || (constraint.bodyB && constraint.bodyB.isStatic);

            if (!fixedA && !fixedB) {
                Constraint.solve(constraints[i], timeScale);
            }
        }
    };

    /**
     * Solves a distance constraint with Gauss-Siedel method.
     * @private
     * @method solve
     * @param {constraint} constraint
     * @param {number} timeScale
     */
    Constraint.solve = function(constraint, timeScale) {
        var bodyA = constraint.bodyA,
            bodyB = constraint.bodyB,
            pointA = constraint.pointA,
            pointB = constraint.pointB;

        if (!bodyA && !bodyB)
            return;

        // update reference angle
        if (bodyA && !bodyA.isStatic) {
            Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);
            constraint.angleA = bodyA.angle;
        }
        
        // update reference angle
        if (bodyB && !bodyB.isStatic) {
            Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);
            constraint.angleB = bodyB.angle;
        }

        var pointAWorld = pointA,
            pointBWorld = pointB;

        if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);
        if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);

        if (!pointAWorld || !pointBWorld)
            return;

        var delta = Vector.sub(pointAWorld, pointBWorld),
            currentLength = Vector.magnitude(delta);

        // prevent singularity
        if (currentLength < Constraint._minLength) {
            currentLength = Constraint._minLength;
        }

        // solve distance constraint with Gauss-Siedel method
        var difference = (currentLength - constraint.length) / currentLength,
            stiffness = constraint.stiffness < 1 ? constraint.stiffness * timeScale : constraint.stiffness,
            force = Vector.mult(delta, difference * stiffness),
            massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0),
            inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0),
            resistanceTotal = massTotal + inertiaTotal,
            torque,
            share,
            normal,
            normalVelocity,
            relativeVelocity;

        if (constraint.damping) {
            var zero = Vector.create();
            normal = Vector.div(delta, currentLength);

            relativeVelocity = Vector.sub(
                bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero,
                bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero
            );

            normalVelocity = Vector.dot(normal, relativeVelocity);
        }

        if (bodyA && !bodyA.isStatic) {
            share = bodyA.inverseMass / massTotal;

            // keep track of applied impulses for post solving
            bodyA.constraintImpulse.x -= force.x * share;
            bodyA.constraintImpulse.y -= force.y * share;

            // apply forces
            bodyA.position.x -= force.x * share;
            bodyA.position.y -= force.y * share;

            // apply damping
            if (constraint.damping) {
                bodyA.positionPrev.x -= constraint.damping * normal.x * normalVelocity * share;
                bodyA.positionPrev.y -= constraint.damping * normal.y * normalVelocity * share;
            }

            // apply torque
            torque = (Vector.cross(pointA, force) / resistanceTotal) * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);
            bodyA.constraintImpulse.angle -= torque;
            bodyA.angle -= torque;
        }

        if (bodyB && !bodyB.isStatic) {
            share = bodyB.inverseMass / massTotal;

            // keep track of applied impulses for post solving
            bodyB.constraintImpulse.x += force.x * share;
            bodyB.constraintImpulse.y += force.y * share;
            
            // apply forces
            bodyB.position.x += force.x * share;
            bodyB.position.y += force.y * share;

            // apply damping
            if (constraint.damping) {
                bodyB.positionPrev.x += constraint.damping * normal.x * normalVelocity * share;
                bodyB.positionPrev.y += constraint.damping * normal.y * normalVelocity * share;
            }

            // apply torque
            torque = (Vector.cross(pointB, force) / resistanceTotal) * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);
            bodyB.constraintImpulse.angle += torque;
            bodyB.angle += torque;
        }

    };

    /**
     * Performs body updates required after solving constraints.
     * @private
     * @method postSolveAll
     * @param {body[]} bodies
     */
    Constraint.postSolveAll = function(bodies) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                impulse = body.constraintImpulse;

            if (body.isStatic || (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0)) {
                continue;
            }

            Sleeping.set(body, false);

            // update geometry and reset
            for (var j = 0; j < body.parts.length; j++) {
                var part = body.parts[j];
                
                Vertices.translate(part.vertices, impulse);

                if (j > 0) {
                    part.position.x += impulse.x;
                    part.position.y += impulse.y;
                }

                if (impulse.angle !== 0) {
                    Vertices.rotate(part.vertices, impulse.angle, body.position);
                    Axes.rotate(part.axes, impulse.angle);
                    if (j > 0) {
                        Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);
                    }
                }

                Bounds.update(part.bounds, part.vertices, body.velocity);
            }

            // dampen the cached impulse for warming next step
            impulse.angle *= Constraint._warming;
            impulse.x *= Constraint._warming;
            impulse.y *= Constraint._warming;
        }
    };

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.
     *
     * @property id
     * @type number
     */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "constraint"
     * @readOnly
     */

    /**
     * An arbitrary `String` name to help the user identify and manage bodies.
     *
     * @property label
     * @type string
     * @default "Constraint"
     */

    /**
     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.
     *
     * @property render
     * @type object
     */

    /**
     * A flag that indicates if the constraint should be rendered.
     *
     * @property render.visible
     * @type boolean
     * @default true
     */

    /**
     * A `Number` that defines the line width to use when rendering the constraint outline.
     * A value of `0` means no outline will be rendered.
     *
     * @property render.lineWidth
     * @type number
     * @default 2
     */

    /**
     * A `String` that defines the stroke style to use when rendering the constraint outline.
     * It is the same as when using a canvas, so it accepts CSS style property values.
     *
     * @property render.strokeStyle
     * @type string
     * @default a random colour
     */

    /**
     * A `String` that defines the constraint rendering type. 
     * The possible values are 'line', 'pin', 'spring'.
     * An appropriate render type will be automatically chosen unless one is given in options.
     *
     * @property render.type
     * @type string
     * @default 'line'
     */

    /**
     * A `Boolean` that defines if the constraint's anchor points should be rendered.
     *
     * @property render.anchors
     * @type boolean
     * @default true
     */

    /**
     * The first possible `Body` that this constraint is attached to.
     *
     * @property bodyA
     * @type body
     * @default null
     */

    /**
     * The second possible `Body` that this constraint is attached to.
     *
     * @property bodyB
     * @type body
     * @default null
     */

    /**
     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.
     *
     * @property pointA
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyB` if defined, otherwise a world-space position.
     *
     * @property pointB
     * @type vector
     * @default { x: 0, y: 0 }
     */

    /**
     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.
     * A value of `1` means the constraint should be very stiff.
     * A value of `0.2` means the constraint acts like a soft spring.
     *
     * @property stiffness
     * @type number
     * @default 1
     */

    /**
     * A `Number` that specifies the damping of the constraint, 
     * i.e. the amount of resistance applied to each body based on their velocities to limit the amount of oscillation.
     * Damping will only be apparent when the constraint also has a very low `stiffness`.
     * A value of `0.1` means the constraint will apply heavy damping, resulting in little to no oscillation.
     * A value of `0` means the constraint will apply no damping.
     *
     * @property damping
     * @type number
     * @default 0
     */

    /**
     * A `Number` that specifies the target resting length of the constraint. 
     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.
     *
     * @property length
     * @type number
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

})();

},{"../core/Common":14,"../core/Sleeping":22,"../geometry/Axes":25,"../geometry/Bounds":26,"../geometry/Vector":28,"../geometry/Vertices":29}],13:[function(_dereq_,module,exports){
/**
* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.
* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class MouseConstraint
*/

var MouseConstraint = {};

module.exports = MouseConstraint;

var Vertices = _dereq_('../geometry/Vertices');
var Sleeping = _dereq_('../core/Sleeping');
var Mouse = _dereq_('../core/Mouse');
var Events = _dereq_('../core/Events');
var Detector = _dereq_('../collision/Detector');
var Constraint = _dereq_('./Constraint');
var Composite = _dereq_('../body/Composite');
var Common = _dereq_('../core/Common');
var Bounds = _dereq_('../geometry/Bounds');

(function() {

    /**
     * Creates a new mouse constraint.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {engine} engine
     * @param {} options
     * @return {MouseConstraint} A new MouseConstraint
     */
    MouseConstraint.create = function(engine, options) {
        var mouse = (engine ? engine.mouse : null) || (options ? options.mouse : null);

        if (!mouse) {
            if (engine && engine.render && engine.render.canvas) {
                mouse = Mouse.create(engine.render.canvas);
            } else if (options && options.element) {
                mouse = Mouse.create(options.element);
            } else {
                mouse = Mouse.create();
                Common.warn('MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected');
            }
        }

        var constraint = Constraint.create({ 
            label: 'Mouse Constraint',
            pointA: mouse.position,
            pointB: { x: 0, y: 0 },
            length: 0.01, 
            stiffness: 0.1,
            angularStiffness: 1,
            render: {
                strokeStyle: '#90EE90',
                lineWidth: 3
            }
        });

        var defaults = {
            type: 'mouseConstraint',
            mouse: mouse,
            element: null,
            body: null,
            constraint: constraint,
            collisionFilter: {
                category: 0x0001,
                mask: 0xFFFFFFFF,
                group: 0
            }
        };

        var mouseConstraint = Common.extend(defaults, options);

        Events.on(engine, 'beforeUpdate', function() {
            var allBodies = Composite.allBodies(engine.world);
            MouseConstraint.update(mouseConstraint, allBodies);
            MouseConstraint._triggerEvents(mouseConstraint);
        });

        return mouseConstraint;
    };

    /**
     * Updates the given mouse constraint.
     * @private
     * @method update
     * @param {MouseConstraint} mouseConstraint
     * @param {body[]} bodies
     */
    MouseConstraint.update = function(mouseConstraint, bodies) {
        var mouse = mouseConstraint.mouse,
            constraint = mouseConstraint.constraint,
            body = mouseConstraint.body;

        if (mouse.button === 0) {
            if (!constraint.bodyB) {
                for (var i = 0; i < bodies.length; i++) {
                    body = bodies[i];
                    if (Bounds.contains(body.bounds, mouse.position) 
                            && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {
                        for (var j = body.parts.length > 1 ? 1 : 0; j < body.parts.length; j++) {
                            var part = body.parts[j];
                            if (Vertices.contains(part.vertices, mouse.position)) {
                                constraint.pointA = mouse.position;
                                constraint.bodyB = mouseConstraint.body = body;
                                constraint.pointB = { x: mouse.position.x - body.position.x, y: mouse.position.y - body.position.y };
                                constraint.angleB = body.angle;

                                Sleeping.set(body, false);
                                Events.trigger(mouseConstraint, 'startdrag', { mouse: mouse, body: body });

                                break;
                            }
                        }
                    }
                }
            } else {
                Sleeping.set(constraint.bodyB, false);
                constraint.pointA = mouse.position;
            }
        } else {
            constraint.bodyB = mouseConstraint.body = null;
            constraint.pointB = null;

            if (body)
                Events.trigger(mouseConstraint, 'enddrag', { mouse: mouse, body: body });
        }
    };

    /**
     * Triggers mouse constraint events.
     * @method _triggerEvents
     * @private
     * @param {mouse} mouseConstraint
     */
    MouseConstraint._triggerEvents = function(mouseConstraint) {
        var mouse = mouseConstraint.mouse,
            mouseEvents = mouse.sourceEvents;

        if (mouseEvents.mousemove)
            Events.trigger(mouseConstraint, 'mousemove', { mouse: mouse });

        if (mouseEvents.mousedown)
            Events.trigger(mouseConstraint, 'mousedown', { mouse: mouse });

        if (mouseEvents.mouseup)
            Events.trigger(mouseConstraint, 'mouseup', { mouse: mouse });

        // reset the mouse state ready for the next step
        Mouse.clearSourceEvents(mouse);
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired when the mouse has moved (or a touch moves) during the last step
    *
    * @event mousemove
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the mouse is down (or a touch has started) during the last step
    *
    * @event mousedown
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the mouse is up (or a touch has ended) during the last step
    *
    * @event mouseup
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the user starts dragging a body
    *
    * @event startdrag
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {body} event.body The body being dragged
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired when the user ends dragging a body
    *
    * @event enddrag
    * @param {} event An event object
    * @param {mouse} event.mouse The engine's mouse instance
    * @param {body} event.body The body that has stopped being dragged
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * A `String` denoting the type of object.
     *
     * @property type
     * @type string
     * @default "constraint"
     * @readOnly
     */

    /**
     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.
     *
     * @property mouse
     * @type mouse
     * @default mouse
     */

    /**
     * The `Body` that is currently being moved by the user, or `null` if no body.
     *
     * @property body
     * @type body
     * @default null
     */

    /**
     * The `Constraint` object that is used to move the body during interaction.
     *
     * @property constraint
     * @type constraint
     */

    /**
     * An `Object` that specifies the collision filter properties.
     * The collision filter allows the user to define which types of body this mouse constraint can interact with.
     * See `body.collisionFilter` for more information.
     *
     * @property collisionFilter
     * @type object
     */

})();

},{"../body/Composite":2,"../collision/Detector":5,"../core/Common":14,"../core/Events":16,"../core/Mouse":19,"../core/Sleeping":22,"../geometry/Bounds":26,"../geometry/Vertices":29,"./Constraint":12}],14:[function(_dereq_,module,exports){
(function (global){
/**
* The `Matter.Common` module contains utility functions that are common to all modules.
*
* @class Common
*/

var Common = {};

module.exports = Common;

(function() {

    Common._nextId = 0;
    Common._seed = 0;
    Common._nowStartTime = +(new Date());

    /**
     * Extends the object in the first argument using the object in the second argument.
     * @method extend
     * @param {} obj
     * @param {boolean} deep
     * @return {} obj extended
     */
    Common.extend = function(obj, deep) {
        var argsStart,
            args,
            deepClone;

        if (typeof deep === 'boolean') {
            argsStart = 2;
            deepClone = deep;
        } else {
            argsStart = 1;
            deepClone = true;
        }

        for (var i = argsStart; i < arguments.length; i++) {
            var source = arguments[i];

            if (source) {
                for (var prop in source) {
                    if (deepClone && source[prop] && source[prop].constructor === Object) {
                        if (!obj[prop] || obj[prop].constructor === Object) {
                            obj[prop] = obj[prop] || {};
                            Common.extend(obj[prop], deepClone, source[prop]);
                        } else {
                            obj[prop] = source[prop];
                        }
                    } else {
                        obj[prop] = source[prop];
                    }
                }
            }
        }
        
        return obj;
    };

    /**
     * Creates a new clone of the object, if deep is true references will also be cloned.
     * @method clone
     * @param {} obj
     * @param {bool} deep
     * @return {} obj cloned
     */
    Common.clone = function(obj, deep) {
        return Common.extend({}, deep, obj);
    };

    /**
     * Returns the list of keys for the given object.
     * @method keys
     * @param {} obj
     * @return {string[]} keys
     */
    Common.keys = function(obj) {
        if (Object.keys)
            return Object.keys(obj);

        // avoid hasOwnProperty for performance
        var keys = [];
        for (var key in obj)
            keys.push(key);
        return keys;
    };

    /**
     * Returns the list of values for the given object.
     * @method values
     * @param {} obj
     * @return {array} Array of the objects property values
     */
    Common.values = function(obj) {
        var values = [];
        
        if (Object.keys) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length; i++) {
                values.push(obj[keys[i]]);
            }
            return values;
        }
        
        // avoid hasOwnProperty for performance
        for (var key in obj)
            values.push(obj[key]);
        return values;
    };

    /**
     * Gets a value from `base` relative to the `path` string.
     * @method get
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} The object at the given path
     */
    Common.get = function(obj, path, begin, end) {
        path = path.split('.').slice(begin, end);

        for (var i = 0; i < path.length; i += 1) {
            obj = obj[path[i]];
        }

        return obj;
    };

    /**
     * Sets a value on `base` relative to the given `path` string.
     * @method set
     * @param {} obj The base object
     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'
     * @param {} val The value to set
     * @param {number} [begin] Path slice begin
     * @param {number} [end] Path slice end
     * @return {} Pass through `val` for chaining
     */
    Common.set = function(obj, path, val, begin, end) {
        var parts = path.split('.').slice(begin, end);
        Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;
        return val;
    };

    /**
     * Shuffles the given array in-place.
     * The function uses a seeded random generator.
     * @method shuffle
     * @param {array} array
     * @return {array} array shuffled randomly
     */
    Common.shuffle = function(array) {
        for (var i = array.length - 1; i > 0; i--) {
            var j = Math.floor(Common.random() * (i + 1));
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
        return array;
    };

    /**
     * Randomly chooses a value from a list with equal probability.
     * The function uses a seeded random generator.
     * @method choose
     * @param {array} choices
     * @return {object} A random choice object from the array
     */
    Common.choose = function(choices) {
        return choices[Math.floor(Common.random() * choices.length)];
    };

    /**
     * Returns true if the object is a HTMLElement, otherwise false.
     * @method isElement
     * @param {object} obj
     * @return {boolean} True if the object is a HTMLElement, otherwise false
     */
    Common.isElement = function(obj) {
        if (typeof HTMLElement !== 'undefined') {
            return obj instanceof HTMLElement;
        }

        return !!(obj && obj.nodeType && obj.nodeName);
    };

    /**
     * Returns true if the object is an array.
     * @method isArray
     * @param {object} obj
     * @return {boolean} True if the object is an array, otherwise false
     */
    Common.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    };

    /**
     * Returns true if the object is a function.
     * @method isFunction
     * @param {object} obj
     * @return {boolean} True if the object is a function, otherwise false
     */
    Common.isFunction = function(obj) {
        return typeof obj === "function";
    };

    /**
     * Returns true if the object is a plain object.
     * @method isPlainObject
     * @param {object} obj
     * @return {boolean} True if the object is a plain object, otherwise false
     */
    Common.isPlainObject = function(obj) {
        return typeof obj === 'object' && obj.constructor === Object;
    };

    /**
     * Returns true if the object is a string.
     * @method isString
     * @param {object} obj
     * @return {boolean} True if the object is a string, otherwise false
     */
    Common.isString = function(obj) {
        return toString.call(obj) === '[object String]';
    };
    
    /**
     * Returns the given value clamped between a minimum and maximum value.
     * @method clamp
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @return {number} The value clamped between min and max inclusive
     */
    Common.clamp = function(value, min, max) {
        if (value < min)
            return min;
        if (value > max)
            return max;
        return value;
    };
    
    /**
     * Returns the sign of the given value.
     * @method sign
     * @param {number} value
     * @return {number} -1 if negative, +1 if 0 or positive
     */
    Common.sign = function(value) {
        return value < 0 ? -1 : 1;
    };
    
    /**
     * Returns the current timestamp since the time origin (e.g. from page load).
     * The result will be high-resolution including decimal places if available.
     * @method now
     * @return {number} the current timestamp
     */
    Common.now = function() {
        if (window.performance) {
            if (window.performance.now) {
                return window.performance.now();
            } else if (window.performance.webkitNow) {
                return window.performance.webkitNow();
            }
        }

        return (new Date()) - Common._nowStartTime;
    };
    
    /**
     * Returns a random value between a minimum and a maximum value inclusive.
     * The function uses a seeded random generator.
     * @method random
     * @param {number} min
     * @param {number} max
     * @return {number} A random number between min and max inclusive
     */
    Common.random = function(min, max) {
        min = (typeof min !== "undefined") ? min : 0;
        max = (typeof max !== "undefined") ? max : 1;
        return min + _seededRandom() * (max - min);
    };

    var _seededRandom = function() {
        // https://en.wikipedia.org/wiki/Linear_congruential_generator
        Common._seed = (Common._seed * 9301 + 49297) % 233280;
        return Common._seed / 233280;
    };

    /**
     * Converts a CSS hex colour string into an integer.
     * @method colorToNumber
     * @param {string} colorString
     * @return {number} An integer representing the CSS hex string
     */
    Common.colorToNumber = function(colorString) {
        colorString = colorString.replace('#','');

        if (colorString.length == 3) {
            colorString = colorString.charAt(0) + colorString.charAt(0)
                        + colorString.charAt(1) + colorString.charAt(1)
                        + colorString.charAt(2) + colorString.charAt(2);
        }

        return parseInt(colorString, 16);
    };

    /**
     * The console logging level to use, where each level includes all levels above and excludes the levels below.
     * The default level is 'debug' which shows all console messages.  
     *
     * Possible level values are:
     * - 0 = None
     * - 1 = Debug
     * - 2 = Info
     * - 3 = Warn
     * - 4 = Error
     * @property Common.logLevel
     * @type {Number}
     * @default 1
     */
    Common.logLevel = 1;

    /**
     * Shows a `console.log` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method log
     * @param ...objs {} The objects to log.
     */
    Common.log = function() {
        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
            console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));
        }
    };

    /**
     * Shows a `console.info` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method info
     * @param ...objs {} The objects to log.
     */
    Common.info = function() {
        if (console && Common.logLevel > 0 && Common.logLevel <= 2) {
            console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));
        }
    };

    /**
     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.
     * The message will be prefixed with 'matter-js' to make it easily identifiable.
     * @method warn
     * @param ...objs {} The objects to log.
     */
    Common.warn = function() {
        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
            console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));
        }
    };

    /**
     * Returns the next unique sequential ID.
     * @method nextId
     * @return {Number} Unique sequential ID
     */
    Common.nextId = function() {
        return Common._nextId++;
    };

    /**
     * A cross browser compatible indexOf implementation.
     * @method indexOf
     * @param {array} haystack
     * @param {object} needle
     * @return {number} The position of needle in haystack, otherwise -1.
     */
    Common.indexOf = function(haystack, needle) {
        if (haystack.indexOf)
            return haystack.indexOf(needle);

        for (var i = 0; i < haystack.length; i++) {
            if (haystack[i] === needle)
                return i;
        }

        return -1;
    };

    /**
     * A cross browser compatible array map implementation.
     * @method map
     * @param {array} list
     * @param {function} func
     * @return {array} Values from list transformed by func.
     */
    Common.map = function(list, func) {
        if (list.map) {
            return list.map(func);
        }

        var mapped = [];

        for (var i = 0; i < list.length; i += 1) {
            mapped.push(func(list[i]));
        }

        return mapped;
    };

    /**
     * Takes a directed graph and returns the partially ordered set of vertices in topological order.
     * Circular dependencies are allowed.
     * @method topologicalSort
     * @param {object} graph
     * @return {array} Partially ordered set of vertices in topological order.
     */
    Common.topologicalSort = function(graph) {
        // https://github.com/mgechev/javascript-algorithms
        // Copyright (c) Minko Gechev (MIT license)
        // Modifications: tidy formatting and naming
        var result = [],
            visited = [],
            temp = [];

        for (var node in graph) {
            if (!visited[node] && !temp[node]) {
                Common._topologicalSort(node, visited, temp, graph, result);
            }
        }

        return result;
    };

    Common._topologicalSort = function(node, visited, temp, graph, result) {
        var neighbors = graph[node] || [];
        temp[node] = true;

        for (var i = 0; i < neighbors.length; i += 1) {
            var neighbor = neighbors[i];

            if (temp[neighbor]) {
                // skip circular dependencies
                continue;
            }

            if (!visited[neighbor]) {
                Common._topologicalSort(neighbor, visited, temp, graph, result);
            }
        }

        temp[node] = false;
        visited[node] = true;

        result.push(node);
    };

    /**
     * Takes _n_ functions as arguments and returns a new function that calls them in order.
     * The arguments applied when calling the new function will also be applied to every function passed.
     * The value of `this` refers to the last value returned in the chain that was not `undefined`.
     * Therefore if a passed function does not return a value, the previously returned value is maintained.
     * After all passed functions have been called the new function returns the last returned value (if any).
     * If any of the passed functions are a chain, then the chain will be flattened.
     * @method chain
     * @param ...funcs {function} The functions to chain.
     * @return {function} A new function that calls the passed functions in order.
     */
    Common.chain = function() {
        var funcs = [];

        for (var i = 0; i < arguments.length; i += 1) {
            var func = arguments[i];

            if (func._chained) {
                // flatten already chained functions
                funcs.push.apply(funcs, func._chained);
            } else {
                funcs.push(func);
            }
        }

        var chain = function() {
            // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358
            var lastResult,
                args = new Array(arguments.length);

            for (var i = 0, l = arguments.length; i < l; i++) {
                args[i] = arguments[i];
            }

            for (i = 0; i < funcs.length; i += 1) {
                var result = funcs[i].apply(lastResult, args);

                if (typeof result !== 'undefined') {
                    lastResult = result;
                }
            }

            return lastResult;
        };

        chain._chained = funcs;

        return chain;
    };

    /**
     * Chains a function to excute before the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathBefore
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */
    Common.chainPathBefore = function(base, path, func) {
        return Common.set(base, path, Common.chain(
            func,
            Common.get(base, path)
        ));
    };

    /**
     * Chains a function to excute after the original function on the given `path` relative to `base`.
     * See also docs for `Common.chain`.
     * @method chainPathAfter
     * @param {} base The base object
     * @param {string} path The path relative to `base`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */
    Common.chainPathAfter = function(base, path, func) {
        return Common.set(base, path, Common.chain(
            Common.get(base, path),
            func
        ));
    };

    /**
     * Used to require external libraries outside of the bundle.
     * It first looks for the `globalName` on the environment's global namespace.
     * If the global is not found, it will fall back to using the standard `require` using the `moduleName`.
     * @private
     * @method _requireGlobal
     * @param {string} globalName The global module name
     * @param {string} moduleName The fallback CommonJS module name
     * @return {} The loaded module
     */
    Common._requireGlobal = function(globalName, moduleName) {
        var obj = (typeof window !== 'undefined' ? window[globalName] : typeof global !== 'undefined' ? global[globalName] : null);
        return obj || _dereq_(moduleName);
    };
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],15:[function(_dereq_,module,exports){
/**
* The `Matter.Engine` module contains methods for creating and manipulating engines.
* An engine is a controller that manages updating the simulation of the world.
* See `Matter.Runner` for an optional game loop utility.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Engine
*/

var Engine = {};

module.exports = Engine;

var World = _dereq_('../body/World');
var Sleeping = _dereq_('./Sleeping');
var Resolver = _dereq_('../collision/Resolver');
var Render = _dereq_('../render/Render');
var Pairs = _dereq_('../collision/Pairs');
var Metrics = _dereq_('./Metrics');
var Grid = _dereq_('../collision/Grid');
var Events = _dereq_('./Events');
var Composite = _dereq_('../body/Composite');
var Constraint = _dereq_('../constraint/Constraint');
var Common = _dereq_('./Common');
var Body = _dereq_('../body/Body');

(function() {

    /**
     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {engine} engine
     */
    Engine.create = function(element, options) {
        // options may be passed as the first (and only) argument
        options = Common.isElement(element) ? options : element;
        element = Common.isElement(element) ? element : null;
        options = options || {};

        if (element || options.render) {
            Common.warn('Engine.create: engine.render is deprecated (see docs)');
        }

        var defaults = {
            positionIterations: 6,
            velocityIterations: 4,
            constraintIterations: 2,
            enableSleeping: false,
            events: [],
            plugin: {},
            timing: {
                timestamp: 0,
                timeScale: 1
            },
            broadphase: {
                controller: Grid
            }
        };

        var engine = Common.extend(defaults, options);

        // @deprecated
        if (element || engine.render) {
            var renderDefaults = {
                element: element,
                controller: Render
            };
            
            engine.render = Common.extend(renderDefaults, engine.render);
        }

        // @deprecated
        if (engine.render && engine.render.controller) {
            engine.render = engine.render.controller.create(engine.render);
        }

        // @deprecated
        if (engine.render) {
            engine.render.engine = engine;
        }

        engine.world = options.world || World.create(engine.world);
        engine.pairs = Pairs.create();
        engine.broadphase = engine.broadphase.controller.create(engine.broadphase);
        engine.metrics = engine.metrics || { extended: false };


        return engine;
    };

    /**
     * Moves the simulation forward in time by `delta` ms.
     * The `correction` argument is an optional `Number` that specifies the time correction factor to apply to the update.
     * This can help improve the accuracy of the simulation in cases where `delta` is changing between updates.
     * The value of `correction` is defined as `delta / lastDelta`, i.e. the percentage change of `delta` over the last step.
     * Therefore the value is always `1` (no correction) when `delta` constant (or when no correction is desired, which is the default).
     * See the paper on <a href="http://lonesock.net/article/verlet.html">Time Corrected Verlet</a> for more information.
     *
     * Triggers `beforeUpdate` and `afterUpdate` events.
     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.
     * @method update
     * @param {engine} engine
     * @param {number} [delta=16.666]
     * @param {number} [correction=1]
     */
    Engine.update = function(engine, delta, correction) {
        delta = delta || 1000 / 60;
        correction = correction || 1;

        var world = engine.world,
            timing = engine.timing,
            broadphase = engine.broadphase,
            broadphasePairs = [],
            i;

        // increment timestamp
        timing.timestamp += delta * timing.timeScale;

        // create an event object
        var event = {
            timestamp: timing.timestamp
        };

        Events.trigger(engine, 'beforeUpdate', event);

        // get lists of all bodies and constraints, no matter what composites they are in
        var allBodies = Composite.allBodies(world),
            allConstraints = Composite.allConstraints(world);


        // if sleeping enabled, call the sleeping controller
        if (engine.enableSleeping)
            Sleeping.update(allBodies, timing.timeScale);

        // applies gravity to all bodies
        Engine._bodiesApplyGravity(allBodies, world.gravity);

        // update all body position and rotation by integration
        Engine._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);

        // update all constraints (first pass)
        Constraint.preSolveAll(allBodies);
        for (i = 0; i < engine.constraintIterations; i++) {
            Constraint.solveAll(allConstraints, timing.timeScale);
        }
        Constraint.postSolveAll(allBodies);

        // broadphase pass: find potential collision pairs
        if (broadphase.controller) {
            // if world is dirty, we must flush the whole grid
            if (world.isModified)
                broadphase.controller.clear(broadphase);

            // update the grid buckets based on current bodies
            broadphase.controller.update(broadphase, allBodies, engine, world.isModified);
            broadphasePairs = broadphase.pairsList;
        } else {
            // if no broadphase set, we just pass all bodies
            broadphasePairs = allBodies;
        }

        // clear all composite modified flags
        if (world.isModified) {
            Composite.setModified(world, false, false, true);
        }

        // narrowphase pass: find actual collisions, then create or update collision pairs
        var collisions = broadphase.detector(broadphasePairs, engine);

        // update collision pairs
        var pairs = engine.pairs,
            timestamp = timing.timestamp;
        Pairs.update(pairs, collisions, timestamp);
        Pairs.removeOld(pairs, timestamp);

        // wake up bodies involved in collisions
        if (engine.enableSleeping)
            Sleeping.afterCollisions(pairs.list, timing.timeScale);

        // trigger collision events
        if (pairs.collisionStart.length > 0)
            Events.trigger(engine, 'collisionStart', { pairs: pairs.collisionStart });

        // iteratively resolve position between collisions
        Resolver.preSolvePosition(pairs.list);
        for (i = 0; i < engine.positionIterations; i++) {
            Resolver.solvePosition(pairs.list, timing.timeScale);
        }
        Resolver.postSolvePosition(allBodies);

        // update all constraints (second pass)
        Constraint.preSolveAll(allBodies);
        for (i = 0; i < engine.constraintIterations; i++) {
            Constraint.solveAll(allConstraints, timing.timeScale);
        }
        Constraint.postSolveAll(allBodies);

        // iteratively resolve velocity between collisions
        Resolver.preSolveVelocity(pairs.list);
        for (i = 0; i < engine.velocityIterations; i++) {
            Resolver.solveVelocity(pairs.list, timing.timeScale);
        }

        // trigger collision events
        if (pairs.collisionActive.length > 0)
            Events.trigger(engine, 'collisionActive', { pairs: pairs.collisionActive });

        if (pairs.collisionEnd.length > 0)
            Events.trigger(engine, 'collisionEnd', { pairs: pairs.collisionEnd });


        // clear force buffers
        Engine._bodiesClearForces(allBodies);

        Events.trigger(engine, 'afterUpdate', event);

        return engine;
    };
    
    /**
     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.
     * @method merge
     * @param {engine} engineA
     * @param {engine} engineB
     */
    Engine.merge = function(engineA, engineB) {
        Common.extend(engineA, engineB);
        
        if (engineB.world) {
            engineA.world = engineB.world;

            Engine.clear(engineA);

            var bodies = Composite.allBodies(engineA.world);

            for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                Sleeping.set(body, false);
                body.id = Common.nextId();
            }
        }
    };

    /**
     * Clears the engine including the world, pairs and broadphase.
     * @method clear
     * @param {engine} engine
     */
    Engine.clear = function(engine) {
        var world = engine.world;
        
        Pairs.clear(engine.pairs);

        var broadphase = engine.broadphase;
        if (broadphase.controller) {
            var bodies = Composite.allBodies(world);
            broadphase.controller.clear(broadphase);
            broadphase.controller.update(broadphase, bodies, engine, true);
        }
    };

    /**
     * Zeroes the `body.force` and `body.torque` force buffers.
     * @method _bodiesClearForces
     * @private
     * @param {body[]} bodies
     */
    Engine._bodiesClearForces = function(bodies) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            // reset force buffers
            body.force.x = 0;
            body.force.y = 0;
            body.torque = 0;
        }
    };

    /**
     * Applys a mass dependant force to all given bodies.
     * @method _bodiesApplyGravity
     * @private
     * @param {body[]} bodies
     * @param {vector} gravity
     */
    Engine._bodiesApplyGravity = function(bodies, gravity) {
        var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001;

        if ((gravity.x === 0 && gravity.y === 0) || gravityScale === 0) {
            return;
        }
        
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.isStatic || body.isSleeping)
                continue;

            // apply gravity
            body.force.y += body.mass * gravity.y * gravityScale;
            body.force.x += body.mass * gravity.x * gravityScale;
        }
    };

    /**
     * Applys `Body.update` to all given `bodies`.
     * @method _bodiesUpdate
     * @private
     * @param {body[]} bodies
     * @param {number} deltaTime 
     * The amount of time elapsed between updates
     * @param {number} timeScale
     * @param {number} correction 
     * The Verlet correction factor (deltaTime / lastDeltaTime)
     * @param {bounds} worldBounds
     */
    Engine._bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.isStatic || body.isSleeping)
                continue;

            Body.update(body, deltaTime, timeScale, correction);
        }
    };

    /**
     * An alias for `Runner.run`, see `Matter.Runner` for more information.
     * @method run
     * @param {engine} engine
     */

    /**
    * Fired just before an update
    *
    * @event beforeUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update and all collision events
    *
    * @event afterUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)
    *
    * @event collisionStart
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)
    *
    * @event collisionActive
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)
    *
    * @event collisionEnd
    * @param {} event An event object
    * @param {} event.pairs List of affected pairs
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * An integer `Number` that specifies the number of position iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     *
     * @property positionIterations
     * @type number
     * @default 6
     */

    /**
     * An integer `Number` that specifies the number of velocity iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     *
     * @property velocityIterations
     * @type number
     * @default 4
     */

    /**
     * An integer `Number` that specifies the number of constraint iterations to perform each update.
     * The higher the value, the higher quality the simulation will be at the expense of performance.
     * The default value of `2` is usually very adequate.
     *
     * @property constraintIterations
     * @type number
     * @default 2
     */

    /**
     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.
     * Sleeping can improve stability and performance, but often at the expense of accuracy.
     *
     * @property enableSleeping
     * @type boolean
     * @default false
     */

    /**
     * An `Object` containing properties regarding the timing systems of the engine. 
     *
     * @property timing
     * @type object
     */

    /**
     * A `Number` that specifies the global scaling factor of time for all bodies.
     * A value of `0` freezes the simulation.
     * A value of `0.1` gives a slow-motion effect.
     * A value of `1.2` gives a speed-up effect.
     *
     * @property timing.timeScale
     * @type number
     * @default 1
     */

    /**
     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. 
     * It is incremented on every `Engine.update` by the given `delta` argument. 
     *
     * @property timing.timestamp
     * @type number
     * @default 0
     */

    /**
     * An instance of a `Render` controller. The default value is a `Matter.Render` instance created by `Engine.create`.
     * One may also develop a custom renderer module based on `Matter.Render` and pass an instance of it to `Engine.create` via `options.render`.
     *
     * A minimal custom renderer object must define at least three functions: `create`, `clear` and `world` (see `Matter.Render`).
     * It is also possible to instead pass the _module_ reference via `options.render.controller` and `Engine.create` will instantiate one for you.
     *
     * @property render
     * @type render
     * @deprecated see Demo.js for an example of creating a renderer
     * @default a Matter.Render instance
     */

    /**
     * An instance of a broadphase controller. The default value is a `Matter.Grid` instance created by `Engine.create`.
     *
     * @property broadphase
     * @type grid
     * @default a Matter.Grid instance
     */

    /**
     * A `World` composite object that will contain all simulated bodies and constraints.
     *
     * @property world
     * @type world
     * @default a Matter.World instance
     */

    /**
     * An object reserved for storing plugin-specific properties.
     *
     * @property plugin
     * @type {}
     */

})();

},{"../body/Body":1,"../body/Composite":2,"../body/World":3,"../collision/Grid":6,"../collision/Pairs":8,"../collision/Resolver":10,"../constraint/Constraint":12,"../render/Render":31,"./Common":14,"./Events":16,"./Metrics":18,"./Sleeping":22}],16:[function(_dereq_,module,exports){
/**
* The `Matter.Events` module contains methods to fire and listen to events on other objects.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Events
*/

var Events = {};

module.exports = Events;

var Common = _dereq_('./Common');

(function() {

    /**
     * Subscribes a callback function to the given object's `eventName`.
     * @method on
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */
    Events.on = function(object, eventNames, callback) {
        var names = eventNames.split(' '),
            name;

        for (var i = 0; i < names.length; i++) {
            name = names[i];
            object.events = object.events || {};
            object.events[name] = object.events[name] || [];
            object.events[name].push(callback);
        }

        return callback;
    };

    /**
     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.
     * @method off
     * @param {} object
     * @param {string} eventNames
     * @param {function} callback
     */
    Events.off = function(object, eventNames, callback) {
        if (!eventNames) {
            object.events = {};
            return;
        }

        // handle Events.off(object, callback)
        if (typeof eventNames === 'function') {
            callback = eventNames;
            eventNames = Common.keys(object.events).join(' ');
        }

        var names = eventNames.split(' ');

        for (var i = 0; i < names.length; i++) {
            var callbacks = object.events[names[i]],
                newCallbacks = [];

            if (callback && callbacks) {
                for (var j = 0; j < callbacks.length; j++) {
                    if (callbacks[j] !== callback)
                        newCallbacks.push(callbacks[j]);
                }
            }

            object.events[names[i]] = newCallbacks;
        }
    };

    /**
     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.
     * @method trigger
     * @param {} object
     * @param {string} eventNames
     * @param {} event
     */
    Events.trigger = function(object, eventNames, event) {
        var names,
            name,
            callbacks,
            eventClone;

        if (object.events) {
            if (!event)
                event = {};

            names = eventNames.split(' ');

            for (var i = 0; i < names.length; i++) {
                name = names[i];
                callbacks = object.events[name];

                if (callbacks) {
                    eventClone = Common.clone(event, false);
                    eventClone.name = name;
                    eventClone.source = object;

                    for (var j = 0; j < callbacks.length; j++) {
                        callbacks[j].apply(object, [eventClone]);
                    }
                }
            }
        }
    };

})();

},{"./Common":14}],17:[function(_dereq_,module,exports){
/**
* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.
*
* @class Matter
*/

var Matter = {};

module.exports = Matter;

var Plugin = _dereq_('./Plugin');
var Common = _dereq_('./Common');

(function() {

    /**
     * The library name.
     * @property name
     * @readOnly
     * @type {String}
     */
    Matter.name = 'matter-js';

    /**
     * The library version.
     * @property version
     * @readOnly
     * @type {String}
     */
    Matter.version = '0.14.2';

    /**
     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.
     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.
     * @property uses
     * @type {Array}
     */
    Matter.uses = [];

    /**
     * The plugins that have been installed through `Matter.Plugin.install`. Read only.
     * @property used
     * @readOnly
     * @type {Array}
     */
    Matter.used = [];

    /**
     * Installs the given plugins on the `Matter` namespace.
     * This is a short-hand for `Plugin.use`, see it for more information.
     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.
     * Avoid calling this function multiple times unless you intend to manually control installation order.
     * @method use
     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).
     */
    Matter.use = function() {
        Plugin.use(Matter, Array.prototype.slice.call(arguments));
    };

    /**
     * Chains a function to excute before the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method before
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain before the original
     * @return {function} The chained function that replaced the original
     */
    Matter.before = function(path, func) {
        path = path.replace(/^Matter./, '');
        return Common.chainPathBefore(Matter, path, func);
    };

    /**
     * Chains a function to excute after the original function on the given `path` relative to `Matter`.
     * See also docs for `Common.chain`.
     * @method after
     * @param {string} path The path relative to `Matter`
     * @param {function} func The function to chain after the original
     * @return {function} The chained function that replaced the original
     */
    Matter.after = function(path, func) {
        path = path.replace(/^Matter./, '');
        return Common.chainPathAfter(Matter, path, func);
    };

})();

},{"./Common":14,"./Plugin":20}],18:[function(_dereq_,module,exports){

},{"../body/Composite":2,"./Common":14}],19:[function(_dereq_,module,exports){
/**
* The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.
*
* @class Mouse
*/

var Mouse = {};

module.exports = Mouse;

var Common = _dereq_('../core/Common');

(function() {

    /**
     * Creates a mouse input.
     * @method create
     * @param {HTMLElement} element
     * @return {mouse} A new mouse
     */
    Mouse.create = function(element) {
        var mouse = {};

        if (!element) {
            Common.log('Mouse.create: element was undefined, defaulting to document.body', 'warn');
        }
        
        mouse.element = element || document.body;
        mouse.absolute = { x: 0, y: 0 };
        mouse.position = { x: 0, y: 0 };
        mouse.mousedownPosition = { x: 0, y: 0 };
        mouse.mouseupPosition = { x: 0, y: 0 };
        mouse.offset = { x: 0, y: 0 };
        mouse.scale = { x: 1, y: 1 };
        mouse.wheelDelta = 0;
        mouse.button = -1;
        mouse.pixelRatio = mouse.element.getAttribute('data-pixel-ratio') || 1;

        mouse.sourceEvents = {
            mousemove: null,
            mousedown: null,
            mouseup: null,
            mousewheel: null
        };
        
        mouse.mousemove = function(event) { 
            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
                touches = event.changedTouches;

            if (touches) {
                mouse.button = 0;
                event.preventDefault();
            }

            mouse.absolute.x = position.x;
            mouse.absolute.y = position.y;
            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            mouse.sourceEvents.mousemove = event;
        };
        
        mouse.mousedown = function(event) {
            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
                touches = event.changedTouches;

            if (touches) {
                mouse.button = 0;
                event.preventDefault();
            } else {
                mouse.button = event.button;
            }

            mouse.absolute.x = position.x;
            mouse.absolute.y = position.y;
            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            mouse.mousedownPosition.x = mouse.position.x;
            mouse.mousedownPosition.y = mouse.position.y;
            mouse.sourceEvents.mousedown = event;
        };
        
        mouse.mouseup = function(event) {
            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),
                touches = event.changedTouches;

            if (touches) {
                event.preventDefault();
            }
            
            mouse.button = -1;
            mouse.absolute.x = position.x;
            mouse.absolute.y = position.y;
            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
            mouse.mouseupPosition.x = mouse.position.x;
            mouse.mouseupPosition.y = mouse.position.y;
            mouse.sourceEvents.mouseup = event;
        };

        mouse.mousewheel = function(event) {
            mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));
            event.preventDefault();
        };

        Mouse.setElement(mouse, mouse.element);

        return mouse;
    };

    /**
     * Sets the element the mouse is bound to (and relative to).
     * @method setElement
     * @param {mouse} mouse
     * @param {HTMLElement} element
     */
    Mouse.setElement = function(mouse, element) {
        mouse.element = element;

        element.addEventListener('mousemove', mouse.mousemove);
        element.addEventListener('mousedown', mouse.mousedown);
        element.addEventListener('mouseup', mouse.mouseup);
        
        element.addEventListener('mousewheel', mouse.mousewheel);
        element.addEventListener('DOMMouseScroll', mouse.mousewheel);

        element.addEventListener('touchmove', mouse.mousemove);
        element.addEventListener('touchstart', mouse.mousedown);
        element.addEventListener('touchend', mouse.mouseup);
    };

    /**
     * Clears all captured source events.
     * @method clearSourceEvents
     * @param {mouse} mouse
     */
    Mouse.clearSourceEvents = function(mouse) {
        mouse.sourceEvents.mousemove = null;
        mouse.sourceEvents.mousedown = null;
        mouse.sourceEvents.mouseup = null;
        mouse.sourceEvents.mousewheel = null;
        mouse.wheelDelta = 0;
    };

    /**
     * Sets the mouse position offset.
     * @method setOffset
     * @param {mouse} mouse
     * @param {vector} offset
     */
    Mouse.setOffset = function(mouse, offset) {
        mouse.offset.x = offset.x;
        mouse.offset.y = offset.y;
        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
    };

    /**
     * Sets the mouse position scale.
     * @method setScale
     * @param {mouse} mouse
     * @param {vector} scale
     */
    Mouse.setScale = function(mouse, scale) {
        mouse.scale.x = scale.x;
        mouse.scale.y = scale.y;
        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;
        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;
    };
    
    /**
     * Gets the mouse position relative to an element given a screen pixel ratio.
     * @method _getRelativeMousePosition
     * @private
     * @param {} event
     * @param {} element
     * @param {number} pixelRatio
     * @return {}
     */
    Mouse._getRelativeMousePosition = function(event, element, pixelRatio) {
        var elementBounds = element.getBoundingClientRect(),
            rootNode = (document.documentElement || document.body.parentNode || document.body),
            scrollX = (window.pageXOffset !== undefined) ? window.pageXOffset : rootNode.scrollLeft,
            scrollY = (window.pageYOffset !== undefined) ? window.pageYOffset : rootNode.scrollTop,
            touches = event.changedTouches,
            x, y;
        
        if (touches) {
            x = touches[0].pageX - elementBounds.left - scrollX;
            y = touches[0].pageY - elementBounds.top - scrollY;
        } else {
            x = event.pageX - elementBounds.left - scrollX;
            y = event.pageY - elementBounds.top - scrollY;
        }

        return { 
            x: x / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),
            y: y / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)
        };
    };

})();

},{"../core/Common":14}],20:[function(_dereq_,module,exports){
/**
* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.
*
* @class Plugin
*/

var Plugin = {};

module.exports = Plugin;

var Common = _dereq_('./Common');

(function() {

    Plugin._registry = {};

    /**
     * Registers a plugin object so it can be resolved later by name.
     * @method register
     * @param plugin {} The plugin to register.
     * @return {object} The plugin.
     */
    Plugin.register = function(plugin) {
        if (!Plugin.isPlugin(plugin)) {
            Common.warn('Plugin.register:', Plugin.toString(plugin), 'does not implement all required fields.');
        }

        if (plugin.name in Plugin._registry) {
            var registered = Plugin._registry[plugin.name],
                pluginVersion = Plugin.versionParse(plugin.version).number,
                registeredVersion = Plugin.versionParse(registered.version).number;

            if (pluginVersion > registeredVersion) {
                Common.warn('Plugin.register:', Plugin.toString(registered), 'was upgraded to', Plugin.toString(plugin));
                Plugin._registry[plugin.name] = plugin;
            } else if (pluginVersion < registeredVersion) {
                Common.warn('Plugin.register:', Plugin.toString(registered), 'can not be downgraded to', Plugin.toString(plugin));
            } else if (plugin !== registered) {
                Common.warn('Plugin.register:', Plugin.toString(plugin), 'is already registered to different plugin object');
            }
        } else {
            Plugin._registry[plugin.name] = plugin;
        }

        return plugin;
    };

    /**
     * Resolves a dependency to a plugin object from the registry if it exists. 
     * The `dependency` may contain a version, but only the name matters when resolving.
     * @method resolve
     * @param dependency {string} The dependency.
     * @return {object} The plugin if resolved, otherwise `undefined`.
     */
    Plugin.resolve = function(dependency) {
        return Plugin._registry[Plugin.dependencyParse(dependency).name];
    };

    /**
     * Returns a pretty printed plugin name and version.
     * @method toString
     * @param plugin {} The plugin.
     * @return {string} Pretty printed plugin name and version.
     */
    Plugin.toString = function(plugin) {
        return typeof plugin === 'string' ? plugin : (plugin.name || 'anonymous') + '@' + (plugin.version || plugin.range || '0.0.0');
    };

    /**
     * Returns `true` if the object meets the minimum standard to be considered a plugin.
     * This means it must define the following properties:
     * - `name`
     * - `version`
     * - `install`
     * @method isPlugin
     * @param obj {} The obj to test.
     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.
     */
    Plugin.isPlugin = function(obj) {
        return obj && obj.name && obj.version && obj.install;
    };

    /**
     * Returns `true` if a plugin with the given `name` been installed on `module`.
     * @method isUsed
     * @param module {} The module.
     * @param name {string} The plugin name.
     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.
     */
    Plugin.isUsed = function(module, name) {
        return module.used.indexOf(name) > -1;
    };

    /**
     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.
     * If `plugin.for` is not specified then it is assumed to be applicable.
     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.
     * @method isFor
     * @param plugin {} The plugin.
     * @param module {} The module.
     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.
     */
    Plugin.isFor = function(plugin, module) {
        var parsed = plugin.for && Plugin.dependencyParse(plugin.for);
        return !plugin.for || (module.name === parsed.name && Plugin.versionSatisfies(module.version, parsed.range));
    };

    /**
     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.
     * For installing plugins on `Matter` see the convenience function `Matter.use`.
     * Plugins may be specified either by their name or a reference to the plugin object.
     * Plugins themselves may specify further dependencies, but each plugin is installed only once.
     * Order is important, a topological sort is performed to find the best resulting order of installation.
     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.
     * This function logs the resulting status of each dependency in the console, along with any warnings.
     * - A green tick  indicates a dependency was resolved and installed.
     * - An orange diamond  indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.
     * - A red cross  indicates a dependency could not be resolved.
     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.
     * @method use
     * @param module {} The module install plugins on.
     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).
     */
    Plugin.use = function(module, plugins) {
        module.uses = (module.uses || []).concat(plugins || []);

        if (module.uses.length === 0) {
            Common.warn('Plugin.use:', Plugin.toString(module), 'does not specify any dependencies to install.');
            return;
        }

        var dependencies = Plugin.dependencies(module),
            sortedDependencies = Common.topologicalSort(dependencies),
            status = [];

        for (var i = 0; i < sortedDependencies.length; i += 1) {
            if (sortedDependencies[i] === module.name) {
                continue;
            }

            var plugin = Plugin.resolve(sortedDependencies[i]);

            if (!plugin) {
                status.push(' ' + sortedDependencies[i]);
                continue;
            }

            if (Plugin.isUsed(module, plugin.name)) {
                continue;
            }

            if (!Plugin.isFor(plugin, module)) {
                Common.warn('Plugin.use:', Plugin.toString(plugin), 'is for', plugin.for, 'but installed on', Plugin.toString(module) + '.');
                plugin._warned = true;
            }

            if (plugin.install) {
                plugin.install(module);
            } else {
                Common.warn('Plugin.use:', Plugin.toString(plugin), 'does not specify an install function.');
                plugin._warned = true;
            }

            if (plugin._warned) {
                status.push(' ' + Plugin.toString(plugin));
                delete plugin._warned;
            } else {
                status.push(' ' + Plugin.toString(plugin));
            }

            module.used.push(plugin.name);
        }

        if (status.length > 0) {
            Common.info(status.join('  '));
        }
    };

    /**
     * Recursively finds all of a module's dependencies and returns a flat dependency graph.
     * @method dependencies
     * @param module {} The module.
     * @return {object} A dependency graph.
     */
    Plugin.dependencies = function(module, tracked) {
        var parsedBase = Plugin.dependencyParse(module),
            name = parsedBase.name;

        tracked = tracked || {};

        if (name in tracked) {
            return;
        }

        module = Plugin.resolve(module) || module;

        tracked[name] = Common.map(module.uses || [], function(dependency) {
            if (Plugin.isPlugin(dependency)) {
                Plugin.register(dependency);
            }

            var parsed = Plugin.dependencyParse(dependency),
                resolved = Plugin.resolve(dependency);

            if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {
                Common.warn(
                    'Plugin.dependencies:', Plugin.toString(resolved), 'does not satisfy',
                    Plugin.toString(parsed), 'used by', Plugin.toString(parsedBase) + '.'
                );

                resolved._warned = true;
                module._warned = true;
            } else if (!resolved) {
                Common.warn(
                    'Plugin.dependencies:', Plugin.toString(dependency), 'used by',
                    Plugin.toString(parsedBase), 'could not be resolved.'
                );

                module._warned = true;
            }

            return parsed.name;
        });

        for (var i = 0; i < tracked[name].length; i += 1) {
            Plugin.dependencies(tracked[name][i], tracked);
        }

        return tracked;
    };

    /**
     * Parses a dependency string into its components.
     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * This function can also handle dependencies that are already resolved (e.g. a module object).
     * @method dependencyParse
     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.
     * @return {object} The dependency parsed into its components.
     */
    Plugin.dependencyParse = function(dependency) {
        if (Common.isString(dependency)) {
            var pattern = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/;

            if (!pattern.test(dependency)) {
                Common.warn('Plugin.dependencyParse:', dependency, 'is not a valid dependency string.');
            }

            return {
                name: dependency.split('@')[0],
                range: dependency.split('@')[1] || '*'
            };
        }

        return {
            name: dependency.name,
            range: dependency.range || dependency.version
        };
    };

    /**
     * Parses a version string into its components.  
     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).
     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.
     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).
     * Only the following range types are supported:
     * - Tilde ranges e.g. `~1.2.3`
     * - Caret ranges e.g. `^1.2.3`
     * - Exact version e.g. `1.2.3`
     * - Any version `*`
     * @method versionParse
     * @param range {string} The version string.
     * @return {object} The version range parsed into its components.
     */
    Plugin.versionParse = function(range) {
        var pattern = /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/;

        if (!pattern.test(range)) {
            Common.warn('Plugin.versionParse:', range, 'is not a valid version or range.');
        }

        var identifiers = range.split('-');
        range = identifiers[0];

        var isRange = isNaN(Number(range[0])),
            version = isRange ? range.substr(1) : range,
            parts = Common.map(version.split('.'), function(part) {
                return Number(part);
            });

        return {
            isRange: isRange,
            version: version,
            range: range,
            operator: isRange ? range[0] : '',
            parts: parts,
            prerelease: identifiers[1],
            number: parts[0] * 1e8 + parts[1] * 1e4 + parts[2]
        };
    };

    /**
     * Returns `true` if `version` satisfies the given `range`.
     * See documentation for `Plugin.versionParse` for a description of the format.
     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.
     * @method versionSatisfies
     * @param version {string} The version string.
     * @param range {string} The range string.
     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.
     */
    Plugin.versionSatisfies = function(version, range) {
        range = range || '*';

        var rangeParsed = Plugin.versionParse(range),
            rangeParts = rangeParsed.parts,
            versionParsed = Plugin.versionParse(version),
            versionParts = versionParsed.parts;

        if (rangeParsed.isRange) {
            if (rangeParsed.operator === '*' || version === '*') {
                return true;
            }

            if (rangeParsed.operator === '~') {
                return versionParts[0] === rangeParts[0] && versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
            }

            if (rangeParsed.operator === '^') {
                if (rangeParts[0] > 0) {
                    return versionParts[0] === rangeParts[0] && versionParsed.number >= rangeParsed.number;
                }

                if (rangeParts[1] > 0) {
                    return versionParts[1] === rangeParts[1] && versionParts[2] >= rangeParts[2];
                }

                return versionParts[2] === rangeParts[2];
            }
        }

        return version === range || version === '*';
    };

})();

},{"./Common":14}],21:[function(_dereq_,module,exports){
/**
* The `Matter.Runner` module is an optional utility which provides a game loop, 
* that handles continuously updating a `Matter.Engine` for you within a browser.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* If you are using your own game loop instead, then you do not need the `Matter.Runner` module.
* Instead just call `Engine.update(engine, delta)` in your own loop.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Runner
*/

var Runner = {};

module.exports = Runner;

var Events = _dereq_('./Events');
var Engine = _dereq_('./Engine');
var Common = _dereq_('./Common');

(function() {

    var _requestAnimationFrame,
        _cancelAnimationFrame;

    if (typeof window !== 'undefined') {
        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame
                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame;
   
        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame 
                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
    }

    if (!_requestAnimationFrame) {
        var _frameTimeout;

        _requestAnimationFrame = function(callback){ 
            _frameTimeout = setTimeout(function() { 
                callback(Common.now()); 
            }, 1000 / 60);
        };

        _cancelAnimationFrame = function() {
            clearTimeout(_frameTimeout);
        };
    }

    /**
     * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.
     * @method create
     * @param {} options
     */
    Runner.create = function(options) {
        var defaults = {
            fps: 60,
            correction: 1,
            deltaSampleSize: 60,
            counterTimestamp: 0,
            frameCounter: 0,
            deltaHistory: [],
            timePrev: null,
            timeScalePrev: 1,
            frameRequestId: null,
            isFixed: false,
            enabled: true
        };

        var runner = Common.extend(defaults, options);

        runner.delta = runner.delta || 1000 / runner.fps;
        runner.deltaMin = runner.deltaMin || 1000 / runner.fps;
        runner.deltaMax = runner.deltaMax || 1000 / (runner.fps * 0.5);
        runner.fps = 1000 / runner.delta;

        return runner;
    };

    /**
     * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.
     * @method run
     * @param {engine} engine
     */
    Runner.run = function(runner, engine) {
        // create runner if engine is first argument
        if (typeof runner.positionIterations !== 'undefined') {
            engine = runner;
            runner = Runner.create();
        }

        (function render(time){
            runner.frameRequestId = _requestAnimationFrame(render);

            if (time && runner.enabled) {
                Runner.tick(runner, engine, time);
            }
        })();

        return runner;
    };

    /**
     * A game loop utility that updates the engine and renderer by one step (a 'tick').
     * Features delta smoothing, time correction and fixed or dynamic timing.
     * Triggers `beforeTick`, `tick` and `afterTick` events on the engine.
     * Consider just `Engine.update(engine, delta)` if you're using your own loop.
     * @method tick
     * @param {runner} runner
     * @param {engine} engine
     * @param {number} time
     */
    Runner.tick = function(runner, engine, time) {
        var timing = engine.timing,
            correction = 1,
            delta;

        // create an event object
        var event = {
            timestamp: timing.timestamp
        };

        Events.trigger(runner, 'beforeTick', event);
        Events.trigger(engine, 'beforeTick', event); // @deprecated

        if (runner.isFixed) {
            // fixed timestep
            delta = runner.delta;
        } else {
            // dynamic timestep based on wall clock between calls
            delta = (time - runner.timePrev) || runner.delta;
            runner.timePrev = time;

            // optimistically filter delta over a few frames, to improve stability
            runner.deltaHistory.push(delta);
            runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);
            delta = Math.min.apply(null, runner.deltaHistory);
            
            // limit delta
            delta = delta < runner.deltaMin ? runner.deltaMin : delta;
            delta = delta > runner.deltaMax ? runner.deltaMax : delta;

            // correction for delta
            correction = delta / runner.delta;

            // update engine timing object
            runner.delta = delta;
        }

        // time correction for time scaling
        if (runner.timeScalePrev !== 0)
            correction *= timing.timeScale / runner.timeScalePrev;

        if (timing.timeScale === 0)
            correction = 0;

        runner.timeScalePrev = timing.timeScale;
        runner.correction = correction;

        // fps counter
        runner.frameCounter += 1;
        if (time - runner.counterTimestamp >= 1000) {
            runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);
            runner.counterTimestamp = time;
            runner.frameCounter = 0;
        }

        Events.trigger(runner, 'tick', event);
        Events.trigger(engine, 'tick', event); // @deprecated

        // if world has been modified, clear the render scene graph
        if (engine.world.isModified 
            && engine.render
            && engine.render.controller
            && engine.render.controller.clear) {
            engine.render.controller.clear(engine.render); // @deprecated
        }

        // update
        Events.trigger(runner, 'beforeUpdate', event);
        Engine.update(engine, delta, correction);
        Events.trigger(runner, 'afterUpdate', event);

        // render
        // @deprecated
        if (engine.render && engine.render.controller) {
            Events.trigger(runner, 'beforeRender', event);
            Events.trigger(engine, 'beforeRender', event); // @deprecated

            engine.render.controller.world(engine.render);

            Events.trigger(runner, 'afterRender', event);
            Events.trigger(engine, 'afterRender', event); // @deprecated
        }

        Events.trigger(runner, 'afterTick', event);
        Events.trigger(engine, 'afterTick', event); // @deprecated
    };

    /**
     * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.
     * If you wish to only temporarily pause the engine, see `engine.enabled` instead.
     * @method stop
     * @param {runner} runner
     */
    Runner.stop = function(runner) {
        _cancelAnimationFrame(runner.frameRequestId);
    };

    /**
     * Alias for `Runner.run`.
     * @method start
     * @param {runner} runner
     * @param {engine} engine
     */
    Runner.start = function(runner, engine) {
        Runner.run(runner, engine);
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired at the start of a tick, before any updates to the engine or timing
    *
    * @event beforeTick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after engine timing updated, but just before update
    *
    * @event tick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired at the end of a tick, after engine update and after rendering
    *
    * @event afterTick
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired before update
    *
    * @event beforeUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after update
    *
    * @event afterUpdate
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired before rendering
    *
    * @event beforeRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    * @deprecated
    */

    /**
    * Fired after rendering
    *
    * @event afterRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    * @deprecated
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * A flag that specifies whether the runner is running or not.
     *
     * @property enabled
     * @type boolean
     * @default true
     */

    /**
     * A `Boolean` that specifies if the runner should use a fixed timestep (otherwise it is variable).
     * If timing is fixed, then the apparent simulation speed will change depending on the frame rate (but behaviour will be deterministic).
     * If the timing is variable, then the apparent simulation speed will be constant (approximately, but at the cost of determininism).
     *
     * @property isFixed
     * @type boolean
     * @default false
     */

    /**
     * A `Number` that specifies the time step between updates in milliseconds.
     * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.
     * If it is `false`, then `delta` can dynamically change to maintain the correct apparent simulation speed.
     *
     * @property delta
     * @type number
     * @default 1000 / 60
     */

})();

},{"./Common":14,"./Engine":15,"./Events":16}],22:[function(_dereq_,module,exports){
/**
* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.
*
* @class Sleeping
*/

var Sleeping = {};

module.exports = Sleeping;

var Events = _dereq_('./Events');

(function() {

    Sleeping._motionWakeThreshold = 0.18;
    Sleeping._motionSleepThreshold = 0.08;
    Sleeping._minBias = 0.9;

    /**
     * Puts bodies to sleep or wakes them up depending on their motion.
     * @method update
     * @param {body[]} bodies
     * @param {number} timeScale
     */
    Sleeping.update = function(bodies, timeScale) {
        var timeFactor = timeScale * timeScale * timeScale;

        // update bodies sleeping status
        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;

            // wake up bodies if they have a force applied
            if (body.force.x !== 0 || body.force.y !== 0) {
                Sleeping.set(body, false);
                continue;
            }

            var minMotion = Math.min(body.motion, motion),
                maxMotion = Math.max(body.motion, motion);
        
            // biased average motion estimation between frames
            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;
            
            if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {
                body.sleepCounter += 1;
                
                if (body.sleepCounter >= body.sleepThreshold)
                    Sleeping.set(body, true);
            } else if (body.sleepCounter > 0) {
                body.sleepCounter -= 1;
            }
        }
    };

    /**
     * Given a set of colliding pairs, wakes the sleeping bodies involved.
     * @method afterCollisions
     * @param {pair[]} pairs
     * @param {number} timeScale
     */
    Sleeping.afterCollisions = function(pairs, timeScale) {
        var timeFactor = timeScale * timeScale * timeScale;

        // wake up bodies involved in collisions
        for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            
            // don't wake inactive pairs
            if (!pair.isActive)
                continue;

            var collision = pair.collision,
                bodyA = collision.bodyA.parent, 
                bodyB = collision.bodyB.parent;
        
            // don't wake if at least one body is static
            if ((bodyA.isSleeping && bodyB.isSleeping) || bodyA.isStatic || bodyB.isStatic)
                continue;
        
            if (bodyA.isSleeping || bodyB.isSleeping) {
                var sleepingBody = (bodyA.isSleeping && !bodyA.isStatic) ? bodyA : bodyB,
                    movingBody = sleepingBody === bodyA ? bodyB : bodyA;

                if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {
                    Sleeping.set(sleepingBody, false);
                }
            }
        }
    };
  
    /**
     * Set a body as sleeping or awake.
     * @method set
     * @param {body} body
     * @param {boolean} isSleeping
     */
    Sleeping.set = function(body, isSleeping) {
        var wasSleeping = body.isSleeping;

        if (isSleeping) {
            body.isSleeping = true;
            body.sleepCounter = body.sleepThreshold;

            body.positionImpulse.x = 0;
            body.positionImpulse.y = 0;

            body.positionPrev.x = body.position.x;
            body.positionPrev.y = body.position.y;

            body.anglePrev = body.angle;
            body.speed = 0;
            body.angularSpeed = 0;
            body.motion = 0;

            if (!wasSleeping) {
                Events.trigger(body, 'sleepStart');
            }
        } else {
            body.isSleeping = false;
            body.sleepCounter = 0;

            if (wasSleeping) {
                Events.trigger(body, 'sleepEnd');
            }
        }
    };

})();

},{"./Events":16}],23:[function(_dereq_,module,exports){
/**
* The `Matter.Bodies` module contains factory methods for creating rigid body models 
* with commonly used body configurations (such as rectangles, circles and other polygons).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Bodies
*/

// TODO: true circle bodies

var Bodies = {};

module.exports = Bodies;

var Vertices = _dereq_('../geometry/Vertices');
var Common = _dereq_('../core/Common');
var Body = _dereq_('../body/Body');
var Bounds = _dereq_('../geometry/Bounds');
var Vector = _dereq_('../geometry/Vector');
var decomp;

(function() {

    /**
     * Creates a new rigid body model with a rectangle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method rectangle
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {object} [options]
     * @return {body} A new rectangle body
     */
    Bodies.rectangle = function(x, y, width, height, options) {
        options = options || {};

        var rectangle = { 
            label: 'Rectangle Body',
            position: { x: x, y: y },
            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)
        };

        if (options.chamfer) {
            var chamfer = options.chamfer;
            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, 
                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
            delete options.chamfer;
        }

        return Body.create(Common.extend({}, rectangle, options));
    };
    
    /**
     * Creates a new rigid body model with a trapezoid hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method trapezoid
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {number} slope
     * @param {object} [options]
     * @return {body} A new trapezoid body
     */
    Bodies.trapezoid = function(x, y, width, height, slope, options) {
        options = options || {};

        slope *= 0.5;
        var roof = (1 - (slope * 2)) * width;
        
        var x1 = width * slope,
            x2 = x1 + roof,
            x3 = x2 + x1,
            verticesPath;

        if (slope < 0.5) {
            verticesPath = 'L 0 0 L ' + x1 + ' ' + (-height) + ' L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';
        } else {
            verticesPath = 'L 0 0 L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';
        }

        var trapezoid = { 
            label: 'Trapezoid Body',
            position: { x: x, y: y },
            vertices: Vertices.fromPath(verticesPath)
        };

        if (options.chamfer) {
            var chamfer = options.chamfer;
            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, 
                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
            delete options.chamfer;
        }

        return Body.create(Common.extend({}, trapezoid, options));
    };

    /**
     * Creates a new rigid body model with a circle hull. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method circle
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {object} [options]
     * @param {number} [maxSides]
     * @return {body} A new circle body
     */
    Bodies.circle = function(x, y, radius, options, maxSides) {
        options = options || {};

        var circle = {
            label: 'Circle Body',
            circleRadius: radius
        };
        
        // approximate circles with polygons until true circles implemented in SAT
        maxSides = maxSides || 25;
        var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));

        // optimisation: always use even number of sides (half the number of unique axes)
        if (sides % 2 === 1)
            sides += 1;

        return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));
    };

    /**
     * Creates a new rigid body model with a regular polygon hull with the given number of sides. 
     * The options parameter is an object that specifies any properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method polygon
     * @param {number} x
     * @param {number} y
     * @param {number} sides
     * @param {number} radius
     * @param {object} [options]
     * @return {body} A new regular polygon body
     */
    Bodies.polygon = function(x, y, sides, radius, options) {
        options = options || {};

        if (sides < 3)
            return Bodies.circle(x, y, radius, options);

        var theta = 2 * Math.PI / sides,
            path = '',
            offset = theta * 0.5;

        for (var i = 0; i < sides; i += 1) {
            var angle = offset + (i * theta),
                xx = Math.cos(angle) * radius,
                yy = Math.sin(angle) * radius;

            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';
        }

        var polygon = { 
            label: 'Polygon Body',
            position: { x: x, y: y },
            vertices: Vertices.fromPath(path)
        };

        if (options.chamfer) {
            var chamfer = options.chamfer;
            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, 
                                    chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
            delete options.chamfer;
        }

        return Body.create(Common.extend({}, polygon, options));
    };

    /**
     * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).
     * If the vertices are convex, they will pass through as supplied.
     * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.
     * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).
     * By default the decomposition will discard collinear edges (to improve performance).
     * It can also optionally discard any parts that have an area less than `minimumArea`.
     * If the vertices can not be decomposed, the result will fall back to using the convex hull.
     * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.
     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
     * @method fromVertices
     * @param {number} x
     * @param {number} y
     * @param [[vector]] vertexSets
     * @param {object} [options]
     * @param {bool} [flagInternal=false]
     * @param {number} [removeCollinear=0.01]
     * @param {number} [minimumArea=10]
     * @return {body}
     */
    Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
        if (!decomp) {
            decomp = Common._requireGlobal('decomp', 'poly-decomp');
        }

        var body,
            parts,
            isConvex,
            vertices,
            i,
            j,
            k,
            v,
            z;

        options = options || {};
        parts = [];

        flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;
        removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;
        minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;

        if (!decomp) {
            Common.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.');
        }

        // ensure vertexSets is an array of arrays
        if (!Common.isArray(vertexSets[0])) {
            vertexSets = [vertexSets];
        }

        for (v = 0; v < vertexSets.length; v += 1) {
            vertices = vertexSets[v];
            isConvex = Vertices.isConvex(vertices);

            if (isConvex || !decomp) {
                if (isConvex) {
                    vertices = Vertices.clockwiseSort(vertices);
                } else {
                    // fallback to convex hull when decomposition is not possible
                    vertices = Vertices.hull(vertices);
                }

                parts.push({
                    position: { x: x, y: y },
                    vertices: vertices
                });
            } else {
                // initialise a decomposition
                var concave = vertices.map(function(vertex) {
                    return [vertex.x, vertex.y];
                });

                // vertices are concave and simple, we can decompose into parts
                decomp.makeCCW(concave);
                if (removeCollinear !== false)
                    decomp.removeCollinearPoints(concave, removeCollinear);

                // use the quick decomposition algorithm (Bayazit)
                var decomposed = decomp.quickDecomp(concave);

                // for each decomposed chunk
                for (i = 0; i < decomposed.length; i++) {
                    var chunk = decomposed[i];

                    // convert vertices into the correct structure
                    var chunkVertices = chunk.map(function(vertices) {
                        return {
                            x: vertices[0],
                            y: vertices[1]
                        };
                    });

                    // skip small chunks
                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)
                        continue;

                    // create a compound part
                    parts.push({
                        position: Vertices.centre(chunkVertices),
                        vertices: chunkVertices
                    });
                }
            }
        }

        // create body parts
        for (i = 0; i < parts.length; i++) {
            parts[i] = Body.create(Common.extend(parts[i], options));
        }

        // flag internal edges (coincident part edges)
        if (flagInternal) {
            var coincident_max_dist = 5;

            for (i = 0; i < parts.length; i++) {
                var partA = parts[i];

                for (j = i + 1; j < parts.length; j++) {
                    var partB = parts[j];

                    if (Bounds.overlaps(partA.bounds, partB.bounds)) {
                        var pav = partA.vertices,
                            pbv = partB.vertices;

                        // iterate vertices of both parts
                        for (k = 0; k < partA.vertices.length; k++) {
                            for (z = 0; z < partB.vertices.length; z++) {
                                // find distances between the vertices
                                var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])),
                                    db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));

                                // if both vertices are very close, consider the edge concident (internal)
                                if (da < coincident_max_dist && db < coincident_max_dist) {
                                    pav[k].isInternal = true;
                                    pbv[z].isInternal = true;
                                }
                            }
                        }

                    }
                }
            }
        }

        if (parts.length > 1) {
            // create the parent body to be returned, that contains generated compound parts
            body = Body.create(Common.extend({ parts: parts.slice(0) }, options));
            Body.setPosition(body, { x: x, y: y });

            return body;
        } else {
            return parts[0];
        }
    };

})();

},{"../body/Body":1,"../core/Common":14,"../geometry/Bounds":26,"../geometry/Vector":28,"../geometry/Vertices":29}],24:[function(_dereq_,module,exports){
/**
* The `Matter.Composites` module contains factory methods for creating composite bodies
* with commonly used configurations (such as stacks and chains).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Composites
*/

var Composites = {};

module.exports = Composites;

var Composite = _dereq_('../body/Composite');
var Constraint = _dereq_('../constraint/Constraint');
var Common = _dereq_('../core/Common');
var Body = _dereq_('../body/Body');
var Bodies = _dereq_('./Bodies');

(function() {

    /**
     * Create a new composite containing bodies created in the callback in a grid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method stack
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */
    Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
        var stack = Composite.create({ label: 'Stack' }),
            x = xx,
            y = yy,
            lastBody,
            i = 0;

        for (var row = 0; row < rows; row++) {
            var maxHeight = 0;
            
            for (var column = 0; column < columns; column++) {
                var body = callback(x, y, column, row, lastBody, i);
                    
                if (body) {
                    var bodyHeight = body.bounds.max.y - body.bounds.min.y,
                        bodyWidth = body.bounds.max.x - body.bounds.min.x; 

                    if (bodyHeight > maxHeight)
                        maxHeight = bodyHeight;
                    
                    Body.translate(body, { x: bodyWidth * 0.5, y: bodyHeight * 0.5 });

                    x = body.bounds.max.x + columnGap;

                    Composite.addBody(stack, body);
                    
                    lastBody = body;
                    i += 1;
                } else {
                    x += columnGap;
                }
            }
            
            y += maxHeight + rowGap;
            x = xx;
        }

        return stack;
    };
    
    /**
     * Chains all bodies in the given composite together using constraints.
     * @method chain
     * @param {composite} composite
     * @param {number} xOffsetA
     * @param {number} yOffsetA
     * @param {number} xOffsetB
     * @param {number} yOffsetB
     * @param {object} options
     * @return {composite} A new composite containing objects chained together with constraints
     */
    Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
        var bodies = composite.bodies;
        
        for (var i = 1; i < bodies.length; i++) {
            var bodyA = bodies[i - 1],
                bodyB = bodies[i],
                bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,
                bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, 
                bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,
                bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;
        
            var defaults = {
                bodyA: bodyA,
                pointA: { x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA },
                bodyB: bodyB,
                pointB: { x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB }
            };
            
            var constraint = Common.extend(defaults, options);
        
            Composite.addConstraint(composite, Constraint.create(constraint));
        }

        composite.label += ' Chain';
        
        return composite;
    };

    /**
     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
     * @method mesh
     * @param {composite} composite
     * @param {number} columns
     * @param {number} rows
     * @param {boolean} crossBrace
     * @param {object} options
     * @return {composite} The composite containing objects meshed together with constraints
     */
    Composites.mesh = function(composite, columns, rows, crossBrace, options) {
        var bodies = composite.bodies,
            row,
            col,
            bodyA,
            bodyB,
            bodyC;
        
        for (row = 0; row < rows; row++) {
            for (col = 1; col < columns; col++) {
                bodyA = bodies[(col - 1) + (row * columns)];
                bodyB = bodies[col + (row * columns)];
                Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));
            }

            if (row > 0) {
                for (col = 0; col < columns; col++) {
                    bodyA = bodies[col + ((row - 1) * columns)];
                    bodyB = bodies[col + (row * columns)];
                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));

                    if (crossBrace && col > 0) {
                        bodyC = bodies[(col - 1) + ((row - 1) * columns)];
                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));
                    }

                    if (crossBrace && col < columns - 1) {
                        bodyC = bodies[(col + 1) + ((row - 1) * columns)];
                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));
                    }
                }
            }
        }

        composite.label += ' Mesh';
        
        return composite;
    };
    
    /**
     * Create a new composite containing bodies created in the callback in a pyramid arrangement.
     * This function uses the body's bounds to prevent overlaps.
     * @method pyramid
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {function} callback
     * @return {composite} A new composite containing objects created in the callback
     */
    Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
        return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {
            var actualRows = Math.min(rows, Math.ceil(columns / 2)),
                lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;
            
            if (row > actualRows)
                return;
            
            // reverse row order
            row = actualRows - row;
            
            var start = row,
                end = columns - 1 - row;

            if (column < start || column > end)
                return;
            
            // retroactively fix the first body's position, since width was unknown
            if (i === 1) {
                Body.translate(lastBody, { x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0 });
            }

            var xOffset = lastBody ? column * lastBodyWidth : 0;
            
            return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);
        });
    };

    /**
     * Creates a composite with a Newton's Cradle setup of bodies and constraints.
     * @method newtonsCradle
     * @param {number} xx
     * @param {number} yy
     * @param {number} number
     * @param {number} size
     * @param {number} length
     * @return {composite} A new composite newtonsCradle body
     */
    Composites.newtonsCradle = function(xx, yy, number, size, length) {
        var newtonsCradle = Composite.create({ label: 'Newtons Cradle' });

        for (var i = 0; i < number; i++) {
            var separation = 1.9,
                circle = Bodies.circle(xx + i * (size * separation), yy + length, size, 
                            { inertia: Infinity, restitution: 1, friction: 0, frictionAir: 0.0001, slop: 1 }),
                constraint = Constraint.create({ pointA: { x: xx + i * (size * separation), y: yy }, bodyB: circle });

            Composite.addBody(newtonsCradle, circle);
            Composite.addConstraint(newtonsCradle, constraint);
        }

        return newtonsCradle;
    };
    
    /**
     * Creates a composite with simple car setup of bodies and constraints.
     * @method car
     * @param {number} xx
     * @param {number} yy
     * @param {number} width
     * @param {number} height
     * @param {number} wheelSize
     * @return {composite} A new composite car body
     */
    Composites.car = function(xx, yy, width, height, wheelSize) {
        var group = Body.nextGroup(true),
            wheelBase = 20,
            wheelAOffset = -width * 0.5 + wheelBase,
            wheelBOffset = width * 0.5 - wheelBase,
            wheelYOffset = 0;
    
        var car = Composite.create({ label: 'Car' }),
            body = Bodies.rectangle(xx, yy, width, height, { 
                collisionFilter: {
                    group: group
                },
                chamfer: {
                    radius: height * 0.5
                },
                density: 0.0002
            });
    
        var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, { 
            collisionFilter: {
                group: group
            },
            friction: 0.8
        });
                    
        var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, { 
            collisionFilter: {
                group: group
            },
            friction: 0.8
        });
                    
        var axelA = Constraint.create({
            bodyB: body,
            pointB: { x: wheelAOffset, y: wheelYOffset },
            bodyA: wheelA,
            stiffness: 1,
            length: 0
        });
                        
        var axelB = Constraint.create({
            bodyB: body,
            pointB: { x: wheelBOffset, y: wheelYOffset },
            bodyA: wheelB,
            stiffness: 1,
            length: 0
        });
        
        Composite.addBody(car, body);
        Composite.addBody(car, wheelA);
        Composite.addBody(car, wheelB);
        Composite.addConstraint(car, axelA);
        Composite.addConstraint(car, axelB);

        return car;
    };

    /**
     * Creates a simple soft body like object.
     * @method softBody
     * @param {number} xx
     * @param {number} yy
     * @param {number} columns
     * @param {number} rows
     * @param {number} columnGap
     * @param {number} rowGap
     * @param {boolean} crossBrace
     * @param {number} particleRadius
     * @param {} particleOptions
     * @param {} constraintOptions
     * @return {composite} A new composite softBody
     */
    Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
        particleOptions = Common.extend({ inertia: Infinity }, particleOptions);
        constraintOptions = Common.extend({ stiffness: 0.2, render: { type: 'line', anchors: false } }, constraintOptions);

        var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {
            return Bodies.circle(x, y, particleRadius, particleOptions);
        });

        Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);

        softBody.label = 'Soft Body';

        return softBody;
    };

})();

},{"../body/Body":1,"../body/Composite":2,"../constraint/Constraint":12,"../core/Common":14,"./Bodies":23}],25:[function(_dereq_,module,exports){
/**
* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.
*
* @class Axes
*/

var Axes = {};

module.exports = Axes;

var Vector = _dereq_('../geometry/Vector');
var Common = _dereq_('../core/Common');

(function() {

    /**
     * Creates a new set of axes from the given vertices.
     * @method fromVertices
     * @param {vertices} vertices
     * @return {axes} A new axes from the given vertices
     */
    Axes.fromVertices = function(vertices) {
        var axes = {};

        // find the unique axes, using edge normal gradients
        for (var i = 0; i < vertices.length; i++) {
            var j = (i + 1) % vertices.length, 
                normal = Vector.normalise({ 
                    x: vertices[j].y - vertices[i].y, 
                    y: vertices[i].x - vertices[j].x
                }),
                gradient = (normal.y === 0) ? Infinity : (normal.x / normal.y);
            
            // limit precision
            gradient = gradient.toFixed(3).toString();
            axes[gradient] = normal;
        }

        return Common.values(axes);
    };

    /**
     * Rotates a set of axes by the given angle.
     * @method rotate
     * @param {axes} axes
     * @param {number} angle
     */
    Axes.rotate = function(axes, angle) {
        if (angle === 0)
            return;
        
        var cos = Math.cos(angle),
            sin = Math.sin(angle);

        for (var i = 0; i < axes.length; i++) {
            var axis = axes[i],
                xx;
            xx = axis.x * cos - axis.y * sin;
            axis.y = axis.x * sin + axis.y * cos;
            axis.x = xx;
        }
    };

})();

},{"../core/Common":14,"../geometry/Vector":28}],26:[function(_dereq_,module,exports){
/**
* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).
*
* @class Bounds
*/

var Bounds = {};

module.exports = Bounds;

(function() {

    /**
     * Creates a new axis-aligned bounding box (AABB) for the given vertices.
     * @method create
     * @param {vertices} vertices
     * @return {bounds} A new bounds object
     */
    Bounds.create = function(vertices) {
        var bounds = { 
            min: { x: 0, y: 0 }, 
            max: { x: 0, y: 0 }
        };

        if (vertices)
            Bounds.update(bounds, vertices);
        
        return bounds;
    };

    /**
     * Updates bounds using the given vertices and extends the bounds given a velocity.
     * @method update
     * @param {bounds} bounds
     * @param {vertices} vertices
     * @param {vector} velocity
     */
    Bounds.update = function(bounds, vertices, velocity) {
        bounds.min.x = Infinity;
        bounds.max.x = -Infinity;
        bounds.min.y = Infinity;
        bounds.max.y = -Infinity;

        for (var i = 0; i < vertices.length; i++) {
            var vertex = vertices[i];
            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;
            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;
            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;
            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;
        }
        
        if (velocity) {
            if (velocity.x > 0) {
                bounds.max.x += velocity.x;
            } else {
                bounds.min.x += velocity.x;
            }
            
            if (velocity.y > 0) {
                bounds.max.y += velocity.y;
            } else {
                bounds.min.y += velocity.y;
            }
        }
    };

    /**
     * Returns true if the bounds contains the given point.
     * @method contains
     * @param {bounds} bounds
     * @param {vector} point
     * @return {boolean} True if the bounds contain the point, otherwise false
     */
    Bounds.contains = function(bounds, point) {
        return point.x >= bounds.min.x && point.x <= bounds.max.x 
               && point.y >= bounds.min.y && point.y <= bounds.max.y;
    };

    /**
     * Returns true if the two bounds intersect.
     * @method overlaps
     * @param {bounds} boundsA
     * @param {bounds} boundsB
     * @return {boolean} True if the bounds overlap, otherwise false
     */
    Bounds.overlaps = function(boundsA, boundsB) {
        return (boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x
                && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y);
    };

    /**
     * Translates the bounds by the given vector.
     * @method translate
     * @param {bounds} bounds
     * @param {vector} vector
     */
    Bounds.translate = function(bounds, vector) {
        bounds.min.x += vector.x;
        bounds.max.x += vector.x;
        bounds.min.y += vector.y;
        bounds.max.y += vector.y;
    };

    /**
     * Shifts the bounds to the given position.
     * @method shift
     * @param {bounds} bounds
     * @param {vector} position
     */
    Bounds.shift = function(bounds, position) {
        var deltaX = bounds.max.x - bounds.min.x,
            deltaY = bounds.max.y - bounds.min.y;
            
        bounds.min.x = position.x;
        bounds.max.x = position.x + deltaX;
        bounds.min.y = position.y;
        bounds.max.y = position.y + deltaY;
    };
    
})();

},{}],27:[function(_dereq_,module,exports){
/**
* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.
*
* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Svg
*/

var Svg = {};

module.exports = Svg;

var Bounds = _dereq_('../geometry/Bounds');
var Common = _dereq_('../core/Common');

(function() {

    /**
     * Converts an SVG path into an array of vector points.
     * If the input path forms a concave shape, you must decompose the result into convex parts before use.
     * See `Bodies.fromVertices` which provides support for this.
     * Note that this function is not guaranteed to support complex paths (such as those with holes).
     * You must load the `pathseg.js` polyfill on newer browsers.
     * @method pathToVertices
     * @param {SVGPathElement} path
     * @param {Number} [sampleLength=15]
     * @return {Vector[]} points
     */
    Svg.pathToVertices = function(path, sampleLength) {
        if (typeof window !== 'undefined' && !('SVGPathSeg' in window)) {
            Common.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.');
        }

        // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js
        var i, il, total, point, segment, segments, 
            segmentsQueue, lastSegment, 
            lastPoint, segmentIndex, points = [],
            lx, ly, length = 0, x = 0, y = 0;

        sampleLength = sampleLength || 15;

        var addPoint = function(px, py, pathSegType) {
            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)
            var isRelative = pathSegType % 2 === 1 && pathSegType > 1;

            // when the last point doesn't equal the current point add the current point
            if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {
                if (lastPoint && isRelative) {
                    lx = lastPoint.x;
                    ly = lastPoint.y;
                } else {
                    lx = 0;
                    ly = 0;
                }

                var point = {
                    x: lx + px,
                    y: ly + py
                };

                // set last point
                if (isRelative || !lastPoint) {
                    lastPoint = point;
                }

                points.push(point);

                x = lx + px;
                y = ly + py;
            }
        };

        var addSegmentPoint = function(segment) {
            var segType = segment.pathSegTypeAsLetter.toUpperCase();

            // skip path ends
            if (segType === 'Z') 
                return;

            // map segment to x and y
            switch (segType) {

            case 'M':
            case 'L':
            case 'T':
            case 'C':
            case 'S':
            case 'Q':
                x = segment.x;
                y = segment.y;
                break;
            case 'H':
                x = segment.x;
                break;
            case 'V':
                y = segment.y;
                break;
            }

            addPoint(x, y, segment.pathSegType);
        };

        // ensure path is absolute
        Svg._svgPathToAbsolute(path);

        // get total length
        total = path.getTotalLength();

        // queue segments
        segments = [];
        for (i = 0; i < path.pathSegList.numberOfItems; i += 1)
            segments.push(path.pathSegList.getItem(i));

        segmentsQueue = segments.concat();

        // sample through path
        while (length < total) {
            // get segment at position
            segmentIndex = path.getPathSegAtLength(length);
            segment = segments[segmentIndex];

            // new segment
            if (segment != lastSegment) {
                while (segmentsQueue.length && segmentsQueue[0] != segment)
                    addSegmentPoint(segmentsQueue.shift());

                lastSegment = segment;
            }

            // add points in between when curving
            // TODO: adaptive sampling
            switch (segment.pathSegTypeAsLetter.toUpperCase()) {

            case 'C':
            case 'T':
            case 'S':
            case 'Q':
            case 'A':
                point = path.getPointAtLength(length);
                addPoint(point.x, point.y, 0);
                break;

            }

            // increment by sample value
            length += sampleLength;
        }

        // add remaining segments not passed by sampling
        for (i = 0, il = segmentsQueue.length; i < il; ++i)
            addSegmentPoint(segmentsQueue[i]);

        return points;
    };

    Svg._svgPathToAbsolute = function(path) {
        // http://phrogz.net/convert-svg-path-to-all-absolute-commands
        // Copyright (c) Gavin Kistner
        // http://phrogz.net/js/_ReuseLicense.txt
        // Modifications: tidy formatting and naming
        var x0, y0, x1, y1, x2, y2, segs = path.pathSegList,
            x = 0, y = 0, len = segs.numberOfItems;

        for (var i = 0; i < len; ++i) {
            var seg = segs.getItem(i),
                segType = seg.pathSegTypeAsLetter;

            if (/[MLHVCSQTA]/.test(segType)) {
                if ('x' in seg) x = seg.x;
                if ('y' in seg) y = seg.y;
            } else {
                if ('x1' in seg) x1 = x + seg.x1;
                if ('x2' in seg) x2 = x + seg.x2;
                if ('y1' in seg) y1 = y + seg.y1;
                if ('y2' in seg) y2 = y + seg.y2;
                if ('x' in seg) x += seg.x;
                if ('y' in seg) y += seg.y;

                switch (segType) {

                case 'm':
                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);
                    break;
                case 'l':
                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);
                    break;
                case 'h':
                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);
                    break;
                case 'v':
                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);
                    break;
                case 'c':
                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);
                    break;
                case 's':
                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);
                    break;
                case 'q':
                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);
                    break;
                case 't':
                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);
                    break;
                case 'a':
                    segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);
                    break;
                case 'z':
                case 'Z':
                    x = x0;
                    y = y0;
                    break;

                }
            }

            if (segType == 'M' || segType == 'm') {
                x0 = x;
                y0 = y;
            }
        }
    };

})();
},{"../core/Common":14,"../geometry/Bounds":26}],28:[function(_dereq_,module,exports){
/**
* The `Matter.Vector` module contains methods for creating and manipulating vectors.
* Vectors are the basis of all the geometry related operations in the engine.
* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vector
*/

// TODO: consider params for reusing vector objects

var Vector = {};

module.exports = Vector;

(function() {

    /**
     * Creates a new vector.
     * @method create
     * @param {number} x
     * @param {number} y
     * @return {vector} A new vector
     */
    Vector.create = function(x, y) {
        return { x: x || 0, y: y || 0 };
    };

    /**
     * Returns a new vector with `x` and `y` copied from the given `vector`.
     * @method clone
     * @param {vector} vector
     * @return {vector} A new cloned vector
     */
    Vector.clone = function(vector) {
        return { x: vector.x, y: vector.y };
    };

    /**
     * Returns the magnitude (length) of a vector.
     * @method magnitude
     * @param {vector} vector
     * @return {number} The magnitude of the vector
     */
    Vector.magnitude = function(vector) {
        return Math.sqrt((vector.x * vector.x) + (vector.y * vector.y));
    };

    /**
     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).
     * @method magnitudeSquared
     * @param {vector} vector
     * @return {number} The squared magnitude of the vector
     */
    Vector.magnitudeSquared = function(vector) {
        return (vector.x * vector.x) + (vector.y * vector.y);
    };

    /**
     * Rotates the vector about (0, 0) by specified angle.
     * @method rotate
     * @param {vector} vector
     * @param {number} angle
     * @param {vector} [output]
     * @return {vector} The vector rotated about (0, 0)
     */
    Vector.rotate = function(vector, angle, output) {
        var cos = Math.cos(angle), sin = Math.sin(angle);
        if (!output) output = {};
        var x = vector.x * cos - vector.y * sin;
        output.y = vector.x * sin + vector.y * cos;
        output.x = x;
        return output;
    };

    /**
     * Rotates the vector about a specified point by specified angle.
     * @method rotateAbout
     * @param {vector} vector
     * @param {number} angle
     * @param {vector} point
     * @param {vector} [output]
     * @return {vector} A new vector rotated about the point
     */
    Vector.rotateAbout = function(vector, angle, point, output) {
        var cos = Math.cos(angle), sin = Math.sin(angle);
        if (!output) output = {};
        var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);
        output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);
        output.x = x;
        return output;
    };

    /**
     * Normalises a vector (such that its magnitude is `1`).
     * @method normalise
     * @param {vector} vector
     * @return {vector} A new vector normalised
     */
    Vector.normalise = function(vector) {
        var magnitude = Vector.magnitude(vector);
        if (magnitude === 0)
            return { x: 0, y: 0 };
        return { x: vector.x / magnitude, y: vector.y / magnitude };
    };

    /**
     * Returns the dot-product of two vectors.
     * @method dot
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The dot product of the two vectors
     */
    Vector.dot = function(vectorA, vectorB) {
        return (vectorA.x * vectorB.x) + (vectorA.y * vectorB.y);
    };

    /**
     * Returns the cross-product of two vectors.
     * @method cross
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The cross product of the two vectors
     */
    Vector.cross = function(vectorA, vectorB) {
        return (vectorA.x * vectorB.y) - (vectorA.y * vectorB.x);
    };

    /**
     * Returns the cross-product of three vectors.
     * @method cross3
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} vectorC
     * @return {number} The cross product of the three vectors
     */
    Vector.cross3 = function(vectorA, vectorB, vectorC) {
        return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);
    };

    /**
     * Adds the two vectors.
     * @method add
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB added
     */
    Vector.add = function(vectorA, vectorB, output) {
        if (!output) output = {};
        output.x = vectorA.x + vectorB.x;
        output.y = vectorA.y + vectorB.y;
        return output;
    };

    /**
     * Subtracts the two vectors.
     * @method sub
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @param {vector} [output]
     * @return {vector} A new vector of vectorA and vectorB subtracted
     */
    Vector.sub = function(vectorA, vectorB, output) {
        if (!output) output = {};
        output.x = vectorA.x - vectorB.x;
        output.y = vectorA.y - vectorB.y;
        return output;
    };

    /**
     * Multiplies a vector and a scalar.
     * @method mult
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector multiplied by scalar
     */
    Vector.mult = function(vector, scalar) {
        return { x: vector.x * scalar, y: vector.y * scalar };
    };

    /**
     * Divides a vector and a scalar.
     * @method div
     * @param {vector} vector
     * @param {number} scalar
     * @return {vector} A new vector divided by scalar
     */
    Vector.div = function(vector, scalar) {
        return { x: vector.x / scalar, y: vector.y / scalar };
    };

    /**
     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.
     * @method perp
     * @param {vector} vector
     * @param {bool} [negate=false]
     * @return {vector} The perpendicular vector
     */
    Vector.perp = function(vector, negate) {
        negate = negate === true ? -1 : 1;
        return { x: negate * -vector.y, y: negate * vector.x };
    };

    /**
     * Negates both components of a vector such that it points in the opposite direction.
     * @method neg
     * @param {vector} vector
     * @return {vector} The negated vector
     */
    Vector.neg = function(vector) {
        return { x: -vector.x, y: -vector.y };
    };

    /**
     * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians.
     * @method angle
     * @param {vector} vectorA
     * @param {vector} vectorB
     * @return {number} The angle in radians
     */
    Vector.angle = function(vectorA, vectorB) {
        return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);
    };

    /**
     * Temporary vector pool (not thread-safe).
     * @property _temp
     * @type {vector[]}
     * @private
     */
    Vector._temp = [
        Vector.create(), Vector.create(), 
        Vector.create(), Vector.create(), 
        Vector.create(), Vector.create()
    ];

})();
},{}],29:[function(_dereq_,module,exports){
/**
* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.
* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.
* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).
*
* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).
*
* @class Vertices
*/

var Vertices = {};

module.exports = Vertices;

var Vector = _dereq_('../geometry/Vector');
var Common = _dereq_('../core/Common');

(function() {

    /**
     * Creates a new set of `Matter.Body` compatible vertices.
     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:
     *
     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]
     *
     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,
     * but with some additional references required for efficient collision detection routines.
     *
     * Vertices must be specified in clockwise order.
     *
     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.
     *
     * @method create
     * @param {vector[]} points
     * @param {body} body
     */
    Vertices.create = function(points, body) {
        var vertices = [];

        for (var i = 0; i < points.length; i++) {
            var point = points[i],
                vertex = {
                    x: point.x,
                    y: point.y,
                    index: i,
                    body: body,
                    isInternal: false
                };

            vertices.push(vertex);
        }

        return vertices;
    };

    /**
     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), 
     * into a `Matter.Vertices` object for the given `Matter.Body`.
     * For parsing SVG paths, see `Svg.pathToVertices`.
     * @method fromPath
     * @param {string} path
     * @param {body} body
     * @return {vertices} vertices
     */
    Vertices.fromPath = function(path, body) {
        var pathPattern = /L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/ig,
            points = [];

        path.replace(pathPattern, function(match, x, y) {
            points.push({ x: parseFloat(x), y: parseFloat(y) });
        });

        return Vertices.create(points, body);
    };

    /**
     * Returns the centre (centroid) of the set of vertices.
     * @method centre
     * @param {vertices} vertices
     * @return {vector} The centre point
     */
    Vertices.centre = function(vertices) {
        var area = Vertices.area(vertices, true),
            centre = { x: 0, y: 0 },
            cross,
            temp,
            j;

        for (var i = 0; i < vertices.length; i++) {
            j = (i + 1) % vertices.length;
            cross = Vector.cross(vertices[i], vertices[j]);
            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);
            centre = Vector.add(centre, temp);
        }

        return Vector.div(centre, 6 * area);
    };

    /**
     * Returns the average (mean) of the set of vertices.
     * @method mean
     * @param {vertices} vertices
     * @return {vector} The average point
     */
    Vertices.mean = function(vertices) {
        var average = { x: 0, y: 0 };

        for (var i = 0; i < vertices.length; i++) {
            average.x += vertices[i].x;
            average.y += vertices[i].y;
        }

        return Vector.div(average, vertices.length);
    };

    /**
     * Returns the area of the set of vertices.
     * @method area
     * @param {vertices} vertices
     * @param {bool} signed
     * @return {number} The area
     */
    Vertices.area = function(vertices, signed) {
        var area = 0,
            j = vertices.length - 1;

        for (var i = 0; i < vertices.length; i++) {
            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);
            j = i;
        }

        if (signed)
            return area / 2;

        return Math.abs(area) / 2;
    };

    /**
     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.
     * @method inertia
     * @param {vertices} vertices
     * @param {number} mass
     * @return {number} The polygon's moment of inertia
     */
    Vertices.inertia = function(vertices, mass) {
        var numerator = 0,
            denominator = 0,
            v = vertices,
            cross,
            j;

        // find the polygon's moment of inertia, using second moment of area
        // from equations at http://www.physicsforums.com/showthread.php?t=25293
        for (var n = 0; n < v.length; n++) {
            j = (n + 1) % v.length;
            cross = Math.abs(Vector.cross(v[j], v[n]));
            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));
            denominator += cross;
        }

        return (mass / 6) * (numerator / denominator);
    };

    /**
     * Translates the set of vertices in-place.
     * @method translate
     * @param {vertices} vertices
     * @param {vector} vector
     * @param {number} scalar
     */
    Vertices.translate = function(vertices, vector, scalar) {
        var i;
        if (scalar) {
            for (i = 0; i < vertices.length; i++) {
                vertices[i].x += vector.x * scalar;
                vertices[i].y += vector.y * scalar;
            }
        } else {
            for (i = 0; i < vertices.length; i++) {
                vertices[i].x += vector.x;
                vertices[i].y += vector.y;
            }
        }

        return vertices;
    };

    /**
     * Rotates the set of vertices in-place.
     * @method rotate
     * @param {vertices} vertices
     * @param {number} angle
     * @param {vector} point
     */
    Vertices.rotate = function(vertices, angle, point) {
        if (angle === 0)
            return;

        var cos = Math.cos(angle),
            sin = Math.sin(angle);

        for (var i = 0; i < vertices.length; i++) {
            var vertice = vertices[i],
                dx = vertice.x - point.x,
                dy = vertice.y - point.y;
                
            vertice.x = point.x + (dx * cos - dy * sin);
            vertice.y = point.y + (dx * sin + dy * cos);
        }

        return vertices;
    };

    /**
     * Returns `true` if the `point` is inside the set of `vertices`.
     * @method contains
     * @param {vertices} vertices
     * @param {vector} point
     * @return {boolean} True if the vertices contains point, otherwise false
     */
    Vertices.contains = function(vertices, point) {
        for (var i = 0; i < vertices.length; i++) {
            var vertice = vertices[i],
                nextVertice = vertices[(i + 1) % vertices.length];
            if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {
                return false;
            }
        }

        return true;
    };

    /**
     * Scales the vertices from a point (default is centre) in-place.
     * @method scale
     * @param {vertices} vertices
     * @param {number} scaleX
     * @param {number} scaleY
     * @param {vector} point
     */
    Vertices.scale = function(vertices, scaleX, scaleY, point) {
        if (scaleX === 1 && scaleY === 1)
            return vertices;

        point = point || Vertices.centre(vertices);

        var vertex,
            delta;

        for (var i = 0; i < vertices.length; i++) {
            vertex = vertices[i];
            delta = Vector.sub(vertex, point);
            vertices[i].x = point.x + delta.x * scaleX;
            vertices[i].y = point.y + delta.y * scaleY;
        }

        return vertices;
    };

    /**
     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.
     * The radius parameter is a single number or an array to specify the radius for each vertex.
     * @method chamfer
     * @param {vertices} vertices
     * @param {number[]} radius
     * @param {number} quality
     * @param {number} qualityMin
     * @param {number} qualityMax
     */
    Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {
        if (typeof radius === 'number') {
            radius = [radius];
        } else {
            radius = radius || [8];
        }

        // quality defaults to -1, which is auto
        quality = (typeof quality !== 'undefined') ? quality : -1;
        qualityMin = qualityMin || 2;
        qualityMax = qualityMax || 14;

        var newVertices = [];

        for (var i = 0; i < vertices.length; i++) {
            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],
                vertex = vertices[i],
                nextVertex = vertices[(i + 1) % vertices.length],
                currentRadius = radius[i < radius.length ? i : radius.length - 1];

            if (currentRadius === 0) {
                newVertices.push(vertex);
                continue;
            }

            var prevNormal = Vector.normalise({ 
                x: vertex.y - prevVertex.y, 
                y: prevVertex.x - vertex.x
            });

            var nextNormal = Vector.normalise({ 
                x: nextVertex.y - vertex.y, 
                y: vertex.x - nextVertex.x
            });

            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),
                radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),
                midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),
                scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));

            var precision = quality;

            if (quality === -1) {
                // automatically decide precision
                precision = Math.pow(currentRadius, 0.32) * 1.75;
            }

            precision = Common.clamp(precision, qualityMin, qualityMax);

            // use an even value for precision, more likely to reduce axes by using symmetry
            if (precision % 2 === 1)
                precision += 1;

            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),
                theta = alpha / precision;

            for (var j = 0; j < precision; j++) {
                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));
            }
        }

        return newVertices;
    };

    /**
     * Sorts the input vertices into clockwise order in place.
     * @method clockwiseSort
     * @param {vertices} vertices
     * @return {vertices} vertices
     */
    Vertices.clockwiseSort = function(vertices) {
        var centre = Vertices.mean(vertices);

        vertices.sort(function(vertexA, vertexB) {
            return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);
        });

        return vertices;
    };

    /**
     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).
     * @method isConvex
     * @param {vertices} vertices
     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).
     */
    Vertices.isConvex = function(vertices) {
        // http://paulbourke.net/geometry/polygonmesh/
        // Copyright (c) Paul Bourke (use permitted)

        var flag = 0,
            n = vertices.length,
            i,
            j,
            k,
            z;

        if (n < 3)
            return null;

        for (i = 0; i < n; i++) {
            j = (i + 1) % n;
            k = (i + 2) % n;
            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);
            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);

            if (z < 0) {
                flag |= 1;
            } else if (z > 0) {
                flag |= 2;
            }

            if (flag === 3) {
                return false;
            }
        }

        if (flag !== 0){
            return true;
        } else {
            return null;
        }
    };

    /**
     * Returns the convex hull of the input vertices as a new array of points.
     * @method hull
     * @param {vertices} vertices
     * @return [vertex] vertices
     */
    Vertices.hull = function(vertices) {
        // http://geomalgorithms.com/a10-_hull-1.html

        var upper = [],
            lower = [], 
            vertex,
            i;

        // sort vertices on x-axis (y-axis for ties)
        vertices = vertices.slice(0);
        vertices.sort(function(vertexA, vertexB) {
            var dx = vertexA.x - vertexB.x;
            return dx !== 0 ? dx : vertexA.y - vertexB.y;
        });

        // build lower hull
        for (i = 0; i < vertices.length; i += 1) {
            vertex = vertices[i];

            while (lower.length >= 2 
                   && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {
                lower.pop();
            }

            lower.push(vertex);
        }

        // build upper hull
        for (i = vertices.length - 1; i >= 0; i -= 1) {
            vertex = vertices[i];

            while (upper.length >= 2 
                   && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {
                upper.pop();
            }

            upper.push(vertex);
        }

        // concatenation of the lower and upper hulls gives the convex hull
        // omit last points because they are repeated at the beginning of the other list
        upper.pop();
        lower.pop();

        return upper.concat(lower);
    };

})();

},{"../core/Common":14,"../geometry/Vector":28}],30:[function(_dereq_,module,exports){
var Matter = module.exports = _dereq_('../core/Matter');

Matter.Body = _dereq_('../body/Body');
Matter.Composite = _dereq_('../body/Composite');
Matter.World = _dereq_('../body/World');

Matter.Contact = _dereq_('../collision/Contact');
Matter.Detector = _dereq_('../collision/Detector');
Matter.Grid = _dereq_('../collision/Grid');
Matter.Pairs = _dereq_('../collision/Pairs');
Matter.Pair = _dereq_('../collision/Pair');
Matter.Query = _dereq_('../collision/Query');
Matter.Resolver = _dereq_('../collision/Resolver');
Matter.SAT = _dereq_('../collision/SAT');

Matter.Constraint = _dereq_('../constraint/Constraint');
Matter.MouseConstraint = _dereq_('../constraint/MouseConstraint');

Matter.Common = _dereq_('../core/Common');
Matter.Engine = _dereq_('../core/Engine');
Matter.Events = _dereq_('../core/Events');
Matter.Mouse = _dereq_('../core/Mouse');
Matter.Runner = _dereq_('../core/Runner');
Matter.Sleeping = _dereq_('../core/Sleeping');
Matter.Plugin = _dereq_('../core/Plugin');


Matter.Bodies = _dereq_('../factory/Bodies');
Matter.Composites = _dereq_('../factory/Composites');

Matter.Axes = _dereq_('../geometry/Axes');
Matter.Bounds = _dereq_('../geometry/Bounds');
Matter.Svg = _dereq_('../geometry/Svg');
Matter.Vector = _dereq_('../geometry/Vector');
Matter.Vertices = _dereq_('../geometry/Vertices');

Matter.Render = _dereq_('../render/Render');
Matter.RenderPixi = _dereq_('../render/RenderPixi');

// aliases

Matter.World.add = Matter.Composite.add;
Matter.World.remove = Matter.Composite.remove;
Matter.World.addComposite = Matter.Composite.addComposite;
Matter.World.addBody = Matter.Composite.addBody;
Matter.World.addConstraint = Matter.Composite.addConstraint;
Matter.World.clear = Matter.Composite.clear;
Matter.Engine.run = Matter.Runner.run;

},{"../body/Body":1,"../body/Composite":2,"../body/World":3,"../collision/Contact":4,"../collision/Detector":5,"../collision/Grid":6,"../collision/Pair":7,"../collision/Pairs":8,"../collision/Query":9,"../collision/Resolver":10,"../collision/SAT":11,"../constraint/Constraint":12,"../constraint/MouseConstraint":13,"../core/Common":14,"../core/Engine":15,"../core/Events":16,"../core/Matter":17,"../core/Metrics":18,"../core/Mouse":19,"../core/Plugin":20,"../core/Runner":21,"../core/Sleeping":22,"../factory/Bodies":23,"../factory/Composites":24,"../geometry/Axes":25,"../geometry/Bounds":26,"../geometry/Svg":27,"../geometry/Vector":28,"../geometry/Vertices":29,"../render/Render":31,"../render/RenderPixi":32}],31:[function(_dereq_,module,exports){
/**
* The `Matter.Render` module is a simple HTML5 canvas based renderer for visualising instances of `Matter.Engine`.
* It is intended for development and debugging purposes, but may also be suitable for simple games.
* It includes a number of drawing options including wireframe, vector with support for sprites and viewports.
*
* @class Render
*/

var Render = {};

module.exports = Render;

var Common = _dereq_('../core/Common');
var Composite = _dereq_('../body/Composite');
var Bounds = _dereq_('../geometry/Bounds');
var Events = _dereq_('../core/Events');
var Grid = _dereq_('../collision/Grid');
var Vector = _dereq_('../geometry/Vector');
var Mouse = _dereq_('../core/Mouse');

(function() {

    var _requestAnimationFrame,
        _cancelAnimationFrame;

    if (typeof window !== 'undefined') {
        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame
                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame
                                      || function(callback){ window.setTimeout(function() { callback(Common.now()); }, 1000 / 60); };

        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame
                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
    }

    /**
     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.
     * All properties have default values, and many are pre-calculated automatically based on other properties.
     * See the properties section below for detailed information on what you can pass via the `options` object.
     * @method create
     * @param {object} [options]
     * @return {render} A new renderer
     */
    Render.create = function(options) {
        var defaults = {
            controller: Render,
            engine: null,
            element: null,
            canvas: null,
            mouse: null,
            frameRequestId: null,
            options: {
                width: 800,
                height: 600,
                pixelRatio: 1,
                background: '#18181d',
                wireframeBackground: '#0f0f13',
                hasBounds: !!options.bounds,
                enabled: true,
                wireframes: true,
                showSleeping: true,
                showDebug: false,
                showBroadphase: false,
                showBounds: false,
                showVelocity: false,
                showCollisions: false,
                showSeparations: false,
                showAxes: false,
                showPositions: false,
                showAngleIndicator: false,
                showIds: false,
                showShadows: false,
                showVertexNumbers: false,
                showConvexHulls: false,
                showInternalEdges: false,
                showMousePosition: false
            }
        };

        var render = Common.extend(defaults, options);

        if (render.canvas) {
            render.canvas.width = render.options.width || render.canvas.width;
            render.canvas.height = render.options.height || render.canvas.height;
        }

        render.mouse = options.mouse;
        render.engine = options.engine;
        render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);
        render.context = render.canvas.getContext('2d');
        render.textures = {};

        render.bounds = render.bounds || {
            min: {
                x: 0,
                y: 0
            },
            max: {
                x: render.canvas.width,
                y: render.canvas.height
            }
        };

        if (render.options.pixelRatio !== 1) {
            Render.setPixelRatio(render, render.options.pixelRatio);
        }

        if (Common.isElement(render.element)) {
            render.element.appendChild(render.canvas);
        } else if (!render.canvas.parentNode) {
            Common.log('Render.create: options.element was undefined, render.canvas was created but not appended', 'warn');
        }

        return render;
    };

    /**
     * Continuously updates the render canvas on the `requestAnimationFrame` event.
     * @method run
     * @param {render} render
     */
    Render.run = function(render) {
        (function loop(time){
            render.frameRequestId = _requestAnimationFrame(loop);
            Render.world(render);
        })();
    };

    /**
     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.
     * @method stop
     * @param {render} render
     */
    Render.stop = function(render) {
        _cancelAnimationFrame(render.frameRequestId);
    };

    /**
     * Sets the pixel ratio of the renderer and updates the canvas.
     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.
     * @method setPixelRatio
     * @param {render} render
     * @param {number} pixelRatio
     */
    Render.setPixelRatio = function(render, pixelRatio) {
        var options = render.options,
            canvas = render.canvas;

        if (pixelRatio === 'auto') {
            pixelRatio = _getPixelRatio(canvas);
        }

        options.pixelRatio = pixelRatio;
        canvas.setAttribute('data-pixel-ratio', pixelRatio);
        canvas.width = options.width * pixelRatio;
        canvas.height = options.height * pixelRatio;
        canvas.style.width = options.width + 'px';
        canvas.style.height = options.height + 'px';
        render.context.scale(pixelRatio, pixelRatio);
    };

    /**
     * Positions and sizes the viewport around the given object bounds.
     * Objects must have at least one of the following properties:
     * - `object.bounds`
     * - `object.position`
     * - `object.min` and `object.max`
     * - `object.x` and `object.y`
     * @method lookAt
     * @param {render} render
     * @param {object[]} objects
     * @param {vector} [padding]
     * @param {bool} [center=true]
     */
    Render.lookAt = function(render, objects, padding, center) {
        center = typeof center !== 'undefined' ? center : true;
        objects = Common.isArray(objects) ? objects : [objects];
        padding = padding || {
            x: 0,
            y: 0
        };

        // find bounds of all objects
        var bounds = {
            min: { x: Infinity, y: Infinity },
            max: { x: -Infinity, y: -Infinity }
        };

        for (var i = 0; i < objects.length; i += 1) {
            var object = objects[i],
                min = object.bounds ? object.bounds.min : (object.min || object.position || object),
                max = object.bounds ? object.bounds.max : (object.max || object.position || object);

            if (min && max) {
                if (min.x < bounds.min.x)
                    bounds.min.x = min.x;

                if (max.x > bounds.max.x)
                    bounds.max.x = max.x;

                if (min.y < bounds.min.y)
                    bounds.min.y = min.y;

                if (max.y > bounds.max.y)
                    bounds.max.y = max.y;
            }
        }

        // find ratios
        var width = (bounds.max.x - bounds.min.x) + 2 * padding.x,
            height = (bounds.max.y - bounds.min.y) + 2 * padding.y,
            viewHeight = render.canvas.height,
            viewWidth = render.canvas.width,
            outerRatio = viewWidth / viewHeight,
            innerRatio = width / height,
            scaleX = 1,
            scaleY = 1;

        // find scale factor
        if (innerRatio > outerRatio) {
            scaleY = innerRatio / outerRatio;
        } else {
            scaleX = outerRatio / innerRatio;
        }

        // enable bounds
        render.options.hasBounds = true;

        // position and size
        render.bounds.min.x = bounds.min.x;
        render.bounds.max.x = bounds.min.x + width * scaleX;
        render.bounds.min.y = bounds.min.y;
        render.bounds.max.y = bounds.min.y + height * scaleY;

        // center
        if (center) {
            render.bounds.min.x += width * 0.5 - (width * scaleX) * 0.5;
            render.bounds.max.x += width * 0.5 - (width * scaleX) * 0.5;
            render.bounds.min.y += height * 0.5 - (height * scaleY) * 0.5;
            render.bounds.max.y += height * 0.5 - (height * scaleY) * 0.5;
        }

        // padding
        render.bounds.min.x -= padding.x;
        render.bounds.max.x -= padding.x;
        render.bounds.min.y -= padding.y;
        render.bounds.max.y -= padding.y;

        // update mouse
        if (render.mouse) {
            Mouse.setScale(render.mouse, {
                x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,
                y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height
            });

            Mouse.setOffset(render.mouse, render.bounds.min);
        }
    };

    /**
     * Applies viewport transforms based on `render.bounds` to a render context.
     * @method startViewTransform
     * @param {render} render
     */
    Render.startViewTransform = function(render) {
        var boundsWidth = render.bounds.max.x - render.bounds.min.x,
            boundsHeight = render.bounds.max.y - render.bounds.min.y,
            boundsScaleX = boundsWidth / render.options.width,
            boundsScaleY = boundsHeight / render.options.height;

        render.context.scale(1 / boundsScaleX, 1 / boundsScaleY);
        render.context.translate(-render.bounds.min.x, -render.bounds.min.y);
    };

    /**
     * Resets all transforms on the render context.
     * @method endViewTransform
     * @param {render} render
     */
    Render.endViewTransform = function(render) {
        render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);
    };

    /**
     * Renders the given `engine`'s `Matter.World` object.
     * This is the entry point for all rendering and should be called every time the scene changes.
     * @method world
     * @param {render} render
     */
    Render.world = function(render) {
        var engine = render.engine,
            world = engine.world,
            canvas = render.canvas,
            context = render.context,
            options = render.options,
            allBodies = Composite.allBodies(world),
            allConstraints = Composite.allConstraints(world),
            background = options.wireframes ? options.wireframeBackground : options.background,
            bodies = [],
            constraints = [],
            i;

        var event = {
            timestamp: engine.timing.timestamp
        };

        Events.trigger(render, 'beforeRender', event);

        // apply background if it has changed
        if (render.currentBackground !== background)
            _applyBackground(render, background);

        // clear the canvas with a transparent fill, to allow the canvas background to show
        context.globalCompositeOperation = 'source-in';
        context.fillStyle = "transparent";
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.globalCompositeOperation = 'source-over';

        // handle bounds
        if (options.hasBounds) {
            // filter out bodies that are not in view
            for (i = 0; i < allBodies.length; i++) {
                var body = allBodies[i];
                if (Bounds.overlaps(body.bounds, render.bounds))
                    bodies.push(body);
            }

            // filter out constraints that are not in view
            for (i = 0; i < allConstraints.length; i++) {
                var constraint = allConstraints[i],
                    bodyA = constraint.bodyA,
                    bodyB = constraint.bodyB,
                    pointAWorld = constraint.pointA,
                    pointBWorld = constraint.pointB;

                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);
                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);

                if (!pointAWorld || !pointBWorld)
                    continue;

                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))
                    constraints.push(constraint);
            }

            // transform the view
            Render.startViewTransform(render);

            // update mouse
            if (render.mouse) {
                Mouse.setScale(render.mouse, {
                    x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,
                    y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height
                });

                Mouse.setOffset(render.mouse, render.bounds.min);
            }
        } else {
            constraints = allConstraints;
            bodies = allBodies;
        }

        if (!options.wireframes || (engine.enableSleeping && options.showSleeping)) {
            // fully featured rendering of bodies
            Render.bodies(render, bodies, context);
        } else {
            if (options.showConvexHulls)
                Render.bodyConvexHulls(render, bodies, context);

            // optimised method for wireframes only
            Render.bodyWireframes(render, bodies, context);
        }

        if (options.showBounds)
            Render.bodyBounds(render, bodies, context);

        if (options.showAxes || options.showAngleIndicator)
            Render.bodyAxes(render, bodies, context);

        if (options.showPositions)
            Render.bodyPositions(render, bodies, context);

        if (options.showVelocity)
            Render.bodyVelocity(render, bodies, context);

        if (options.showIds)
            Render.bodyIds(render, bodies, context);

        if (options.showSeparations)
            Render.separations(render, engine.pairs.list, context);

        if (options.showCollisions)
            Render.collisions(render, engine.pairs.list, context);

        if (options.showVertexNumbers)
            Render.vertexNumbers(render, bodies, context);

        if (options.showMousePosition)
            Render.mousePosition(render, render.mouse, context);

        Render.constraints(constraints, context);

        if (options.showBroadphase && engine.broadphase.controller === Grid)
            Render.grid(render, engine.broadphase, context);

        if (options.showDebug)
            Render.debug(render, context);

        if (options.hasBounds) {
            // revert view transforms
            Render.endViewTransform(render);
        }

        Events.trigger(render, 'afterRender', event);
    };

    /**
     * Description
     * @private
     * @method debug
     * @param {render} render
     * @param {RenderingContext} context
     */
    Render.debug = function(render, context) {
        var c = context,
            engine = render.engine,
            world = engine.world,
            metrics = engine.metrics,
            options = render.options,
            bodies = Composite.allBodies(world),
            space = "    ";

        if (engine.timing.timestamp - (render.debugTimestamp || 0) >= 500) {
            var text = "";

            if (metrics.timing) {
                text += "fps: " + Math.round(metrics.timing.fps) + space;
            }


            render.debugString = text;
            render.debugTimestamp = engine.timing.timestamp;
        }

        if (render.debugString) {
            c.font = "12px Arial";

            if (options.wireframes) {
                c.fillStyle = 'rgba(255,255,255,0.5)';
            } else {
                c.fillStyle = 'rgba(0,0,0,0.5)';
            }

            var split = render.debugString.split('\n');

            for (var i = 0; i < split.length; i++) {
                c.fillText(split[i], 50, 50 + i * 18);
            }
        }
    };

    /**
     * Description
     * @private
     * @method constraints
     * @param {constraint[]} constraints
     * @param {RenderingContext} context
     */
    Render.constraints = function(constraints, context) {
        var c = context;

        for (var i = 0; i < constraints.length; i++) {
            var constraint = constraints[i];

            if (!constraint.render.visible || !constraint.pointA || !constraint.pointB)
                continue;

            var bodyA = constraint.bodyA,
                bodyB = constraint.bodyB,
                start,
                end;

            if (bodyA) {
                start = Vector.add(bodyA.position, constraint.pointA);
            } else {
                start = constraint.pointA;
            }

            if (constraint.render.type === 'pin') {
                c.beginPath();
                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);
                c.closePath();
            } else {
                if (bodyB) {
                    end = Vector.add(bodyB.position, constraint.pointB);
                } else {
                    end = constraint.pointB;
                }

                c.beginPath();
                c.moveTo(start.x, start.y);

                if (constraint.render.type === 'spring') {
                    var delta = Vector.sub(end, start),
                        normal = Vector.perp(Vector.normalise(delta)),
                        coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20)),
                        offset;

                    for (var j = 1; j < coils; j += 1) {
                        offset = j % 2 === 0 ? 1 : -1;

                        c.lineTo(
                            start.x + delta.x * (j / coils) + normal.x * offset * 4,
                            start.y + delta.y * (j / coils) + normal.y * offset * 4
                        );
                    }
                }

                c.lineTo(end.x, end.y);
            }

            if (constraint.render.lineWidth) {
                c.lineWidth = constraint.render.lineWidth;
                c.strokeStyle = constraint.render.strokeStyle;
                c.stroke();
            }

            if (constraint.render.anchors) {
                c.fillStyle = constraint.render.strokeStyle;
                c.beginPath();
                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);
                c.arc(end.x, end.y, 3, 0, 2 * Math.PI);
                c.closePath();
                c.fill();
            }
        }
    };

    /**
     * Description
     * @private
     * @method bodyShadows
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyShadows = function(render, bodies, context) {
        var c = context,
            engine = render.engine;

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (!body.render.visible)
                continue;

            if (body.circleRadius) {
                c.beginPath();
                c.arc(body.position.x, body.position.y, body.circleRadius, 0, 2 * Math.PI);
                c.closePath();
            } else {
                c.beginPath();
                c.moveTo(body.vertices[0].x, body.vertices[0].y);
                for (var j = 1; j < body.vertices.length; j++) {
                    c.lineTo(body.vertices[j].x, body.vertices[j].y);
                }
                c.closePath();
            }

            var distanceX = body.position.x - render.options.width * 0.5,
                distanceY = body.position.y - render.options.height * 0.2,
                distance = Math.abs(distanceX) + Math.abs(distanceY);

            c.shadowColor = 'rgba(0,0,0,0.15)';
            c.shadowOffsetX = 0.05 * distanceX;
            c.shadowOffsetY = 0.05 * distanceY;
            c.shadowBlur = 1 + 12 * Math.min(1, distance / 1000);

            c.fill();

            c.shadowColor = null;
            c.shadowOffsetX = null;
            c.shadowOffsetY = null;
            c.shadowBlur = null;
        }
    };

    /**
     * Description
     * @private
     * @method bodies
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodies = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options,
            showInternalEdges = options.showInternalEdges || !options.wireframes,
            body,
            part,
            i,
            k;

        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible)
                continue;

            // handle compound parts
            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
                part = body.parts[k];

                if (!part.render.visible)
                    continue;

                if (options.showSleeping && body.isSleeping) {
                    c.globalAlpha = 0.5 * part.render.opacity;
                } else if (part.render.opacity !== 1) {
                    c.globalAlpha = part.render.opacity;
                }

                if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {
                    // part sprite
                    var sprite = part.render.sprite,
                        texture = _getTexture(render, sprite.texture);

                    c.translate(part.position.x, part.position.y);
                    c.rotate(part.angle);

                    c.drawImage(
                        texture,
                        texture.width * -sprite.xOffset * sprite.xScale,
                        texture.height * -sprite.yOffset * sprite.yScale,
                        texture.width * sprite.xScale,
                        texture.height * sprite.yScale
                    );

                    // revert translation, hopefully faster than save / restore
                    c.rotate(-part.angle);
                    c.translate(-part.position.x, -part.position.y);
                } else {
                    // part polygon
                    if (part.circleRadius) {
                        c.beginPath();
                        c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);
                    } else {
                        c.beginPath();
                        c.moveTo(part.vertices[0].x, part.vertices[0].y);

                        for (var j = 1; j < part.vertices.length; j++) {
                            if (!part.vertices[j - 1].isInternal || showInternalEdges) {
                                c.lineTo(part.vertices[j].x, part.vertices[j].y);
                            } else {
                                c.moveTo(part.vertices[j].x, part.vertices[j].y);
                            }

                            if (part.vertices[j].isInternal && !showInternalEdges) {
                                c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);
                            }
                        }

                        c.lineTo(part.vertices[0].x, part.vertices[0].y);
                        c.closePath();
                    }

                    if (!options.wireframes) {
                        c.fillStyle = part.render.fillStyle;

                        if (part.render.lineWidth) {
                            c.lineWidth = part.render.lineWidth;
                            c.strokeStyle = part.render.strokeStyle;
                            c.stroke();
                        }

                        c.fill();
                    } else {
                        c.lineWidth = 1;
                        c.strokeStyle = '#bbb';
                        c.stroke();
                    }
                }

                c.globalAlpha = 1;
            }
        }
    };

    /**
     * Optimised method for drawing body wireframes in one pass
     * @private
     * @method bodyWireframes
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyWireframes = function(render, bodies, context) {
        var c = context,
            showInternalEdges = render.options.showInternalEdges,
            body,
            part,
            i,
            j,
            k;

        c.beginPath();

        // render all bodies
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible)
                continue;

            // handle compound parts
            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
                part = body.parts[k];

                c.moveTo(part.vertices[0].x, part.vertices[0].y);

                for (j = 1; j < part.vertices.length; j++) {
                    if (!part.vertices[j - 1].isInternal || showInternalEdges) {
                        c.lineTo(part.vertices[j].x, part.vertices[j].y);
                    } else {
                        c.moveTo(part.vertices[j].x, part.vertices[j].y);
                    }

                    if (part.vertices[j].isInternal && !showInternalEdges) {
                        c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);
                    }
                }

                c.lineTo(part.vertices[0].x, part.vertices[0].y);
            }
        }

        c.lineWidth = 1;
        c.strokeStyle = '#bbb';
        c.stroke();
    };

    /**
     * Optimised method for drawing body convex hull wireframes in one pass
     * @private
     * @method bodyConvexHulls
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyConvexHulls = function(render, bodies, context) {
        var c = context,
            body,
            part,
            i,
            j,
            k;

        c.beginPath();

        // render convex hulls
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible || body.parts.length === 1)
                continue;

            c.moveTo(body.vertices[0].x, body.vertices[0].y);

            for (j = 1; j < body.vertices.length; j++) {
                c.lineTo(body.vertices[j].x, body.vertices[j].y);
            }

            c.lineTo(body.vertices[0].x, body.vertices[0].y);
        }

        c.lineWidth = 1;
        c.strokeStyle = 'rgba(255,255,255,0.2)';
        c.stroke();
    };

    /**
     * Renders body vertex numbers.
     * @private
     * @method vertexNumbers
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.vertexNumbers = function(render, bodies, context) {
        var c = context,
            i,
            j,
            k;

        for (i = 0; i < bodies.length; i++) {
            var parts = bodies[i].parts;
            for (k = parts.length > 1 ? 1 : 0; k < parts.length; k++) {
                var part = parts[k];
                for (j = 0; j < part.vertices.length; j++) {
                    c.fillStyle = 'rgba(255,255,255,0.2)';
                    c.fillText(i + '_' + j, part.position.x + (part.vertices[j].x - part.position.x) * 0.8, part.position.y + (part.vertices[j].y - part.position.y) * 0.8);
                }
            }
        }
    };

    /**
     * Renders mouse position.
     * @private
     * @method mousePosition
     * @param {render} render
     * @param {mouse} mouse
     * @param {RenderingContext} context
     */
    Render.mousePosition = function(render, mouse, context) {
        var c = context;
        c.fillStyle = 'rgba(255,255,255,0.8)';
        c.fillText(mouse.position.x + '  ' + mouse.position.y, mouse.position.x + 5, mouse.position.y - 5);
    };

    /**
     * Draws body bounds
     * @private
     * @method bodyBounds
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyBounds = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options;

        c.beginPath();

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (body.render.visible) {
                var parts = bodies[i].parts;
                for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    var part = parts[j];
                    c.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);
                }
            }
        }

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,255,255,0.08)';
        } else {
            c.strokeStyle = 'rgba(0,0,0,0.1)';
        }

        c.lineWidth = 1;
        c.stroke();
    };

    /**
     * Draws body angle indicators and axes
     * @private
     * @method bodyAxes
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyAxes = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options,
            part,
            i,
            j,
            k;

        c.beginPath();

        for (i = 0; i < bodies.length; i++) {
            var body = bodies[i],
                parts = body.parts;

            if (!body.render.visible)
                continue;

            if (options.showAxes) {
                // render all axes
                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    part = parts[j];
                    for (k = 0; k < part.axes.length; k++) {
                        var axis = part.axes[k];
                        c.moveTo(part.position.x, part.position.y);
                        c.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);
                    }
                }
            } else {
                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    part = parts[j];
                    for (k = 0; k < part.axes.length; k++) {
                        // render a single axis indicator
                        c.moveTo(part.position.x, part.position.y);
                        c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2,
                                 (part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2);
                    }
                }
            }
        }

        if (options.wireframes) {
            c.strokeStyle = 'indianred';
            c.lineWidth = 1;
        } else {
            c.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            c.globalCompositeOperation = 'overlay';
            c.lineWidth = 2;
        }

        c.stroke();
        c.globalCompositeOperation = 'source-over';
    };

    /**
     * Draws body positions
     * @private
     * @method bodyPositions
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyPositions = function(render, bodies, context) {
        var c = context,
            engine = render.engine,
            options = render.options,
            body,
            part,
            i,
            k;

        c.beginPath();

        // render current positions
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];

            if (!body.render.visible)
                continue;

            // handle compound parts
            for (k = 0; k < body.parts.length; k++) {
                part = body.parts[k];
                c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);
                c.closePath();
            }
        }

        if (options.wireframes) {
            c.fillStyle = 'indianred';
        } else {
            c.fillStyle = 'rgba(0,0,0,0.5)';
        }
        c.fill();

        c.beginPath();

        // render previous positions
        for (i = 0; i < bodies.length; i++) {
            body = bodies[i];
            if (body.render.visible) {
                c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);
                c.closePath();
            }
        }

        c.fillStyle = 'rgba(255,165,0,0.8)';
        c.fill();
    };

    /**
     * Draws body velocity
     * @private
     * @method bodyVelocity
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyVelocity = function(render, bodies, context) {
        var c = context;

        c.beginPath();

        for (var i = 0; i < bodies.length; i++) {
            var body = bodies[i];

            if (!body.render.visible)
                continue;

            c.moveTo(body.position.x, body.position.y);
            c.lineTo(body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);
        }

        c.lineWidth = 3;
        c.strokeStyle = 'cornflowerblue';
        c.stroke();
    };

    /**
     * Draws body ids
     * @private
     * @method bodyIds
     * @param {render} render
     * @param {body[]} bodies
     * @param {RenderingContext} context
     */
    Render.bodyIds = function(render, bodies, context) {
        var c = context,
            i,
            j;

        for (i = 0; i < bodies.length; i++) {
            if (!bodies[i].render.visible)
                continue;

            var parts = bodies[i].parts;
            for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                var part = parts[j];
                c.font = "12px Arial";
                c.fillStyle = 'rgba(255,255,255,0.5)';
                c.fillText(part.id, part.position.x + 10, part.position.y - 10);
            }
        }
    };

    /**
     * Description
     * @private
     * @method collisions
     * @param {render} render
     * @param {pair[]} pairs
     * @param {RenderingContext} context
     */
    Render.collisions = function(render, pairs, context) {
        var c = context,
            options = render.options,
            pair,
            collision,
            corrected,
            bodyA,
            bodyB,
            i,
            j;

        c.beginPath();

        // render collision positions
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive)
                continue;

            collision = pair.collision;
            for (j = 0; j < pair.activeContacts.length; j++) {
                var contact = pair.activeContacts[j],
                    vertex = contact.vertex;
                c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);
            }
        }

        if (options.wireframes) {
            c.fillStyle = 'rgba(255,255,255,0.7)';
        } else {
            c.fillStyle = 'orange';
        }
        c.fill();

        c.beginPath();

        // render collision normals
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive)
                continue;

            collision = pair.collision;

            if (pair.activeContacts.length > 0) {
                var normalPosX = pair.activeContacts[0].vertex.x,
                    normalPosY = pair.activeContacts[0].vertex.y;

                if (pair.activeContacts.length === 2) {
                    normalPosX = (pair.activeContacts[0].vertex.x + pair.activeContacts[1].vertex.x) / 2;
                    normalPosY = (pair.activeContacts[0].vertex.y + pair.activeContacts[1].vertex.y) / 2;
                }

                if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {
                    c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);
                } else {
                    c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);
                }

                c.lineTo(normalPosX, normalPosY);
            }
        }

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,165,0,0.7)';
        } else {
            c.strokeStyle = 'orange';
        }

        c.lineWidth = 1;
        c.stroke();
    };

    /**
     * Description
     * @private
     * @method separations
     * @param {render} render
     * @param {pair[]} pairs
     * @param {RenderingContext} context
     */
    Render.separations = function(render, pairs, context) {
        var c = context,
            options = render.options,
            pair,
            collision,
            corrected,
            bodyA,
            bodyB,
            i,
            j;

        c.beginPath();

        // render separations
        for (i = 0; i < pairs.length; i++) {
            pair = pairs[i];

            if (!pair.isActive)
                continue;

            collision = pair.collision;
            bodyA = collision.bodyA;
            bodyB = collision.bodyB;

            var k = 1;

            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;
            if (bodyB.isStatic) k = 0;

            c.moveTo(bodyB.position.x, bodyB.position.y);
            c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);

            k = 1;

            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;
            if (bodyA.isStatic) k = 0;

            c.moveTo(bodyA.position.x, bodyA.position.y);
            c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);
        }

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,165,0,0.5)';
        } else {
            c.strokeStyle = 'orange';
        }
        c.stroke();
    };

    /**
     * Description
     * @private
     * @method grid
     * @param {render} render
     * @param {grid} grid
     * @param {RenderingContext} context
     */
    Render.grid = function(render, grid, context) {
        var c = context,
            options = render.options;

        if (options.wireframes) {
            c.strokeStyle = 'rgba(255,180,0,0.1)';
        } else {
            c.strokeStyle = 'rgba(255,180,0,0.5)';
        }

        c.beginPath();

        var bucketKeys = Common.keys(grid.buckets);

        for (var i = 0; i < bucketKeys.length; i++) {
            var bucketId = bucketKeys[i];

            if (grid.buckets[bucketId].length < 2)
                continue;

            var region = bucketId.split(/C|R/);
            c.rect(0.5 + parseInt(region[1], 10) * grid.bucketWidth,
                    0.5 + parseInt(region[2], 10) * grid.bucketHeight,
                    grid.bucketWidth,
                    grid.bucketHeight);
        }

        c.lineWidth = 1;
        c.stroke();
    };

    /**
     * Description
     * @private
     * @method inspector
     * @param {inspector} inspector
     * @param {RenderingContext} context
     */
    Render.inspector = function(inspector, context) {
        var engine = inspector.engine,
            selected = inspector.selected,
            render = inspector.render,
            options = render.options,
            bounds;

        if (options.hasBounds) {
            var boundsWidth = render.bounds.max.x - render.bounds.min.x,
                boundsHeight = render.bounds.max.y - render.bounds.min.y,
                boundsScaleX = boundsWidth / render.options.width,
                boundsScaleY = boundsHeight / render.options.height;

            context.scale(1 / boundsScaleX, 1 / boundsScaleY);
            context.translate(-render.bounds.min.x, -render.bounds.min.y);
        }

        for (var i = 0; i < selected.length; i++) {
            var item = selected[i].data;

            context.translate(0.5, 0.5);
            context.lineWidth = 1;
            context.strokeStyle = 'rgba(255,165,0,0.9)';
            context.setLineDash([1,2]);

            switch (item.type) {

            case 'body':

                // render body selections
                bounds = item.bounds;
                context.beginPath();
                context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3),
                             Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));
                context.closePath();
                context.stroke();

                break;

            case 'constraint':

                // render constraint selections
                var point = item.pointA;
                if (item.bodyA)
                    point = item.pointB;
                context.beginPath();
                context.arc(point.x, point.y, 10, 0, 2 * Math.PI);
                context.closePath();
                context.stroke();

                break;

            }

            context.setLineDash([]);
            context.translate(-0.5, -0.5);
        }

        // render selection region
        if (inspector.selectStart !== null) {
            context.translate(0.5, 0.5);
            context.lineWidth = 1;
            context.strokeStyle = 'rgba(255,165,0,0.6)';
            context.fillStyle = 'rgba(255,165,0,0.1)';
            bounds = inspector.selectBounds;
            context.beginPath();
            context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y),
                         Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));
            context.closePath();
            context.stroke();
            context.fill();
            context.translate(-0.5, -0.5);
        }

        if (options.hasBounds)
            context.setTransform(1, 0, 0, 1, 0, 0);
    };

    /**
     * Description
     * @method _createCanvas
     * @private
     * @param {} width
     * @param {} height
     * @return canvas
     */
    var _createCanvas = function(width, height) {
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        canvas.oncontextmenu = function() { return false; };
        canvas.onselectstart = function() { return false; };
        return canvas;
    };

    /**
     * Gets the pixel ratio of the canvas.
     * @method _getPixelRatio
     * @private
     * @param {HTMLElement} canvas
     * @return {Number} pixel ratio
     */
    var _getPixelRatio = function(canvas) {
        var context = canvas.getContext('2d'),
            devicePixelRatio = window.devicePixelRatio || 1,
            backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio
                                      || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio
                                      || context.backingStorePixelRatio || 1;

        return devicePixelRatio / backingStorePixelRatio;
    };

    /**
     * Gets the requested texture (an Image) via its path
     * @method _getTexture
     * @private
     * @param {render} render
     * @param {string} imagePath
     * @return {Image} texture
     */
    var _getTexture = function(render, imagePath) {
        var image = render.textures[imagePath];

        if (image)
            return image;

        image = render.textures[imagePath] = new Image();
        image.src = imagePath;

        return image;
    };

    /**
     * Applies the background to the canvas using CSS.
     * @method applyBackground
     * @private
     * @param {render} render
     * @param {string} background
     */
    var _applyBackground = function(render, background) {
        var cssBackground = background;

        if (/(jpg|gif|png)$/.test(background))
            cssBackground = 'url(' + background + ')';

        render.canvas.style.background = cssBackground;
        render.canvas.style.backgroundSize = "contain";
        render.currentBackground = background;
    };

    /*
    *
    *  Events Documentation
    *
    */

    /**
    * Fired before rendering
    *
    * @event beforeRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /**
    * Fired after rendering
    *
    * @event afterRender
    * @param {} event An event object
    * @param {number} event.timestamp The engine.timing.timestamp of the event
    * @param {} event.source The source object of the event
    * @param {} event.name The name of the event
    */

    /*
    *
    *  Properties Documentation
    *
    */

    /**
     * A back-reference to the `Matter.Render` module.
     *
     * @property controller
     * @type render
     */

    /**
     * A reference to the `Matter.Engine` instance to be used.
     *
     * @property engine
     * @type engine
     */

    /**
     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)
     *
     * @property element
     * @type HTMLElement
     * @default null
     */

    /**
     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.
     *
     * @property canvas
     * @type HTMLCanvasElement
     * @default null
     */

    /**
     * The configuration options of the renderer.
     *
     * @property options
     * @type {}
     */

    /**
     * The target width in pixels of the `render.canvas` to be created.
     *
     * @property options.width
     * @type number
     * @default 800
     */

    /**
     * The target height in pixels of the `render.canvas` to be created.
     *
     * @property options.height
     * @type number
     * @default 600
     */

    /**
     * A flag that specifies if `render.bounds` should be used when rendering.
     *
     * @property options.hasBounds
     * @type boolean
     * @default false
     */

    /**
     * A `Bounds` object that specifies the drawing view region.
     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).
     * This allows for creating views that can pan or zoom around the scene.
     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.
     *
     * @property bounds
     * @type bounds
     */

    /**
     * The 2d rendering context from the `render.canvas` element.
     *
     * @property context
     * @type CanvasRenderingContext2D
     */

    /**
     * The sprite texture cache.
     *
     * @property textures
     * @type {}
     */

})();

},{"../body/Composite":2,"../collision/Grid":6,"../core/Common":14,"../core/Events":16,"../core/Mouse":19,"../geometry/Bounds":26,"../geometry/Vector":28}],32:[function(_dereq_,module,exports){
/**
* The `Matter.RenderPixi` module is an example renderer using pixi.js.
* See also `Matter.Render` for a canvas based renderer.
*
* @class RenderPixi
* @deprecated the Matter.RenderPixi module will soon be removed from the Matter.js core.
* It will likely be moved to its own repository (but maintenance will be limited).
*/

var RenderPixi = {};

module.exports = RenderPixi;

var Bounds = _dereq_('../geometry/Bounds');
var Composite = _dereq_('../body/Composite');
var Common = _dereq_('../core/Common');
var Events = _dereq_('../core/Events');
var Vector = _dereq_('../geometry/Vector');

(function() {

    var _requestAnimationFrame,
        _cancelAnimationFrame;

    if (typeof window !== 'undefined') {
        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame
                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame 
                                      || function(callback){ window.setTimeout(function() { callback(Common.now()); }, 1000 / 60); };
   
        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame 
                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
    }
    
    /**
     * Creates a new Pixi.js WebGL renderer
     * @method create
     * @param {object} options
     * @return {RenderPixi} A new renderer
     * @deprecated
     */
    RenderPixi.create = function(options) {
        Common.warn('RenderPixi.create: Matter.RenderPixi is deprecated (see docs)');

        var defaults = {
            controller: RenderPixi,
            engine: null,
            element: null,
            frameRequestId: null,
            canvas: null,
            renderer: null,
            container: null,
            spriteContainer: null,
            pixiOptions: null,
            options: {
                width: 800,
                height: 600,
                background: '#fafafa',
                wireframeBackground: '#222',
                hasBounds: false,
                enabled: true,
                wireframes: true,
                showSleeping: true,
                showDebug: false,
                showBroadphase: false,
                showBounds: false,
                showVelocity: false,
                showCollisions: false,
                showAxes: false,
                showPositions: false,
                showAngleIndicator: false,
                showIds: false,
                showShadows: false
            }
        };

        var render = Common.extend(defaults, options),
            transparent = !render.options.wireframes && render.options.background === 'transparent';

        // init pixi
        render.pixiOptions = render.pixiOptions || {
            view: render.canvas,
            transparent: transparent,
            antialias: true,
            backgroundColor: options.background
        };

        render.mouse = options.mouse;
        render.engine = options.engine;
        render.renderer = render.renderer || new PIXI.WebGLRenderer(render.options.width, render.options.height, render.pixiOptions);
        render.container = render.container || new PIXI.Container();
        render.spriteContainer = render.spriteContainer || new PIXI.Container();
        render.canvas = render.canvas || render.renderer.view;
        render.bounds = render.bounds || { 
            min: {
                x: 0,
                y: 0
            }, 
            max: { 
                x: render.options.width,
                y: render.options.height
            }
        };

        // event listeners
        Events.on(render.engine, 'beforeUpdate', function() {
            RenderPixi.clear(render);
        });

        // caches
        render.textures = {};
        render.sprites = {};
        render.primitives = {};

        // use a sprite batch for performance
        render.container.addChild(render.spriteContainer);

        // insert canvas
        if (Common.isElement(render.element)) {
            render.element.appendChild(render.canvas);
        } else {
            Common.warn('No "render.element" passed, "render.canvas" was not inserted into document.');
        }

        // prevent menus on canvas
        render.canvas.oncontextmenu = function() { return false; };
        render.canvas.onselectstart = function() { return false; };

        return render;
    };

    /**
     * Continuously updates the render canvas on the `requestAnimationFrame` event.
     * @method run
     * @param {render} render
     * @deprecated
     */
    RenderPixi.run = function(render) {
        (function loop(time){
            render.frameRequestId = _requestAnimationFrame(loop);
            RenderPixi.world(render);
        })();
    };

    /**
     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.
     * @method stop
     * @param {render} render
     * @deprecated
     */
    RenderPixi.stop = function(render) {
        _cancelAnimationFrame(render.frameRequestId);
    };

    /**
     * Clears the scene graph
     * @method clear
     * @param {RenderPixi} render
     * @deprecated
     */
    RenderPixi.clear = function(render) {
        var container = render.container,
            spriteContainer = render.spriteContainer;

        // clear stage container
        while (container.children[0]) { 
            container.removeChild(container.children[0]); 
        }

        // clear sprite batch
        while (spriteContainer.children[0]) { 
            spriteContainer.removeChild(spriteContainer.children[0]); 
        }

        var bgSprite = render.sprites['bg-0'];

        // clear caches
        render.textures = {};
        render.sprites = {};
        render.primitives = {};

        // set background sprite
        render.sprites['bg-0'] = bgSprite;
        if (bgSprite)
            container.addChildAt(bgSprite, 0);

        // add sprite batch back into container
        render.container.addChild(render.spriteContainer);

        // reset background state
        render.currentBackground = null;

        // reset bounds transforms
        container.scale.set(1, 1);
        container.position.set(0, 0);
    };

    /**
     * Sets the background of the canvas 
     * @method setBackground
     * @param {RenderPixi} render
     * @param {string} background
     * @deprecated
     */
    RenderPixi.setBackground = function(render, background) {
        if (render.currentBackground !== background) {
            var isColor = background.indexOf && background.indexOf('#') !== -1,
                bgSprite = render.sprites['bg-0'];

            if (isColor) {
                // if solid background color
                var color = Common.colorToNumber(background);
                render.renderer.backgroundColor = color;

                // remove background sprite if existing
                if (bgSprite)
                    render.container.removeChild(bgSprite); 
            } else {
                // initialise background sprite if needed
                if (!bgSprite) {
                    var texture = _getTexture(render, background);

                    bgSprite = render.sprites['bg-0'] = new PIXI.Sprite(texture);
                    bgSprite.position.x = 0;
                    bgSprite.position.y = 0;
                    render.container.addChildAt(bgSprite, 0);
                }
            }

            render.currentBackground = background;
        }
    };

    /**
     * Description
     * @method world
     * @param {engine} engine
     * @deprecated
     */
    RenderPixi.world = function(render) {
        var engine = render.engine,
            world = engine.world,
            renderer = render.renderer,
            container = render.container,
            options = render.options,
            bodies = Composite.allBodies(world),
            allConstraints = Composite.allConstraints(world),
            constraints = [],
            i;

        if (options.wireframes) {
            RenderPixi.setBackground(render, options.wireframeBackground);
        } else {
            RenderPixi.setBackground(render, options.background);
        }

        // handle bounds
        var boundsWidth = render.bounds.max.x - render.bounds.min.x,
            boundsHeight = render.bounds.max.y - render.bounds.min.y,
            boundsScaleX = boundsWidth / render.options.width,
            boundsScaleY = boundsHeight / render.options.height;

        if (options.hasBounds) {
            // Hide bodies that are not in view
            for (i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                body.render.sprite.visible = Bounds.overlaps(body.bounds, render.bounds);
            }

            // filter out constraints that are not in view
            for (i = 0; i < allConstraints.length; i++) {
                var constraint = allConstraints[i],
                    bodyA = constraint.bodyA,
                    bodyB = constraint.bodyB,
                    pointAWorld = constraint.pointA,
                    pointBWorld = constraint.pointB;

                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);
                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);

                if (!pointAWorld || !pointBWorld)
                    continue;

                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))
                    constraints.push(constraint);
            }

            // transform the view
            container.scale.set(1 / boundsScaleX, 1 / boundsScaleY);
            container.position.set(-render.bounds.min.x * (1 / boundsScaleX), -render.bounds.min.y * (1 / boundsScaleY));
        } else {
            constraints = allConstraints;
        }

        for (i = 0; i < bodies.length; i++)
            RenderPixi.body(render, bodies[i]);

        for (i = 0; i < constraints.length; i++)
            RenderPixi.constraint(render, constraints[i]);

        renderer.render(container);
    };


    /**
     * Description
     * @method constraint
     * @param {engine} engine
     * @param {constraint} constraint
     * @deprecated
     */
    RenderPixi.constraint = function(render, constraint) {
        var engine = render.engine,
            bodyA = constraint.bodyA,
            bodyB = constraint.bodyB,
            pointA = constraint.pointA,
            pointB = constraint.pointB,
            container = render.container,
            constraintRender = constraint.render,
            primitiveId = 'c-' + constraint.id,
            primitive = render.primitives[primitiveId];

        // initialise constraint primitive if not existing
        if (!primitive)
            primitive = render.primitives[primitiveId] = new PIXI.Graphics();

        // don't render if constraint does not have two end points
        if (!constraintRender.visible || !constraint.pointA || !constraint.pointB) {
            primitive.clear();
            return;
        }

        // add to scene graph if not already there
        if (Common.indexOf(container.children, primitive) === -1)
            container.addChild(primitive);

        // render the constraint on every update, since they can change dynamically
        primitive.clear();
        primitive.beginFill(0, 0);
        primitive.lineStyle(constraintRender.lineWidth, Common.colorToNumber(constraintRender.strokeStyle), 1);
        
        if (bodyA) {
            primitive.moveTo(bodyA.position.x + pointA.x, bodyA.position.y + pointA.y);
        } else {
            primitive.moveTo(pointA.x, pointA.y);
        }

        if (bodyB) {
            primitive.lineTo(bodyB.position.x + pointB.x, bodyB.position.y + pointB.y);
        } else {
            primitive.lineTo(pointB.x, pointB.y);
        }

        primitive.endFill();
    };
    
    /**
     * Description
     * @method body
     * @param {engine} engine
     * @param {body} body
     * @deprecated
     */
    RenderPixi.body = function(render, body) {
        var engine = render.engine,
            bodyRender = body.render;

        if (!bodyRender.visible)
            return;

        if (bodyRender.sprite && bodyRender.sprite.texture) {
            var spriteId = 'b-' + body.id,
                sprite = render.sprites[spriteId],
                spriteContainer = render.spriteContainer;

            // initialise body sprite if not existing
            if (!sprite)
                sprite = render.sprites[spriteId] = _createBodySprite(render, body);

            // add to scene graph if not already there
            if (Common.indexOf(spriteContainer.children, sprite) === -1)
                spriteContainer.addChild(sprite);

            // update body sprite
            sprite.position.x = body.position.x;
            sprite.position.y = body.position.y;
            sprite.rotation = body.angle;
            sprite.scale.x = bodyRender.sprite.xScale || 1;
            sprite.scale.y = bodyRender.sprite.yScale || 1;
        } else {
            var primitiveId = 'b-' + body.id,
                primitive = render.primitives[primitiveId],
                container = render.container;

            // initialise body primitive if not existing
            if (!primitive) {
                primitive = render.primitives[primitiveId] = _createBodyPrimitive(render, body);
                primitive.initialAngle = body.angle;
            }

            // add to scene graph if not already there
            if (Common.indexOf(container.children, primitive) === -1)
                container.addChild(primitive);

            // update body primitive
            primitive.position.x = body.position.x;
            primitive.position.y = body.position.y;
            primitive.rotation = body.angle - primitive.initialAngle;
        }
    };

    /**
     * Creates a body sprite
     * @method _createBodySprite
     * @private
     * @param {RenderPixi} render
     * @param {body} body
     * @return {PIXI.Sprite} sprite
     * @deprecated
     */
    var _createBodySprite = function(render, body) {
        var bodyRender = body.render,
            texturePath = bodyRender.sprite.texture,
            texture = _getTexture(render, texturePath),
            sprite = new PIXI.Sprite(texture);

        sprite.anchor.x = body.render.sprite.xOffset;
        sprite.anchor.y = body.render.sprite.yOffset;

        return sprite;
    };

    /**
     * Creates a body primitive
     * @method _createBodyPrimitive
     * @private
     * @param {RenderPixi} render
     * @param {body} body
     * @return {PIXI.Graphics} graphics
     * @deprecated
     */
    var _createBodyPrimitive = function(render, body) {
        var bodyRender = body.render,
            options = render.options,
            primitive = new PIXI.Graphics(),
            fillStyle = Common.colorToNumber(bodyRender.fillStyle),
            strokeStyle = Common.colorToNumber(bodyRender.strokeStyle),
            strokeStyleIndicator = Common.colorToNumber(bodyRender.strokeStyle),
            strokeStyleWireframe = Common.colorToNumber('#bbb'),
            strokeStyleWireframeIndicator = Common.colorToNumber('#CD5C5C'),
            part;

        primitive.clear();

        // handle compound parts
        for (var k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
            part = body.parts[k];

            if (!options.wireframes) {
                primitive.beginFill(fillStyle, 1);
                primitive.lineStyle(bodyRender.lineWidth, strokeStyle, 1);
            } else {
                primitive.beginFill(0, 0);
                primitive.lineStyle(1, strokeStyleWireframe, 1);
            }

            primitive.moveTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);

            for (var j = 1; j < part.vertices.length; j++) {
                primitive.lineTo(part.vertices[j].x - body.position.x, part.vertices[j].y - body.position.y);
            }

            primitive.lineTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);

            primitive.endFill();

            // angle indicator
            if (options.showAngleIndicator || options.showAxes) {
                primitive.beginFill(0, 0);

                if (options.wireframes) {
                    primitive.lineStyle(1, strokeStyleWireframeIndicator, 1);
                } else {
                    primitive.lineStyle(1, strokeStyleIndicator);
                }

                primitive.moveTo(part.position.x - body.position.x, part.position.y - body.position.y);
                primitive.lineTo(((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2 - body.position.x), 
                                 ((part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2 - body.position.y));

                primitive.endFill();
            }
        }

        return primitive;
    };

    /**
     * Gets the requested texture (a PIXI.Texture) via its path
     * @method _getTexture
     * @private
     * @param {RenderPixi} render
     * @param {string} imagePath
     * @return {PIXI.Texture} texture
     * @deprecated
     */
    var _getTexture = function(render, imagePath) {
        var texture = render.textures[imagePath];

        if (!texture)
            texture = render.textures[imagePath] = PIXI.Texture.fromImage(imagePath);

        return texture;
    };

})();

},{"../body/Composite":2,"../core/Common":14,"../core/Events":16,"../geometry/Bounds":26,"../geometry/Vector":28}]},{},[30])(30)
});

(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
},{}],2:[function(require,module,exports){
var arrayLikeToArray = require("./arrayLikeToArray");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;
},{"./arrayLikeToArray":1}],3:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
},{}],4:[function(require,module,exports){
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
},{}],5:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
},{}],6:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf");

var isNativeReflectConstruct = require("./isNativeReflectConstruct");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
},{"./isNativeReflectConstruct":14,"./setPrototypeOf":18}],7:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
},{}],8:[function(require,module,exports){
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
},{}],9:[function(require,module,exports){
var superPropBase = require("./superPropBase");

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;
},{"./superPropBase":19}],10:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
},{}],11:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
},{"./setPrototypeOf":18}],12:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
},{}],13:[function(require,module,exports){
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;
},{}],14:[function(require,module,exports){
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;
},{}],15:[function(require,module,exports){
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;
},{}],16:[function(require,module,exports){
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;
},{}],17:[function(require,module,exports){
var _typeof = require("@babel/runtime/helpers/typeof");

var assertThisInitialized = require("./assertThisInitialized");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
},{"./assertThisInitialized":3,"@babel/runtime/helpers/typeof":21}],18:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
},{}],19:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
},{"./getPrototypeOf":10}],20:[function(require,module,exports){
var arrayWithoutHoles = require("./arrayWithoutHoles");

var iterableToArray = require("./iterableToArray");

var unsupportedIterableToArray = require("./unsupportedIterableToArray");

var nonIterableSpread = require("./nonIterableSpread");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
},{"./arrayWithoutHoles":2,"./iterableToArray":15,"./nonIterableSpread":16,"./unsupportedIterableToArray":22}],21:[function(require,module,exports){
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
},{}],22:[function(require,module,exports){
var arrayLikeToArray = require("./arrayLikeToArray");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;
},{"./arrayLikeToArray":1}],23:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf");

var setPrototypeOf = require("./setPrototypeOf");

var isNativeFunction = require("./isNativeFunction");

var construct = require("./construct");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
},{"./construct":6,"./getPrototypeOf":10,"./isNativeFunction":13,"./setPrototypeOf":18}],24:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

},{}],25:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":24}],26:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _Maths = _interopRequireDefault(require("../utils/Maths.js"));

/**
 * AIEngine class
 * Define the AI engine wich responsible to update entities and apply
 * Machine learning algorithms
 * @abstract
 *
 * @property {EntityManager} entityManager
 * @property {Physics} physics
 * @property {Camera} camera
 */
var AiEngine = /*#__PURE__*/function () {
  /**
   * @param {Physics} physics
   * @param {EntityManager} entityManager
   * @param {Camera} camera
   */
  function AiEngine(physics, entityManager, camera) {
    (0, _classCallCheck2["default"])(this, AiEngine);
    this.physics = physics;
    this.entityManager = entityManager;
    this.camera = camera;
  }
  /**
   * Generate new version
   */


  (0, _createClass2["default"])(AiEngine, [{
    key: "newVersion",
    value: function newVersion() {
      this.version = _Maths["default"].generateId();
    }
    /**
     * Update the AI
     */

  }, {
    key: "update",
    value: function update() {
      throw new TypeError('"AiEngine.update" method must be implemented');
    }
    /**
     * Initialize data
     */

  }, {
    key: "init",
    value: function init() {
      throw new TypeError('"AiEngine.init" method must be implemented');
    }
    /**
     * Get the version of the engine
     */

  }, {
    key: "getVersion",
    value: function getVersion() {
      return this.version;
    }
  }]);
  return AiEngine;
}();

var _default = AiEngine;
exports["default"] = _default;

},{"../utils/Maths.js":165,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],27:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _AiEngine2 = _interopRequireDefault(require("../AiEngine.js"));

var _Genome = _interopRequireDefault(require("./Genome.js"));

var _Storage = _interopRequireDefault(require("../../core/Storage.js"));

var _NaturalSelection = _interopRequireDefault(require("./NaturalSelection.js"));

var _Color = _interopRequireDefault(require("../../utils/Color.js"));

var _Maths = _interopRequireDefault(require("../../utils/Maths.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * GeneticEngine class
 * Define the AI engine which use Genetic algorithms to train AI
 * @property {Genome[]} genomes
 * @property {number} nbGroups
 * @property {boolean} showOnlyBest
 * @property {boolean} randomizeColor
 */
var GeneticEngine = /*#__PURE__*/function (_AiEngine) {
  (0, _inherits2["default"])(GeneticEngine, _AiEngine);

  var _super = _createSuper(GeneticEngine);

  function GeneticEngine(physics, entityManager, camera) {
    var _this;

    (0, _classCallCheck2["default"])(this, GeneticEngine);
    _this = _super.call(this, physics, entityManager, camera);
    _this.naturalSelection = new _NaturalSelection["default"]((0, _assertThisInitialized2["default"])(_this));
    _this.nbPerGeneration = 20;
    _this.showOnlyBest = true;
    _this.randomizeColor = false;
    _this.maxLifeInSec = 20;
    _this.timeToReactInSec = 0.1;
    _this.mutationProb = 0.01;
    _this.genomes = [];
    _this.nbGroups = 0;
    _this.population = [];
    GeneticEngine.instance = (0, _assertThisInitialized2["default"])(_this);
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(GeneticEngine, [{
    key: "init",
    value: function init() {
      this.newVersion();
      this.numGeneration = 0;
      this.totalFitness = 0;
      this.bestGenomes = [];
      this.nbGroups = this.getPopulation().length;
      this.initGenomes();
      this.newGeneration();
      this.updateCamera();
    }
    /**
     * @return {number}
     */

  }, {
    key: "getNbPerGeneration",
    value: function getNbPerGeneration() {
      return this.nbPerGeneration;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setNbPerGeneration",
    value: function setNbPerGeneration(value) {
      this.nbPerGeneration = value;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getMaxLifeInSec",
    value: function getMaxLifeInSec() {
      return this.maxLifeInSec;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setMaxLifeInSec",
    value: function setMaxLifeInSec(value) {
      this.maxLifeInSec = value;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getMutationProb",
    value: function getMutationProb() {
      return this.mutationProb;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setMutationProb",
    value: function setMutationProb(value) {
      this.mutationProb = value;
    }
    /**
     * @override
     */

  }, {
    key: "update",
    value: function update() {
      var _this2 = this;

      if (this.isPopulationDead()) {
        this.genomes = this.naturalSelection.run();
        this.newGeneration();
        this.updateCamera();
      } else {
        this.population.map(function (entity) {
          return _this2.behave(entity);
        });
      }
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "isShowOnlyBest",
    value: function isShowOnlyBest() {
      return this.showOnlyBest;
    }
    /**
     * Set show only best genome
     * PS. the first element in the population is maintained as the best genome
     * @param {boolean} value
     */

  }, {
    key: "setShowOnlyBest",
    value: function setShowOnlyBest(value) {
      var _this3 = this;

      this.showOnlyBest = value;
      this.getPopulation().forEach(function (entity, index) {
        if (index >= _this3.nbGroups) {
          value ? _this3.entityManager.hide(entity) : _this3.entityManager.show(entity);
        }
      });
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "isRandomizeColor",
    value: function isRandomizeColor() {
      return this.randomizeColor;
    }
    /**
     * @param {boolean} randomizeColor
     */

  }, {
    key: "setRandomizeColor",
    value: function setRandomizeColor(randomizeColor) {
      this.randomizeColor = randomizeColor;
    }
    /**
     * Update population
     */

  }, {
    key: "updatePopulation",
    value: function updatePopulation() {
      this.population = this.getPopulation();
    }
    /**
     * Get the population using the entity manager
     * @return {Entity[]}
     */

  }, {
    key: "getPopulation",
    value: function getPopulation() {
      var _this4 = this;

      return this.entityManager.getDynamicEntities().filter(function (entity) {
        return _this4.entityManager.isBodyEntity(entity);
      });
    }
    /**
     * Setup the genomes (link to an entity)
     */

  }, {
    key: "setupGenomes",
    value: function setupGenomes() {
      var _this5 = this;

      this.genomes.forEach(function (genome, index) {
        genome.setEntity(_this5.population[index]);
        _this5.randomizeColor && _this5.updateColor(genome);
      });
    }
    /**
     * Get the genome of the given entity
     * @param {Entity} entity
     */

  }, {
    key: "getGenome",
    value: function getGenome(entity) {
      return this.genomes.find(function (genome) {
        return genome.entityId === entity.id;
      });
    }
    /**
     * Init genomes
     */

  }, {
    key: "initGenomes",
    value: function initGenomes() {
      var _this6 = this;

      var colors = Array.from({
        length: this.nbPerGeneration
      }).map(function () {
        return _Color["default"].fromArrayInt([_Maths["default"].generateId()]);
      });
      this.genomes = Array.from({
        length: this.nbPerGeneration * this.nbGroups
      }).map(function (v, index) {
        var color = colors[Math.floor(index / _this6.nbGroups)];
        return new _Genome["default"](_this6, {
          color: color
        });
      });
    }
    /**
     * Decide which behavior to do for the given entity
     * @param {Entity} entity
     */

  }, {
    key: "behave",
    value: function behave(entity) {
      var genome = this.getGenome(entity);
      return genome.behave(entity);
    }
    /**
     * Make a new generation
     */

  }, {
    key: "newGeneration",
    value: function newGeneration() {
      this.resetPopulation();
      this.newPopulation();
      this.updatePopulation();
      this.setupGenomes();
      this.setShowOnlyBest(this.showOnlyBest);
      this.numGeneration++;

      if (this.numGeneration > 1) {
        this.physics.setToRestart(true);
      }
    }
    /**
     * Reset the population
     */

  }, {
    key: "resetPopulation",
    value: function resetPopulation() {
      this.entityManager.entities = _Storage["default"].get().fetch(_Storage["default"].type.ENTITY);
    }
    /**
     * Create a new population
     */

  }, {
    key: "newPopulation",
    value: function newPopulation() {
      var _this7 = this;

      var entities = this.entityManager.getDynamicEntities();
      var clones = Array.from({
        length: this.nbPerGeneration - 1
      }).map(function () {
        return _this7.entityManager.cloneEntities(entities, {
          sameWorld: true
        });
      }).reduce(function (list, currentList) {
        return currentList.concat(list);
      }, []);
      this.entityManager.concatEntities(clones);
      this.entityManager.disableCollision();
    }
    /**
     * Check if the population is dead
     */

  }, {
    key: "isPopulationDead",
    value: function isPopulationDead() {
      var _this8 = this;

      return !this.population.find(function (entity) {
        return _this8.getGenome(entity).isAlive();
      });
    }
    /**
     * Update the camera position
     */

  }, {
    key: "updateCamera",
    value: function updateCamera() {
      this.camera.attach(this.population[0]);
    }
    /**
     * Update the color of the genome
     */

  }, {
    key: "updateColor",
    value: function updateColor(genome) {
      this.entityManager.findById(genome.entityId).setStyleAndGenerate({
        fillColor: '#' + genome.props.color
      });
    }
  }], [{
    key: "get",
    value: function get() {
      return GeneticEngine.instance;
    }
  }]);
  return GeneticEngine;
}(_AiEngine2["default"]);

GeneticEngine.instance = null;
var _default = GeneticEngine;
exports["default"] = _default;

},{"../../core/Storage.js":39,"../../utils/Color.js":163,"../../utils/Maths.js":165,"../AiEngine.js":26,"./Genome.js":28,"./NaturalSelection.js":29,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],28:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _Maths = _interopRequireDefault(require("../../utils/Maths.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Genome class
 * Define the Genome of the given entity (behaviors)
 */
var Genome = /*#__PURE__*/function () {
  function Genome(_ref, props) {
    var timeToReactInSec = _ref.timeToReactInSec,
        maxLifeInSec = _ref.maxLifeInSec,
        mutationProb = _ref.mutationProb;
    (0, _classCallCheck2["default"])(this, Genome);
    this.props = _objectSpread(_objectSpread({}, props), {}, {
      timeToReactInSec: timeToReactInSec,
      maxLifeInSec: maxLifeInSec,
      mutationProb: mutationProb
    });
    this.maxForce = 0.03;
    this.forces = [];
    this.fitness = 0;
    this.reset();
    this.init();
  }
  /**
   * Init the genome (forces)
   */


  (0, _createClass2["default"])(Genome, [{
    key: "init",
    value: function init() {
      var _this = this;

      this.forces = Array.from({
        length: this.props.maxLifeInSec / this.props.timeToReactInSec
      }, function () {
        return _this.generateRandomForce();
      });
    }
    /**
     * Reset the genome
     */

  }, {
    key: "reset",
    value: function reset() {
      this.timeCounter = 0;
      this.stepBehavior = 0;
      this.alive = true;
      this.fitness = 0;
      this.distance = 0;
      this.isBest = false;
    }
    /**
     * Set the entity and store initial data
     * @param {Entity} entity
     */

  }, {
    key: "setEntity",
    value: function setEntity(entity) {
      this.entityId = entity.id;
      this.startPosition = entity.position;
    }
    /**
     * flag the genome as best
     */

  }, {
    key: "setIsBest",
    value: function setIsBest() {
      this.isBest = true;
    }
    /**
     * Get the actual force to apply
     */

  }, {
    key: "getForce",
    value: function getForce() {
      if (this.haveToBehave()) {
        return this.forces[this.stepBehavior];
      }

      return {
        x: 0,
        y: 0
      };
    }
    /**
     * Decide if the gonme have to behave
     */

  }, {
    key: "haveToBehave",
    value: function haveToBehave() {
      if (this.alive) {
        if (this.timeCounter >= 60 * this.props.timeToReactInSec) {
          this.timeCounter = 0;
          this.stepBehavior++;
          return true;
        }

        this.timeCounter++;
      }

      return false;
    }
    /**
     * Decide if the genome have to die
     * @param {Entity} entity
     */

  }, {
    key: "haveToDie",
    value: function haveToDie(entity) {
      this.alive = this.stepBehavior < this.forces.length - 1 && !entity.isDead();
    }
    /**
     * Is the genome alive
     */

  }, {
    key: "isAlive",
    value: function isAlive() {
      return this.alive;
    }
    /**
     * Calculate the distance
     * @param {Entity} entity
     */

  }, {
    key: "calculateDistance",
    value: function calculateDistance(entity) {
      this.distance = entity.position.x - this.startPosition.x;
    }
    /**
     * Calculate the fitness
     */

  }, {
    key: "calculateFitness",
    value: function calculateFitness() {
      this.fitness = (this.distance < 0 ? 0 : 1 - 1 / Math.pow(this.distance, 3)) + (this.isBest ? 2 : 0);
    }
    /**
     * Decide what to do
     */

  }, {
    key: "behave",
    value: function behave(entity) {
      var force = this.getForce();

      if (entity.isMotion()) {
        entity.setForce(force);
      }

      this.haveToDie(entity);
      this.calculateDistance(entity);
    }
    /**
     * Mutate the genome
     */

  }, {
    key: "mutate",
    value: function mutate() {
      var _this2 = this;

      this.forces.forEach(function (force, index) {
        var randMutate = Math.random();

        if (randMutate < _this2.props.mutationProb) {
          _this2.forces[index] = _this2.generateRandomForce();
        }
      });
      return this;
    }
    /**
     * Generate random force
     */

  }, {
    key: "generateRandomForce",
    value: function generateRandomForce() {
      var force = _Maths["default"].randomInterval(this.maxForce * -1, this.maxForce);

      return {
        x: Math.round(force * 1000) / 1000,
        y: 0
      };
    }
    /**
     * Clone the genome
     */

  }, {
    key: "clone",
    value: function clone() {
      return _.cloneDeep(this);
    }
  }]);
  return Genome;
}();

var _default = Genome;
exports["default"] = _default;

},{"../../utils/Maths.js":165,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12}],29:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * NaturalSelection class
 * Define methods for natural selection
 */
var NaturalSelection = /*#__PURE__*/function () {
  /**
   * @param {GeneticEngine} aiEngine
   */
  function NaturalSelection(aiEngine) {
    (0, _classCallCheck2["default"])(this, NaturalSelection);
    this.aiEngine = aiEngine;
  }
  /**
   * Start the natural selection
   */


  (0, _createClass2["default"])(NaturalSelection, [{
    key: "run",
    value: function run() {
      this.doSnapshotData();
      var parents = this.doParentsSelection();
      var nextGenomes = this.doCrossover(parents);
      return this.doMutation(nextGenomes);
    }
    /**
     * Select parents.
     * 1. Select parent for the first group using random fitness
     * 2. For the other group, use the parent from the first group for the selection
     * @todo Simplify this function
     *
     * @var {number} parentIndexFirstGroup
     * @var {Gnome[]} parentGroup
     */

  }, {
    key: "doParentsSelection",
    value: function doParentsSelection() {
      var _this = this;

      var _this$aiEngine = this.aiEngine,
          genomes = _this$aiEngine.genomes,
          nbGroups = _this$aiEngine.nbGroups;
      var groupGenomes = this.getGroupGenomes(genomes);
      var parents = [];

      var _loop = function _loop(iGenome) {
        var parentGroup = [];
        var parentIndexFirstGroup = null;
        Array.from({
          length: nbGroups
        }).forEach(function (p, index) {
          var groupId = index % nbGroups;
          var groupGenome = groupGenomes[groupId];
          var parent = null;

          if (!groupId) {
            parent = _this.selectParent(groupGenome);
            parentIndexFirstGroup = groupGenome.findIndex(function (gGenome) {
              return gGenome === parent;
            });
          } else {
            parent = groupGenome[parentIndexFirstGroup];
          }

          parentGroup.push(parent);
        });
        parents = parents.concat(parentGroup);
      };

      for (var iGenome = 0; iGenome < genomes.length; iGenome += nbGroups) {
        _loop(iGenome);
      }

      return parents;
    }
    /**
     * Select a parent
     * @param {Genome[]} genomes
     * @return {Genome}
     */

  }, {
    key: "selectParent",
    value: function selectParent(genomes) {
      var totalFitness = this.getTotalFitness(genomes);
      var randomFitness = Math.random() * totalFitness;
      var randomBias = 0;
      return genomes.find(function (genome) {
        randomBias += genome.fitness;
        return randomBias >= randomFitness;
      });
    }
    /**
     * Group genomes by entity type
     * @return {Genome[][]}
     */

  }, {
    key: "getGroupGenomes",
    value: function getGroupGenomes(genomes) {
      var nbGroups = this.aiEngine.nbGroups;
      var groupGenomes = Array.from({
        length: nbGroups
      }, function () {
        return [];
      });
      genomes.map(function (genome, index) {
        var groupId = index % nbGroups;
        groupGenomes[groupId].push(genome);
      });
      return groupGenomes;
    }
    /**
     * Crossover the genome
     * @param {Genome[]} parents
     */

  }, {
    key: "doCrossover",
    value: function doCrossover(parents) {
      return parents.map(function (parent) {
        var genome = parent.clone();
        genome.reset();
        return genome;
      });
    }
    /**
     * Mutate genomes
     * @param {Genome[]} genomes
     */

  }, {
    key: "doMutation",
    value: function doMutation(genomes) {
      var _this$aiEngine2 = this.aiEngine,
          nbGroups = _this$aiEngine2.nbGroups,
          bestGenomes = _this$aiEngine2.bestGenomes;
      var mutatedGenome = genomes.map(function (genome) {
        return genome.mutate();
      });
      Array.from({
        length: nbGroups
      }).forEach(function (v, index) {
        mutatedGenome[index] = bestGenomes[index].clone();
        mutatedGenome[index].reset();
      });
      return mutatedGenome;
    }
    /**
     * Get the best genome in the population
     * @param {Genome[]} genomes
     * @return {Genome[]}
     */

  }, {
    key: "getBestGenomes",
    value: function getBestGenomes(genomes) {
      var groupGenomes = this.getGroupGenomes(genomes);
      var bestFirstGroup = groupGenomes[0].reduce(function (best, current) {
        return best && best.fitness > current.fitness ? best : current;
      }, null);
      return this.getAttachedGenome(bestFirstGroup, genomes).map(function (bestGenome) {
        bestGenome.setIsBest();
        return bestGenome;
      });
    }
    /**
     * Get all attached genomes inside the given genomes (include also
     * the given genome)
     * @param {Genome} genome
     * @param {Genome[]} genomes
     * @return {Genome[]}
     */

  }, {
    key: "getAttachedGenome",
    value: function getAttachedGenome(genome, genomes) {
      var groupGenomes = this.getGroupGenomes(genomes);
      var findGroup = groupGenomes.find(function (gGenomes) {
        return gGenomes.includes(genome);
      });
      var genomeIndex = findGroup.findIndex(function (gGenome) {
        return gGenome === genome;
      });
      return groupGenomes.reduce(function (list, gGenomes) {
        return list.concat([gGenomes[genomeIndex]]);
      }, []);
    }
    /**
     * Calculate the fitness
     */

  }, {
    key: "calculateFitness",
    value: function calculateFitness(genomes) {
      genomes.forEach(function (genome) {
        return genome.calculateFitness();
      });
    }
    /**
     * Get the best genome in the population
     * @param {Genome[]} genomes
     */

  }, {
    key: "getTotalFitness",
    value: function getTotalFitness(genomes) {
      this.calculateFitness(genomes);
      return genomes.reduce(function (total, genome) {
        return total + genome.fitness;
      }, 0);
    }
    /**
     * Do a snapshot of last generation's data
     */

  }, {
    key: "doSnapshotData",
    value: function doSnapshotData() {
      var genomes = this.aiEngine.genomes;
      this.aiEngine.totalFitness = this.getTotalFitness(genomes);
      this.aiEngine.bestGenomes = this.getBestGenomes(genomes);
    }
  }]);
  return NaturalSelection;
}();

var _default = NaturalSelection;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],30:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Define the action to be executed when an event is triggered
 */
var Action = /*#__PURE__*/function () {
  function Action() {
    (0, _classCallCheck2["default"])(this, Action);
    this.queue = [];
  }

  (0, _createClass2["default"])(Action, [{
    key: "add",

    /**
     * Add action to the queue.
     * @param {Object} object the object must define the method "execute"
     * @param {...any} args
     */
    value: function add(object) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this.queue.push({
        object: object,
        args: args
      });
    }
    /**
     * Run all actions. stop the execution if the "execute" return true.
     */

  }, {
    key: "run",
    value: function run() {
      for (var iQueue in this.queue) {
        if (this.queue.hasOwnProperty(iQueue)) {
          var _action$object;

          var action = this.queue[iQueue];

          if ((_action$object = action.object).execute.apply(_action$object, (0, _toConsumableArray2["default"])(action.args))) {
            break;
          }
        }
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this.queue = [];
    }
  }], [{
    key: "get",
    value: function get() {
      if (!Action.instance) {
        Action.instance = new Action();
      }

      return Action.instance;
    }
  }]);
  return Action;
}();

Action.instance = null;
var _default = Action;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/toConsumableArray":20}],31:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _Window = _interopRequireDefault(require("./Window.js"));

var _EventHandler = _interopRequireDefault(require("./EventHandler.js"));

var _ExceptionHandler = _interopRequireDefault(require("../exception/ExceptionHandler.js"));

/**
 * Define the application main
 */
var Application = /*#__PURE__*/function () {
  /**
   * @param {Class<Loop>[]} loops
   */
  function Application(loops) {
    (0, _classCallCheck2["default"])(this, Application);
    this.loops = loops;
    this.exceptionHandler = _ExceptionHandler["default"].get();
    this.window = _Window["default"].get();
    this.loop = this.loop.bind(this);
  }

  (0, _createClass2["default"])(Application, [{
    key: "start",
    value: function () {
      var _start = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.window.init();
                _context.next = 3;
                return Promise.all(this.loops.map(function (loop) {
                  return loop.get().init();
                }));

              case 3:
                this.loop();

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function start() {
        return _start.apply(this, arguments);
      }

      return start;
    }()
    /**
     * @private
     */

  }, {
    key: "loop",
    value: function loop() {
      try {
        this.loops.forEach(function (loop) {
          var loopInstance = loop.get();

          _EventHandler["default"].get().handle(_Window["default"].get(), loopInstance.getRunners());

          loopInstance.loop();
        });
      } catch (e) {
        this.exceptionHandler.handle(e);
      }

      this.window.clear();
      requestAnimationFrame(this.loop);
    }
  }]);
  return Application;
}();

var _default = Application;
exports["default"] = _default;

},{"../exception/ExceptionHandler.js":55,"./EventHandler.js":35,"./Window.js":41,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/regenerator":25}],32:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _CameraData2 = _interopRequireDefault(require("../project/data/CameraData.js"));

var _Vector = _interopRequireDefault(require("../utils/Vector.js"));

var _Constant = require("./Constant.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {Camera}
 * Define the camera
 * @property {{x: number, y: number, z: number}} position
 */
var Camera = /*#__PURE__*/function (_CameraData) {
  (0, _inherits2["default"])(Camera, _CameraData);

  var _super = _createSuper(Camera);

  function Camera(position) {
    var _this;

    (0, _classCallCheck2["default"])(this, Camera);
    _this = _super.call(this);
    _this.initPosition = Object.assign({
      x: 0,
      y: 0,
      z: 0
    }, position);
    _this.position = _this.initPosition;
    _this.entityId = null;
    return _this;
  }
  /**
   * Update camera position
   * @param {Object} position
   */


  (0, _createClass2["default"])(Camera, [{
    key: "update",
    value: function update(position) {
      this.position = Object.assign({
        x: 0,
        y: 0,
        z: 0
      }, position);
    }
    /**
     * Reset camera position
     */

  }, {
    key: "reset",
    value: function reset() {
      this.position = this.initPosition;
    }
    /**
     * Calculate and return the camera view
     */

  }, {
    key: "getCameraView",
    value: function getCameraView() {
      var cameraViewX = this.position.x - _Constant.SCENE_WIDTH / 2;
      var cameraViewY = this.position.y - _Constant.SCENE_HEIGHT / 2;
      var cameraViewZ = this.position.z || 0;
      return {
        cameraViewX: cameraViewX,
        cameraViewY: cameraViewY,
        cameraViewZ: cameraViewZ
      };
    }
    /**
     * Convert a position to canvas coordination
     * @param {Object} position
     */

  }, {
    key: "toCanvasCoord",
    value: function toCanvasCoord(position) {
      var _this$getCameraView = this.getCameraView(),
          cameraViewX = _this$getCameraView.cameraViewX,
          cameraViewY = _this$getCameraView.cameraViewY;

      var x = parseInt(position.x) - cameraViewX;
      var y = parseInt(position.y) - cameraViewY;
      return new _Vector["default"]({
        x: x,
        y: y
      });
    }
    /**
     * Get the canvas coordination from the given position
     * @param {Object} position
     */

  }, {
    key: "fromCanvasCoord",
    value: function fromCanvasCoord(position) {
      var _this$getCameraView2 = this.getCameraView(),
          cameraViewX = _this$getCameraView2.cameraViewX,
          cameraViewY = _this$getCameraView2.cameraViewY;

      var x = position.x + cameraViewX;
      var y = position.y + cameraViewY;
      return new _Vector["default"]({
        x: x,
        y: y
      });
    }
    /**
     * Attach the camera to an entity
     * @param {Entity} entity
     */

  }, {
    key: "attach",
    value: function attach(entity) {
      this.entityId = entity.id;
    }
    /**
     * Detach the camera
     */

  }, {
    key: "detach",
    value: function detach() {
      this.entityId = null;
    }
    /**
     * Get the entity using the id
     * @param {EntityManager} entityManager
     */

  }, {
    key: "getEntity",
    value: function getEntity(entityManager) {
      return entityManager.findById(this.entityId);
    }
    /**
     * @param {Vector} position
     */

  }, {
    key: "setInitPosition",
    value: function setInitPosition(position) {
      this.initPosition = position;
    }
  }]);
  return Camera;
}(_CameraData2["default"]);

var _default = Camera;
exports["default"] = _default;

},{"../project/data/CameraData.js":138,"../utils/Vector.js":169,"./Constant.js":33,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PREVIEW_URL = exports.STYLE_THEME = exports.CANVAS_CONTEXT_TYPE = exports.HTML_ID_PREFIX = exports.SCENE_HEIGHT = exports.SCENE_WIDTH = exports.WINDOW_HEIGHT = exports.WINDOW_WIDTH = void 0;
var WINDOW_WIDTH = window.innerWidth;
exports.WINDOW_WIDTH = WINDOW_WIDTH;
var WINDOW_HEIGHT = window.innerHeight;
exports.WINDOW_HEIGHT = WINDOW_HEIGHT;
var SCENE_WIDTH = 1438;
exports.SCENE_WIDTH = SCENE_WIDTH;
var SCENE_HEIGHT = 781;
exports.SCENE_HEIGHT = SCENE_HEIGHT;
var HTML_ID_PREFIX = 'app-el-';
exports.HTML_ID_PREFIX = HTML_ID_PREFIX;
var CANVAS_CONTEXT_TYPE = '2d';
exports.CANVAS_CONTEXT_TYPE = CANVAS_CONTEXT_TYPE;
var STYLE_THEME = 'dark';
exports.STYLE_THEME = STYLE_THEME;
var PREVIEW_URL = '/src/preview/';
exports.PREVIEW_URL = PREVIEW_URL;

},{}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.objectContext = exports.objectCanvas = void 0;

var _Constant = require("./Constant.js");

var objectCanvas = document.getElementById('object');
exports.objectCanvas = objectCanvas;
var objectContext = objectCanvas.getContext('2d');
exports.objectContext = objectContext;
objectContext.canvas.width = _Constant.SCENE_WIDTH;
objectContext.canvas.height = _Constant.SCENE_HEIGHT;

},{"./Constant.js":33}],35:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _Menu = _interopRequireDefault(require("../layout/Menu.js"));

var _Action = _interopRequireDefault(require("./Action.js"));

/**
 * Handle global events triggered by the user (click , mouse move)
 * and define related action (Runner) to be executed
 */
var EventHandler = /*#__PURE__*/function () {
  function EventHandler() {
    (0, _classCallCheck2["default"])(this, EventHandler);
  }

  (0, _createClass2["default"])(EventHandler, [{
    key: "handle",

    /**
     * Apply actions when event is triggered onto the window (Mouse and Keyboard events, ...)
     * @param {Window} window
     * @param {Class[]} runners
     */
    value: function handle(window, runners) {
      var mouse = window.mouse;

      var action = _Action["default"].get();

      var menu = _Menu["default"].get();

      action.reset();
      runners.forEach(function (runner) {
        var runnerInstance = runner.get();

        if (runnerInstance.isHandle(window)) {
          action.add(runnerInstance, mouse, menu);
        }
      });
      action.run();
    }
  }], [{
    key: "get",
    value: function get() {
      if (!this.instance) {
        this.instance = new this();
      }

      return this.instance;
    }
  }]);
  return EventHandler;
}();

EventHandler.instance = null;
var _default = EventHandler;
exports["default"] = _default;

},{"../layout/Menu.js":58,"./Action.js":30,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],36:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Define the keyboard inputs (key pressed, released)
 * @property {number[]} keys
 */
var Keyboard = /*#__PURE__*/function () {
  function Keyboard() {
    (0, _classCallCheck2["default"])(this, Keyboard);
    this.keys = [];
  }
  /**
   * @param {number} key
   */


  (0, _createClass2["default"])(Keyboard, [{
    key: "setKeyPressed",
    value: function setKeyPressed(key) {
      if (!this.isKeyPressed(key)) {
        this.keys.push(key);
      }
    }
    /**
     * @param {number} key
     */

  }, {
    key: "setKeyReleased",
    value: function setKeyReleased(key) {
      if (this.isKeyPressed(key)) {
        var index = this.keys.indexOf(key);
        this.keys.splice(index, 1);
      }
    }
    /**
     * @param {number} key
     * @return {Boolean}
     */

  }, {
    key: "isKeyPressed",
    value: function isKeyPressed(key) {
      var index = this.keys.indexOf(key);
      return index !== -1;
    }
  }]);
  return Keyboard;
}();

Keyboard.Keys = {
  CTRL: 17
};
var _default = Keyboard;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],37:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MeshData2 = _interopRequireDefault(require("../project/data/MeshData.js"));

var _ImageHelper = _interopRequireDefault(require("../utils/ImageHelper.js"));

var _Size = _interopRequireDefault(require("../pobject/Size.js"));

var _Constant = require("./Constant.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Define a block of pixels loaded to the VRAM.
 * Attached to an entity, and used to draw pixels by the GPU
 * @extends {MeshData}
 * @property {Vector} position
 * @property {{width: number, height: number}} size
 * @property {OffscreenCanvasRenderingContext2D} context
 */
var Mesh = /*#__PURE__*/function (_MeshData) {
  (0, _inherits2["default"])(Mesh, _MeshData);

  var _super = _createSuper(Mesh);

  function Mesh() {
    var _this;

    var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      x: 0,
      y: 0
    };
    var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    (0, _classCallCheck2["default"])(this, Mesh);
    _this = _super.call(this);
    _this.size = _this.getSize(size);
    _this.position = position;

    _this.initCanvas();

    return _this;
  }
  /**
   * @param {number|Size} size
   * @return {Size}
   */


  (0, _createClass2["default"])(Mesh, [{
    key: "getSize",
    value: function getSize(size) {
      return _.isNumber(size) ? new _Size["default"]({
        width: size,
        height: size
      }) : size;
    }
    /**
     * Initialize the canvas and the context for the current Mesh
     */

  }, {
    key: "initCanvas",
    value: function initCanvas() {
      var canvas = new OffscreenCanvas(this.size.width, this.size.height);
      this.context = canvas.getContext(_Constant.CANVAS_CONTEXT_TYPE);
    }
    /**
     * Copy a given canvas to the mesh
     * @param {OffscreenCanvas | HTMLImageElement} canvas
     * @param {Number} x
     * @param {Number} y
     * @param {Number} sw
     * @param {Number} sh
     */

  }, {
    key: "copy",
    value: function copy(canvas, x, y, sw, sh) {
      this.context.drawImage(canvas, x, y, sw, sh);
    }
    /**
     * Clear the Mesh
     * @param {number|Size} size
     */

  }, {
    key: "clear",
    value: function clear() {
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.size = this.getSize(size || this.size);

      if (this.size.width > 0 && this.size.height > 0) {
        this.context.canvas.width = this.size.width;
        this.context.canvas.height = this.size.height;
        return true;
      }

      return false;
    }
    /**
     * Create a mesh from another Mesh
     * @param {Mesh} mesh
     */

  }, {
    key: "copyFromMesh",
    value: function copyFromMesh(mesh) {
      this.copy(mesh.context.canvas, 0, 0, this.size.width, this.size.height);
    }
    /**
     * Create a mesh from a image URL
     * @param {string} imageInput Image url or blob
     * @return {boolean}
     */

  }, {
    key: "fromImage",
    value: function () {
      var _fromImage = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(imageInput) {
        var image, width, height;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!imageInput) {
                  _context.next = 10;
                  break;
                }

                image = new Image();
                image.src = imageInput;
                _context.next = 5;
                return image.decode();

              case 5:
                width = image.width, height = image.height;

                if (!(width && height)) {
                  _context.next = 10;
                  break;
                }

                this.clear({
                  width: width,
                  height: height
                });
                this.copy(image, 0, 0, width, height);
                return _context.abrupt("return", true);

              case 10:
                return _context.abrupt("return", false);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fromImage(_x) {
        return _fromImage.apply(this, arguments);
      }

      return fromImage;
    }()
    /**
     * @override
     */

  }, {
    key: "setDataUrl",
    value: function () {
      var _setDataUrl = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(dataUrl) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.fromImage(dataUrl);

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function setDataUrl(_x2) {
        return _setDataUrl.apply(this, arguments);
      }

      return setDataUrl;
    }()
    /**
     * @override
     */

  }, {
    key: "getDataUrl",
    value: function getDataUrl() {
      return _ImageHelper["default"].getDataURL(this.context.canvas, this.size);
    }
    /**
     * @param {OffscreenCanvasRenderingContext2D} context
     */

  }, {
    key: "setContext",
    value: function setContext(context) {
      this.context = context;
    }
    /**
     * Instantiate new Mesh from image URL
     * @param {string} imageInput Image url or blob
     * @return {Mesh}
     */

  }], [{
    key: "fromImage",
    value: function () {
      var _fromImage2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(imageInput) {
        var mesh;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                mesh = new Mesh();
                _context3.next = 3;
                return mesh.fromImage(imageInput);

              case 3:
                return _context3.abrupt("return", mesh);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function fromImage(_x3) {
        return _fromImage2.apply(this, arguments);
      }

      return fromImage;
    }()
  }]);
  return Mesh;
}(_MeshData2["default"]);

var _default = Mesh;
exports["default"] = _default;

},{"../pobject/Size.js":136,"../project/data/MeshData.js":143,"../utils/ImageHelper.js":164,"./Constant.js":33,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/regenerator":25}],38:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Define the mouse inputs (pressed, clicked, mouse position, ...)
 */
var Mouse = /*#__PURE__*/function () {
  function Mouse() {
    (0, _classCallCheck2["default"])(this, Mouse);
    this.keydowns = [];
    this.keyclicks = [];
    this.keydbclicks = [];
    this.position = {
      x: 0,
      y: 0
    };
    this.target = null;
    this.currentPosition = {
      x: 0,
      y: 0
    };
    this.lastPosition = this.currentPosition;
    this.mouseWheel = {
      y: 0
    };
  }
  /**
   * @param {MouseEvent} event
   * @return {Vector}
   */


  (0, _createClass2["default"])(Mouse, [{
    key: "getPosition",
    value: function getPosition(event) {
      return {
        x: event.clientX,
        y: event.clientY
      };
    }
    /**
     * @param {MouseEvent} event
     * @return {EventTarget}
     */

  }, {
    key: "getTarget",
    value: function getTarget(event) {
      return event.target;
    }
    /**
     * @param {MouseEvent} event
     * @return {EventTarget[]}
     */

  }, {
    key: "getPath",
    value: function getPath(event) {
      return event.composedPath();
    }
    /**
     * @param {number} key
     */

  }, {
    key: "setButtonPressed",
    value: function setButtonPressed(key) {
      if (!this.isButtonPressed(key)) {
        this.keydowns.push(key);
      }

      this.position = this.getPosition(event);
      this.target = this.getTarget(event);
      this.path = this.getPath(event);
    }
    /**
     * @param {number} key
     */

  }, {
    key: "setButtonClicked",
    value: function setButtonClicked(key) {
      if (!this.isButtonClicked(key)) {
        this.keyclicks.push(key);
      }
    }
    /**
     * @param {number} key
     */

  }, {
    key: "setButtonDoubleClicked",
    value: function setButtonDoubleClicked(key) {
      if (!this.isButtonDoubleClicked(key)) {
        this.keydbclicks.push(key);
      }
    }
    /**
     * @param {number} key
     */

  }, {
    key: "setButtonReleased",
    value: function setButtonReleased(key) {
      if (this.isButtonPressed(key)) {
        var index = this.keydowns.indexOf(key);
        this.keydowns.splice(index, 1);
      }
    }
    /**
     * @param {number} deltaY
     */

  }, {
    key: "setMouseWheel",
    value: function setMouseWheel(deltaY) {
      this.mouseWheel.y = deltaY;
    }
    /**
     * Return the distance between the currentPosition and the position
     * of the mouse on the click
     * @returns {Vector}
     */

  }, {
    key: "getDragDistance",
    value: function getDragDistance() {
      var x = this.currentPosition.x - this.position.x;
      var y = this.currentPosition.y - this.position.y;
      return {
        x: x,
        y: y,
        z: 0
      };
    }
    /**
     * Calculate and return the area of drag (selection)
     * @return {{position: Vector, size: Size}}
     */

  }, {
    key: "getDragArea",
    value: function getDragArea() {
      var dragDistance = this.getDragDistance();
      var newX = this.position.x;
      var newY = this.position.y;

      if (dragDistance.x <= 0) {
        newX += dragDistance.x;
      }

      if (dragDistance.y <= 0) {
        newY += dragDistance.y;
      }

      return {
        position: {
          x: newX,
          y: newY
        },
        size: {
          width: Math.abs(dragDistance.x),
          height: Math.abs(dragDistance.y)
        }
      };
    }
    /**
     * Drag and drop (return the drag distance and update the initial position)
     * @return {Vector}
     */

  }, {
    key: "dragAndDrop",
    value: function dragAndDrop() {
      var dragDistance = this.getDragDistance();
      this.position = this.currentPosition;
      return dragDistance;
    }
    /**
     * @param {number} key
     * @return {Boolean}
     */

  }, {
    key: "isButtonPressed",
    value: function isButtonPressed(key) {
      var index = this.keydowns.indexOf(key);
      return index !== -1;
    }
    /**
     * @param {number} key
     * @return {Boolean}
     */

  }, {
    key: "isButtonClicked",
    value: function isButtonClicked(key) {
      var index = this.keyclicks.indexOf(key);
      return index !== -1;
    }
    /**
     * @param {number} key
     * @return {Boolean}
     */

  }, {
    key: "isButtonDoubleClicked",
    value: function isButtonDoubleClicked(key) {
      var index = this.keydbclicks.indexOf(key);
      return index !== -1;
    }
    /**
     * @return {Boolean}
     */

  }, {
    key: "isMouseMove",
    value: function isMouseMove() {
      return this.lastPosition.x !== this.currentPosition.x || this.lastPosition.y !== this.currentPosition.y;
    }
    /**
     * @return {{y: number}}
     */

  }, {
    key: "getMouseWheel",
    value: function getMouseWheel() {
      return this.mouseWheel;
    }
  }, {
    key: "setMouseMove",
    value: function setMouseMove() {
      this.lastPosition = this.currentPosition;
      this.currentPosition = this.getPosition(event);
    }
  }, {
    key: "clearKeyClicked",
    value: function clearKeyClicked() {
      this.keyclicks = [];
      this.keydbclicks = [];
    }
  }, {
    key: "clear",
    value: function clear() {
      this.clearKeyClicked();
      this.mouseWheel.y = 0;
    }
  }]);
  return Mouse;
}();

Mouse.MouseButton = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};
Mouse.CURSOR = {
  DEFAULT: 'default',
  CROSSHAIR: 'crosshair',
  POINTER: 'pointer',
  MOVE: 'move',
  MOVE_ENTITY: 'moveentity'
};
var _default = Mouse;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],39:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _XmlSerDe = _interopRequireDefault(require("../serde/XmlSerDe.js"));

var _JsSerDe = _interopRequireDefault(require("../serde/JsSerDe.js"));

var _Schema = _interopRequireDefault(require("../schema/Schema.js"));

/**
 * Utils to manage the storage of data over time.
 * Handle clones and manage conflicts
 * @property {Map<string, *>} data
 */
var Storage = /*#__PURE__*/function () {
  /**
   * @type {Storage}
   */
  function Storage() {
    (0, _classCallCheck2["default"])(this, Storage);
    this.data = {};
  }
  /**
   * @returns {Storage}
   */


  (0, _createClass2["default"])(Storage, [{
    key: "update",

    /**
     * Update the storage (merge data)
     * @param {string} type
     * @param {Object|Array} data
     */
    value: function update(type, data) {
      this.data[type] = _.cloneDeep(data);
      return this;
    }
    /**
     * Update the storage and validate data
     * @param {string} type
     * @param {Object|Array} data
     * @param {boolean} serialize
     */

  }, {
    key: "updateAndValidate",
    value: function () {
      var _updateAndValidate = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(type, data) {
        var serialize,
            validData,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                serialize = _args.length > 2 && _args[2] !== undefined ? _args[2] : true;
                _context.next = 3;
                return _Schema["default"].validate(type, data, _Schema["default"].getMeta(), {
                  serialize: serialize
                });

              case 3:
                validData = _context.sent;
                this.data[type] = _.cloneDeep(validData);
                return _context.abrupt("return", this);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function updateAndValidate(_x, _x2) {
        return _updateAndValidate.apply(this, arguments);
      }

      return updateAndValidate;
    }()
    /**
     * Load and validate data to the given target
     * @param {string} type
     * @param {Object|Array} data
     * @param {Object} target
     */

  }, {
    key: "load",
    value: function () {
      var _load = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(type, data, target) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.updateAndValidate(type, data, false);

              case 2:
                target.set(_.cloneDeep(this.data[type]));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function load(_x3, _x4, _x5) {
        return _load.apply(this, arguments);
      }

      return load;
    }()
    /**
     * Validate and save given data to the storage
     * @param {string} type
     * @param {Object|Array} data
     */

  }, {
    key: "save",
    value: function () {
      var _save = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(type, data) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.updateAndValidate(type, data);

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function save(_x6, _x7) {
        return _save.apply(this, arguments);
      }

      return save;
    }()
    /**
     * Get data from the storage
     * @param {String} type
     * @return {Object}
     */

  }, {
    key: "fetch",
    value: function fetch(type) {
      var data = this.data[type];
      return data && _.cloneDeep(data);
    }
    /**
     * Export all data to the given format
     * @param {string} key
     * @param {Storage.format} format
     * @return {string|Object}
     */

  }, {
    key: "export",
    value: function _export(key, format) {
      var serde = this.getSerDe(format);
      return new serde().serialize(this.data[key]);
    }
    /**
     * Import data from the given data and format
     * @param {string} data
     * @param {Storage.format} format
     * @return {Map<string, *>}
     */

  }, {
    key: "import",
    value: function _import(data, format) {
      var serde = this.getSerDe(format);
      return new serde().deserialize(data);
    }
    /**
     * Save data to local storage
     * @param {string} key
     * @param {Object|Array} data
     */

  }, {
    key: "saveLocal",
    value: function () {
      var _saveLocal = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(key, data) {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.save(key, data);

              case 2:
                localStorage.setItem(key, JSON.stringify(this.data[key]));

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function saveLocal(_x8, _x9) {
        return _saveLocal.apply(this, arguments);
      }

      return saveLocal;
    }()
    /**
     * Load data from local storage to the target object
     * @param {string} key
     * @param {Object} target
     * @return {Object}
     */

  }, {
    key: "loadLocal",
    value: function () {
      var _loadLocal = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(key, target) {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.loadJson(key, target, localStorage.getItem(key));

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function loadLocal(_x10, _x11) {
        return _loadLocal.apply(this, arguments);
      }

      return loadLocal;
    }()
    /**
     * Load data from the given json string
     * @param {string} key
     * @param {Object} target
     * @param {string} jsonString
     * @return {Object}
     */

  }, {
    key: "loadJson",
    value: function () {
      var _loadJson = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(key, target, jsonString) {
        var data;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                data = JSON.parse(jsonString);
                _context6.next = 3;
                return this.load(key, data, target);

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function loadJson(_x12, _x13, _x14) {
        return _loadJson.apply(this, arguments);
      }

      return loadJson;
    }()
  }, {
    key: "reset",
    value: function reset() {
      localStorage.clear();
    }
    /**
     * @param {Storage.format} format
     * @return {Class}
     */

  }, {
    key: "getSerDe",
    value: function getSerDe(format) {
      switch (format) {
        case Storage.format.XML:
          return _XmlSerDe["default"];

        case Storage.format.WEB:
          return _JsSerDe["default"];

        case Storage.format.BIN:
          return BinSerDe;

        default:
          throw new TypeError("Export format ".concat(format, " not recognized"));
      }
    }
  }], [{
    key: "get",
    value: function get() {
      if (!Storage.instance) {
        Storage.instance = new Storage();
      }

      return Storage.instance;
    }
  }]);
  return Storage;
}();

(0, _defineProperty2["default"])(Storage, "instance", void 0);
Storage.type = {
  ENTITY: 'entities',
  WORLD: 'world'
};
Storage.format = {
  XML: 'xml',
  WEB: 'web',
  BIN: 'bin'
};
var _default = Storage;
exports["default"] = _default;

},{"../schema/Schema.js":155,"../serde/JsSerDe.js":157,"../serde/XmlSerDe.js":159,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/regenerator":25}],40:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Mesh = _interopRequireDefault(require("./Mesh.js"));

var _Maths = _interopRequireDefault(require("../utils/Maths.js"));

var _TextureData2 = _interopRequireDefault(require("../project/data/TextureData.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {Texture}
 * @extends {TextureData}
 */
var Texture = /*#__PURE__*/function (_TextureData) {
  (0, _inherits2["default"])(Texture, _TextureData);

  var _super = _createSuper(Texture);

  function Texture() {
    var _this;

    (0, _classCallCheck2["default"])(this, Texture);
    _this = _super.call(this);
    _this.id = _Maths["default"].generateId();
    _this.name = 'Texture';
    _this.mesh = new _Mesh["default"]();
    _this.selected = false;
    return _this;
  }

  (0, _createClass2["default"])(Texture, [{
    key: "isSelected",
    value: function isSelected() {
      return this.selected;
    }
  }, {
    key: "select",
    value: function select() {
      this.setSelected(true);
    }
  }, {
    key: "unselect",
    value: function unselect() {
      this.setSelected(false);
    }
    /**
     * @param {boolean} value
     */

  }, {
    key: "setSelected",
    value: function setSelected(value) {
      this.selected = value;
    }
    /**
     * @param {string} image
     * @return {boolean}
     */

  }, {
    key: "load",
    value: function () {
      var _load = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(image) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.mesh.fromImage(image));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function load(_x) {
        return _load.apply(this, arguments);
      }

      return load;
    }()
  }]);
  return Texture;
}(_TextureData2["default"]);

var _default = Texture;
exports["default"] = _default;

},{"../project/data/TextureData.js":147,"../utils/Maths.js":165,"./Mesh.js":37,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/regenerator":25}],41:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Keyboard = _interopRequireDefault(require("./Keyboard.js"));

var _Mouse = _interopRequireDefault(require("./Mouse.js"));

/**
 * Handle the window event listeners (keyboard, mouse, ...)
 * @property {Keyboard} keyboard
 * @property {Mouse} mouse
 */
var Window = /*#__PURE__*/function () {
  /**
   * @type {Window}
   */
  function Window() {
    (0, _classCallCheck2["default"])(this, Window);
    this.keyboard = new _Keyboard["default"]();
    this.mouse = new _Mouse["default"]();
  }

  (0, _createClass2["default"])(Window, [{
    key: "init",
    value: function init() {
      this.initEvents();
    }
  }, {
    key: "initEvents",
    value: function initEvents() {
      var _this = this;

      document.addEventListener('keydown', function (event) {
        var key = event.keyCode;

        _this.keyboard.setKeyPressed(key);
      });
      document.addEventListener('keyup', function (event) {
        var key = event.keyCode;

        _this.keyboard.setKeyReleased(key);
      });
      document.addEventListener('click', function (event) {
        var key = event.button;

        _this.mouse.setButtonClicked(key);
      });
      document.addEventListener('dblclick', function (event) {
        var key = event.button;

        _this.mouse.setButtonDoubleClicked(key);
      });
      document.addEventListener('mousedown', function (event) {
        var key = event.button;

        _this.mouse.setButtonPressed(key);
      });
      document.addEventListener('mouseup', function (event) {
        var key = event.button;

        _this.mouse.setButtonReleased(key);
      });
      document.addEventListener('mousemove', function () {
        _this.mouse.setMouseMove();
      });
      document.addEventListener('wheel', function (event) {
        _this.mouse.setMouseWheel(event.deltaY);
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      this.mouse.clear();
    }
    /**
     * @return {Window}
     */

  }], [{
    key: "get",
    value: function get() {
      if (!this.instance) {
        this.instance = new this();
      }

      return this.instance;
    }
  }]);
  return Window;
}();

(0, _defineProperty2["default"])(Window, "instance", null);
var _default = Window;
exports["default"] = _default;

},{"./Keyboard.js":36,"./Mouse.js":38,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12}],42:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Mesh = _interopRequireDefault(require("../core/Mesh.js"));

var _Window = _interopRequireDefault(require("../core/Window.js"));

var _Vertex = _interopRequireDefault(require("../utils/Vertex.js"));

var _Vector = _interopRequireDefault(require("../utils/Vector.js"));

var _EntityData2 = _interopRequireDefault(require("../project/data/EntityData.js"));

var _Style = _interopRequireDefault(require("../pobject/Style.js"));

var _Constant = require("../core/Constant.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Abstract Entity class
 * @abstract
 * @extends {EntityData}
 * @todo Think to use a MeshManager for performance
 *
 * @property {Mesh} mesh
 * @property {number} id
 * @property {string} shape
 * @property {string} name
 * @property {Style} advancedStyle
 */
var Entity = /*#__PURE__*/function (_EntityData) {
  (0, _inherits2["default"])(Entity, _EntityData);

  var _super = _createSuper(Entity);

  /**
   * @param {EntityProps} props
   */
  function Entity(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, Entity);
    _this = _super.call(this, props);

    if (_this.constructor === Entity) {
      throw new TypeError('Abstract class Entity cannot be instantiated directly');
    }

    _this.isBuffered = false;
    _this.isPhyiscsLoaded = false;
    _this.mesh = new _Mesh["default"](_this.position, _this.size);
    _this.meshBgColor = new _Mesh["default"]();
    _this.selected = false;
    _this.focused = false;
    _this.attachedEntities = null;
    _this.generated = true;
    _this.loading = false;
    return _this;
  }
  /**
   * Build the Entity (generate mesh, set properties ...)
   * @param {World} world
   * @return {boolean}
   */


  (0, _createClass2["default"])(Entity, [{
    key: "build",
    value: function build(world) {
      return this.init(world) && this.regenerate(world);
    }
    /**
     * End the build of the Entity
     */

  }, {
    key: "end",
    value: function end() {}
    /**
     * Generate mesh for the rect
     * @param {World} world
     * @return {boolean}
     */

  }, {
    key: "generateMesh",
    value: function generateMesh(world) {
      var dataContext = this.startContext();

      if (dataContext) {
        this.drawContext(dataContext);
        return this.closeContext(dataContext);
      }
    }
    /**
     * Called before starting drawing entities (calculate size, init mesh position, ...)
     * @abstract
     * @param {World} world
     * @return {boolean}
     */

  }, {
    key: "init",
    value: function init(world) {
      throw new TypeError('Entity.init must be implemented');
    }
    /**
     * Draw the context
     * @param {DataContext} dataContext
     */

  }, {
    key: "drawContext",
    value: function drawContext(dataContext) {
      throw new TypeError('"drawContext" method must be implemented');
    }
    /**
     * Start the context
     * @return {DataContext | null}
     */

  }, {
    key: "startContext",
    value: function startContext() {
      var _this$getLargestRecta = this.getLargestRectangle(this.rotation, this.size),
          width = _this$getLargestRecta.width,
          height = _this$getLargestRecta.height;

      if (width && height) {
        var center = {
          x: this.size.width / 2,
          y: this.size.height / 2
        };
        var canvas = new OffscreenCanvas(width, height);
        var context = canvas.getContext(_Constant.CANVAS_CONTEXT_TYPE);
        var fillColor = this.getFillColor();

        var _this$getStyle = this.getStyle(),
            opacity = _this$getStyle.opacity,
            borderSize = _this$getStyle.borderSize;

        context.strokeStyle = this.getColor();
        fillColor && (context.fillStyle = fillColor);
        _.isNumber(opacity) && (context.globalAlpha = opacity);
        context.lineWidth = borderSize || 1;
        context.translate(width / 2, height / 2);
        context.rotate(this.rotation);
        context.translate(-center.x, -center.y);
        return {
          center: center,
          context: context
        };
      }

      return null;
    }
    /**
     * Close drawing context
     * @param {DataContext} dataContext
     * @return {boolean}
     */

  }, {
    key: "closeContext",
    value: function closeContext(dataContext) {
      var fillColor = this.getFillColor();

      var _this$getStyle2 = this.getStyle(),
          borderSize = _this$getStyle2.borderSize;

      var context = dataContext.context;

      if (this.getTextureId()) {
        borderSize && context.stroke();

        if (fillColor) {
          context.fill();
          context.globalCompositeOperation = 'destination-over';
        }

        context.clip();
        var canvasBg = this.meshBgColor.context.canvas;

        if (this.isBackgroundImageRepeat()) {
          context.fillStyle = context.createPattern(canvasBg, 'repeat');
          context.fill();
        } else {
          context.drawImage(this.meshBgColor.context.canvas, 0, 0, this.size.width, this.size.height);
        }
      } else if (fillColor) {
        context.stroke();
        context.fill();
      } else {
        context.stroke();
      }

      return this.updateMeshFromContext(context);
    }
    /**
     * Calculate the largest rectangle for given rotation and size
     * @param {number} angleRadian
     * @param {Object} size
     */

  }, {
    key: "getLargestRectangle",
    value: function getLargestRectangle(angleRadian, size) {
      var cosA = Math.cos(angleRadian);
      var sinA = Math.sin(angleRadian);
      var points = [{
        x: 0,
        y: 0
      }, {
        x: size.width,
        y: 0
      }, {
        x: size.width,
        y: size.height
      }, {
        x: 0,
        y: size.height
      }];
      var rotatedPoints = points.map(function (_ref) {
        var x = _ref.x,
            y = _ref.y;
        return {
          x: x * cosA - y * sinA,
          y: x * sinA + y * cosA
        };
      });
      var minX = rotatedPoints.reduce(function (mnX, current) {
        return mnX > current.x && current.x || mnX;
      }, rotatedPoints[0].x);
      var maxX = rotatedPoints.reduce(function (mxX, current) {
        return mxX < current.x && current.x || mxX;
      }, rotatedPoints[0].x);
      var minY = rotatedPoints.reduce(function (mnY, current) {
        return mnY > current.y && current.y || mnY;
      }, rotatedPoints[0].y);
      var maxY = rotatedPoints.reduce(function (mxY, current) {
        return mxY < current.y && current.y || mxY;
      }, rotatedPoints[0].y);
      return {
        width: Math.ceil(maxX - minX),
        height: Math.ceil(maxY - minY)
      };
    }
    /**
     * Generate the entity
     * @param {World} world
     */

  }, {
    key: "generate",
    value: function generate(world) {
      return this.isCanGenerate() && this.generateMesh(world);
    }
    /**
     * Regenerate the mesh
     * @param {World} world
     */

  }, {
    key: "regenerate",
    value: function regenerate(world) {
      return this.clearBuffer() && this.generate(world);
    }
    /**
     * Clone the entity (can be redefined for each type)
     */

  }, {
    key: "clone",
    value: function clone() {
      var cloned = _.cloneDeep(this);

      cloned.attachedEntities = null;
      return cloned;
    }
    /**
     * Close the build of the Entity
     */

  }, {
    key: "close",
    value: function close() {
      this.position = this.mesh.position;
      this.loading = false;
    }
    /**
     * Send the Mesh to the renderer for drawing
     * @param {Renderer} renderer
     */

  }, {
    key: "draw",
    value: function draw(renderer) {
      if (this.isBuffered) {
        renderer.draw(this);
      }
    }
    /**
     * @override
     */

  }, {
    key: "setPosition",
    value: function setPosition(position) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(Entity.prototype), "setPosition", this).call(this, position);
      this.mesh.position = position;
    }
    /**
     * Set the entity's position and generate the Mesh
     */

  }, {
    key: "setPositionAndGenerate",
    value: function setPositionAndGenerate(position) {
      this.setPosition(position);

      if (!_.isEqual(this.position, position)) {
        this.setGenerated(false);
      }
    }
    /**
     * Set the entity's rotation
     * @param {Number} angle
     */

  }, {
    key: "setRotationAndGenerate",
    value: function setRotationAndGenerate(angle) {
      if (this.rotation !== angle) {
        (0, _get2["default"])((0, _getPrototypeOf2["default"])(Entity.prototype), "setRotation", this).call(this, angle);
        this.setGenerated(false);
      }
    }
    /**
     * Set the entity's style and re-Generate the Mesh
     * @param {Style} style
     */

  }, {
    key: "setStyleAndGenerate",
    value: function setStyleAndGenerate(style) {
      this.setStyle(style);
      this.setGenerated(false);
    }
    /**
     * Set the entity's size
     * @param {{width: number, height: number}} size
     */

  }, {
    key: "setSizeAndGenerate",
    value: function setSizeAndGenerate(size) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(Entity.prototype), "setSize", this).call(this, size);

      if (!_.isEqual(this.size, size)) {
        this.setGenerated(false);
      }
    }
    /**
     * Select the current entity (apply styles, ...)
     */

  }, {
    key: "select",
    value: function select() {
      this.selected = true;
      var style = new _Style["default"]();
      style.setColor('#FF00FF');
      style.setFillColor('rgba(255, 0, 255, 0.3)');
      style.setBorderSize(1);
      this.setStyleAndGenerate(style);
    }
    /**
     * Focus the current entity (apply styles, ...)
     */

  }, {
    key: "focus",
    value: function focus() {
      this.focused = true;
      var style = new _Style["default"]();
      style.setColor('orange');
      style.setFillColor('orange');
      style.setOpacity(0.5);
      style.setBorderSize(1);
      !this.selected && this.setStyleAndGenerate(style);
    }
    /**
     * Unfocus the current entity (apply styles, ...)
     */

  }, {
    key: "unfocus",
    value: function unfocus() {
      !this.selected && this.focused && this.setStyleAndGenerate(this.defineStyle());
      this.focused = false;
    }
    /**
     * Unselect the current entity (apply styles, ...)
     */

  }, {
    key: "unselect",
    value: function unselect() {
      this.selected && this.setStyleAndGenerate(this.defineStyle());
      this.selected = false;
    }
    /**
     * Lock/Unlock the entity for modification
     * @param {Boolean} lock
     */

  }, {
    key: "lock",
    value: function lock(_lock) {
      this.locked = _lock;
      this.setStyleAndGenerate(this.defineStyle());
    }
    /**
     * Show the entity
     * @param {boolean} visible
     */

  }, {
    key: "show",
    value: function show(visible) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(Entity.prototype), "setVisible", this).call(this, visible);
    }
    /**
     * @override
     */

  }, {
    key: "defineStyle",
    value: function defineStyle() {
      var styleLocked = {
        color: '#AAAAAA',
        fillColor: 'rgba(0, 0, 0, 0.01)'
      };
      return this.locked && styleLocked || this.props.style;
    }
    /**
     * Set new position for the Mesh
     * @param {Object} position
     */

  }, {
    key: "setMeshPosition",
    value: function setMeshPosition(position) {
      this.mesh.position = position;
    }
    /**
     * Calculate the centroid
     * @return {Vector}
     */

  }, {
    key: "getCenter",
    value: function getCenter() {
      return {
        x: this.mesh.size.width / 2,
        y: this.mesh.size.height / 2
      };
    }
    /**
     * Convert current position to center position
     * @return {Vector}
     */

  }, {
    key: "toCenterPosition",
    value: function toCenterPosition() {
      var center = this.getCenter();
      return {
        x: this.position.x + center.x,
        y: this.position.y + center.y
      };
    }
    /**
     * Get current position from center position
     * @param {Vector} position
     * @return {Vector}
     */

  }, {
    key: "fromCenterPosition",
    value: function fromCenterPosition(position) {
      var center = this.getCenter();
      return {
        x: position.x - center.x,
        y: position.y - center.y
      };
    }
    /**
     * Move current entity from point A to B
     * @param {Vector} pointA absolute position
     * @param {Vector} pointB absolute position
     */

  }, {
    key: "movePointTo",
    value: function movePointTo(pointA, pointB) {
      var x = this.position.x + pointB.x - pointA.x;
      var y = this.position.y + pointB.y - pointA.y;
      this.setPosition({
        x: x,
        y: y
      });
    }
    /**
     * Convert relative coordinate to absolute coordinate
     * @param {Vector} point Relative coordinate
     * @return {Vector}
     */

  }, {
    key: "toAbsolutePosition",
    value: function toAbsolutePosition(point) {
      return new _Vector["default"]({
        x: point.x + this.mesh.position.x,
        y: point.y + this.mesh.position.y
      });
    }
    /**
     * Convert absolute coordinate to relative coordinate
     * @param {Vector} point Absolute coordinate
     */

  }, {
    key: "fromAbsolutePosition",
    value: function fromAbsolutePosition(point) {
      return {
        x: point.x - this.mesh.position.x,
        y: point.y - this.mesh.position.y
      };
    }
    /**
     * Convert absolute coordinate to relative coordinate
     * based to the center of the object
     * @param {Vector} point Absolute coordinate
     * @return {Vector}
     */

  }, {
    key: "toRelativeCenterPosition",
    value: function toRelativeCenterPosition(point) {
      var _this$toCenterPositio = this.toCenterPosition(),
          x = _this$toCenterPositio.x,
          y = _this$toCenterPositio.y;

      return new _Vector["default"]({
        x: point.x - x,
        y: point.y - y
      });
    }
    /**fromRelativeCenterPosition
     * Convert relative coordinate (based to the center) to absolute coordinate
     * @param {Vector} point relative coordinate
     */

  }, {
    key: "fromRelativeCenterPosition",
    value: function fromRelativeCenterPosition(point) {
      var _this$toCenterPositio2 = this.toCenterPosition(),
          x = _this$toCenterPositio2.x,
          y = _this$toCenterPositio2.y;

      return {
        x: x + point.x,
        y: y + point.y
      };
    }
    /**
     * Convert relative coordinate to absolute coordinate
     * @param {Vector} point Absolute coordinate
     */

  }, {
    key: "fromRelativePosition",
    value: function fromRelativePosition(point) {
      var _this$position = this.position,
          x = _this$position.x,
          y = _this$position.y;
      return {
        x: x + point.x,
        y: y + point.y
      };
    }
    /**
     * Update the Mesh position related to the distance
     * between the click mouse position and the actual
     * position of the mouse, and return the drag distance
     * @return {Vector}
     */

  }, {
    key: "setMeshPositionByDragDistance",
    value: function setMeshPositionByDragDistance() {
      var window = _Window["default"].get();

      var dragDistance = window.mouse.getDragDistance();
      var newX = this.position.x;
      var newY = this.position.y;

      if (dragDistance.x <= 0) {
        newX += dragDistance.x;
      }

      if (dragDistance.y <= 0) {
        newY += dragDistance.y;
      }

      this.setMeshPosition({
        x: newX,
        y: newY
      });
      return dragDistance;
    }
    /**
     * Get the current position of the mouse
     * @return {Vector}
     */

  }, {
    key: "getCurrentMousePosition",
    value: function getCurrentMousePosition() {
      var dragDistance = _Window["default"].get().mouse.getDragDistance();

      return _Vector["default"].add(this.position, dragDistance);
    }
    /**
     * Update the mesh from a given context
     * @param {OffscreenCanvasRenderingContext2D} context
     */

  }, {
    key: "updateMeshFromContext",
    value: function updateMeshFromContext(context) {
      var sw = context.canvas.width,
          sh = context.canvas.height;

      if (sw && sh) {
        this.mesh.clear({
          width: sw,
          height: sh
        });
        this.mesh.context = context;
        return true;
      }

      return false;
    }
    /**
     * Clear the buffer and the Mesh
     */

  }, {
    key: "clearBuffer",
    value: function clearBuffer() {
      this.isBuffered = false;
      return this.mesh.clear();
    }
    /**
     * Set the buffer flag
     */

  }, {
    key: "addToBuffer",
    value: function addToBuffer() {
      if (!this.isBuffered) {
        this.isBuffered = true;
        return true;
      }

      return false;
    }
    /**
     * Unload physics for the entity
     * @param {PhysicsEngine} physicsEngine
     */

  }, {
    key: "unloadPhysics",
    value: function unloadPhysics(physicsEngine) {
      if (this.isPhyiscsLoaded) {
        physicsEngine.removeShape(this);
      }

      this.isPhyiscsLoaded = false;
    }
    /**
     * Add entity to physics Engine
     * @param {PhysicsEngine} physicsEngine
     */

  }, {
    key: "loadPhysics",
    value: function loadPhysics(physicsEngine) {
      if (!this.isPhyiscsLoaded) {
        physicsEngine.add(this);
        this.isPhyiscsLoaded = true;
      }
    }
    /**
     * Check if point is inside the entity (using size)
     * Method can be overwrite by the sub-entities for more precision
     * @param {Vector} point absolute coordinate
     */

  }, {
    key: "includes",
    value: function includes(point) {
      var vertices = this.generateVertices();
      return _Vertex["default"].contains(vertices, this.fromAbsolutePosition(point));
    }
    /**
     * @return {{x: number, y: number}[]}
     */

  }, {
    key: "loadVertices",
    value: function loadVertices() {
      var _this$size = this.size,
          width = _this$size.width,
          height = _this$size.height;
      return [{
        x: 0,
        y: 0
      }, {
        x: width,
        y: 0
      }, {
        x: width,
        y: height
      }, {
        x: 0,
        y: height
      }];
    }
    /**
     * Generate vertices for the current entity (relative coordinates)
     * @return {{x: number, y: number}[]}
     */

  }, {
    key: "generateVertices",
    value: function generateVertices() {
      var _this$getLargestRecta2 = this.getLargestRectangle(this.rotation, this.size),
          mWidth = _this$getLargestRecta2.width,
          mHeight = _this$getLargestRecta2.height;

      var center = {
        x: this.size.width / 2,
        y: this.size.height / 2
      };
      var mCenter = {
        x: mWidth / 2,
        y: mHeight / 2
      };
      var vertices = this.loadVertices();
      vertices = _Vertex["default"].translate(vertices, center, -1);
      vertices = _Vertex["default"].rotate(vertices, this.rotation, {
        x: 0,
        y: 0
      });
      vertices = _Vertex["default"].translate(vertices, mCenter);
      return vertices;
    }
    /**
     * Is entity valid (not in loading mode, ...)
     */

  }, {
    key: "isValid",
    value: function isValid() {
      return !this.loading;
    }
    /**
     * Is entity active (valid, unlocked, ...)
     */

  }, {
    key: "isActive",
    value: function isActive() {
      return this.isValid() && !this.isLocked() && this.isVisible() && !this.isSubEntity();
    }
    /**
     * is the generate hook must be disabled
     */

  }, {
    key: "isCanGenerate",
    value: function isCanGenerate() {
      return (0, _get2["default"])((0, _getPrototypeOf2["default"])(Entity.prototype), "isVisible", this).call(this);
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "isGenerated",
    value: function isGenerated() {
      return this.generated;
    }
    /**
     * @param {boolean} generated
     */

  }, {
    key: "setGenerated",
    value: function setGenerated(generated) {
      this.generated = generated;
    }
    /**
     * @override
     */

  }, {
    key: "setTextureId",
    value: function setTextureId(textureId) {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(Entity.prototype), "setTextureId", this).call(this, textureId);
      this.setGenerated(false);
    }
    /**
     * @param {World} world
     */

  }, {
    key: "updateTexture",
    value: function updateTexture(world) {
      this.meshBgColor = this.getTexture(world);
    }
    /**
     * @param {World} world
     * @return {Mesh}
     */

  }, {
    key: "getTexture",
    value: function getTexture(world) {
      var texture = world.getTextureManager().findById(this.getTextureId());

      if (texture) {
        return texture.getMesh();
      }

      return null;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "isLoading",
    value: function isLoading() {
      return this.loading;
    }
    /**
     * @param {boolean} loading
     */

  }, {
    key: "setLoading",
    value: function setLoading(loading) {
      this.loading = loading;
    }
    /**
     * @param {boolean} value
     */

  }, {
    key: "setIsBuffered",
    value: function setIsBuffered(value) {
      this.isBuffered = value;
    }
    /**
     * @param {boolean} value
     */

  }, {
    key: "setIsPhyiscsLoaded",
    value: function setIsPhyiscsLoaded(value) {
      this.isPhyiscsLoaded = value;
    }
    /**
     * @param {Mesh} value
     */

  }, {
    key: "setMesh",
    value: function setMesh(value) {
      this.mesh = value;
    }
    /**
     * @param {Mesh} value
     */

  }, {
    key: "setMeshBgColor",
    value: function setMeshBgColor(value) {
      this.meshBgColor = value;
    }
    /**
     * @param {boolean} value
     */

  }, {
    key: "setSelected",
    value: function setSelected(value) {
      this.selected = value;
    }
    /**
     * @param {boolean} value
     */

  }, {
    key: "setFocused",
    value: function setFocused(value) {
      this.focused = value;
    }
    /**
     * @param {Entity[]} entities
     */

  }, {
    key: "setAttachedEntities",
    value: function setAttachedEntities(entities) {
      this.attachedEntities = entities;
    }
  }, {
    key: "getFillColor",
    value: function getFillColor() {
      return this.style.fillColor || this.props.style.fillColor;
    }
  }, {
    key: "getColor",
    value: function getColor() {
      return this.style.color || this.props.style.color;
    }
  }]);
  return Entity;
}(_EntityData2["default"]);
/**
 * @typedef {{center: {x: number, y: number}, context: OffscreenCanvasRenderingContext2D}} DataContext
 */


var _default = Entity;
exports["default"] = _default;

},{"../core/Constant.js":33,"../core/Mesh.js":37,"../core/Window.js":41,"../pobject/Style.js":137,"../project/data/EntityData.js":141,"../utils/Vector.js":169,"../utils/Vertex.js":170,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":9,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],43:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Entity2 = _interopRequireDefault(require("./Entity.js"));

var _AppState = _interopRequireDefault(require("../state/AppState.js"));

var _Vector = _interopRequireDefault(require("../utils/Vector.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Abstract EntityMotion class
 * @abstract
 * @extends {Entity}
 * @todo Refactor collision properties
 */
var EntityMotion = /*#__PURE__*/function (_Entity) {
  (0, _inherits2["default"])(EntityMotion, _Entity);

  var _super = _createSuper(EntityMotion);

  function EntityMotion() {
    var _this;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, EntityMotion);
    _this = _super.call(this, props);

    if (_this.constructor === EntityMotion) {
      throw new TypeError('Abstract class EntityMotion cannot be instantiated directly');
    }

    _this.physics = _objectSpread({
      velocity: new _Vector["default"]({
        x: 0,
        y: 0
      }),
      angularVelocity: 0,
      speed: 0.7,
      density: 0.001,
      force: {
        x: 0,
        y: 0
      },
      fixed: false,
      motion: true
    }, props.physics);
    _this.condition = {
      die: {
        collisionWith: null
      }
    };
    _this.collision = {
      group: 0,
      category: 1,
      mask: 1
    };
    _this.die = false;
    _this.controlled = false;
    _this.visible = true;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(EntityMotion, [{
    key: "init",
    value: function init(world) {
      return (0, _get2["default"])((0, _getPrototypeOf2["default"])(EntityMotion.prototype), "init", this).call(this, world);
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "isFixed",
    value: function isFixed() {
      return this.physics.fixed;
    }
    /**
     * If the entity is fixed, is automatically motionless
     * @param {boolean} isFixed
     */

  }, {
    key: "setFixed",
    value: function setFixed(isFixed) {
      this.physics.fixed = isFixed;
      isFixed && this.setMotion(false);
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "isMotion",
    value: function isMotion() {
      return this.physics.motion;
    }
    /**
     * @param {boolean} isMotion
     */

  }, {
    key: "setMotion",
    value: function setMotion(isMotion) {
      this.physics.motion = isMotion;
      isMotion && this.setFixed(false);
    }
    /**
     * Is the entity controlled
     * @return {boolean}
     */

  }, {
    key: "isControlled",
    value: function isControlled() {
      return this.controlled;
    }
    /**
     * Set the controlled flag
     * @param {boolean} value
     */

  }, {
    key: "setControlled",
    value: function setControlled(value) {
      this.controlled = value;
    }
    /**
     * Set velocity for physics props
     * @param {Object} velocity
     */

  }, {
    key: "setVelocity",
    value: function setVelocity(_ref) {
      var x = _ref.x,
          y = _ref.y;
      this.physics.velocity = new _Vector["default"]({
        x: x,
        y: y
      });
    }
    /**
     * Set the force for physics props
     * @param {Vector} force
     */

  }, {
    key: "setForce",
    value: function setForce(force) {
      this.physics.force = force;
    }
    /**
     * Set angular velocity for physics props
     * @param {Object} velocity
     */

  }, {
    key: "setAngularVelocity",
    value: function setAngularVelocity(velocity) {
      this.physics.angularVelocity = velocity;
    }
    /**
     * Get condition for dying (collision with another entity)
     */

  }, {
    key: "getDieCondition",
    value: function getDieCondition() {
      return this.condition.die.collisionWith;
    }
    /**
     * Set condition for dying (collision with another entity)
     */

  }, {
    key: "setDieCondition",
    value: function setDieCondition(entityId) {
      this.condition.die.collisionWith = entityId;
    }
    /**
     * Decide if the entity have to die
     * @param {PhysicsEngine} physicsEngine
     */

  }, {
    key: "haveToDie",
    value: function haveToDie(physicsEngine) {
      var entityId = this.getDieCondition();
      this.die |= entityId && physicsEngine.isCollide(this.getWorldId(), entityId);
    }
    /**
     * Is the entity dead
     */

  }, {
    key: "isDead",
    value: function isDead() {
      return this.die;
    }
    /**
     * Set the die flag
     * @param {Boolean} die
     */

  }, {
    key: "setDie",
    value: function setDie(die) {
      this.die = die;
    }
    /**
     * Get the WorldId (can be used by Engines to apply same
     * conditions for entities with th same worldId)
     * @return {number}
     */

  }, {
    key: "getWorldId",
    value: function getWorldId() {
      return this.worldId || this.id;
    }
    /**
     * Get the force position (center of the entity by default)
     */

  }, {
    key: "getForcePosition",
    value: function getForcePosition() {
      return new _Vector["default"]({
        x: 0,
        y: 0
      });
    }
    /**
     * Move the entity by distance related to a given point.
     * Move also attached entities
     * @param {EntityManager} entityManager
     * @param {Object} point relative position
     * @param {Object} target absolute position
     */

  }, {
    key: "moveRelativePointTo",
    value: function moveRelativePointTo(entityManager, point, target) {
      var diffDistance = {
        x: target.x - this.position.x - point.x,
        y: target.y - this.position.y - point.y
      };
      this.setPosition({
        x: this.position.x + diffDistance.x,
        y: this.position.y + diffDistance.y
      });
    }
    /**
     * Get attached entities
     * @param {EntityManager} entityManager
     */

  }, {
    key: "getAttachedEntities",
    value: function getAttachedEntities(entityManager) {
      if (this.attachedEntities === null) {
        this.attachedEntities = entityManager.getAttachedEntities(this);
      }

      return this.attachedEntities;
    }
    /**
     * Update collision filters for the physic engine
     * @param {PhysicsEngine} physicsEngine
     */

  }, {
    key: "updateCollisionFilters",
    value: function updateCollisionFilters(physicsEngine) {
      if (this.isPhyiscsLoaded) {
        physicsEngine.updateCollisionFilters(this);
      }
    }
    /**
     * Set the collision group
     * @param {Number} collisionGroup
     */

  }, {
    key: "setCollisionGroup",
    value: function setCollisionGroup(collisionGroup) {
      this.collision.group = collisionGroup;
    }
    /**
     * Set the collision mask
     * @param {Number} collisionMask
     */

  }, {
    key: "setCollisionMask",
    value: function setCollisionMask(collisionMask) {
      this.collision.mask = collisionMask;
    }
    /**
     * Update position for entities attached
     * @param {World} world
     * @param {PhysicsEngine} physicsEngine
     */

  }, {
    key: "updateJointPosition",
    value: function updateJointPosition(world, physicsEngine) {
      if (!this.isPhyiscsLoaded) {
        physicsEngine.updateJointPosition(world, this);
      }
    }
    /**
     * Get the relative position of a point inside the current entity
     * from a relative point inside a given entity
     * @param {Entity} entity
     * @param {Vector} point
     */

  }, {
    key: "getRelativeCenterPosition",
    value: function getRelativeCenterPosition(entity, point) {
      return this.toRelativeCenterPosition(entity.toAbsolutePosition(point));
    }
    /**
     * Update the style of the entity using data available on
     * tha application state (color, ...)
     */

  }, {
    key: "updateStyle",
    value: function updateStyle() {
      var color = _AppState["default"].get().data.color;

      color && (this.props.style.fillColor = color);
      return this;
    }
    /**
     * @param {Object} value
     */

  }, {
    key: "setCondition",
    value: function setCondition(value) {
      this.condition = value;
    }
    /**
     * @param {Object} value
     */

  }, {
    key: "setCollision",
    value: function setCollision(value) {
      this.collision = value;
    }
  }]);
  return EntityMotion;
}(_Entity2["default"]);

var _default = EntityMotion;
exports["default"] = _default;

},{"../state/AppState.js":160,"../utils/Vector.js":169,"./Entity.js":42,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/get":9,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],44:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _EntityMotion2 = _interopRequireDefault(require("./EntityMotion.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Virtual Entity can be used to manage entity's props
 */
var VirtualEntity = /*#__PURE__*/function (_EntityMotion) {
  (0, _inherits2["default"])(VirtualEntity, _EntityMotion);

  var _super = _createSuper(VirtualEntity);

  function VirtualEntity(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, VirtualEntity);
    _this = _super.call(this, props);
    _this.shape = _EntityMotion2["default"].shapes.VIRTUAL;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(VirtualEntity, [{
    key: "init",
    value: function init() {
      return true;
    }
    /**
     * @override
     */

  }, {
    key: "drawContext",
    value: function drawContext(dataContext) {}
  }]);
  return VirtualEntity;
}(_EntityMotion2["default"]);

var _default = VirtualEntity;
exports["default"] = _default;

},{"./EntityMotion.js":43,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],45:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _LineEntity2 = _interopRequireDefault(require("../shape/LineEntity.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Attach Entity (abstract class) used to attach two entities
 * Different type of attach are possible (constraint, point, ...)
 * @abstract
 */
var AttachEntity = /*#__PURE__*/function (_LineEntity) {
  (0, _inherits2["default"])(AttachEntity, _LineEntity);

  var _super = _createSuper(AttachEntity);

  function AttachEntity(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, AttachEntity);
    var physics = {
      stiffness: 1,
      angleA: null,
      angleB: null,
      angularStiffness: null
    };
    _this = _super.call(this, _objectSpread(_objectSpread({}, props), {}, {
      physics: physics
    }));
    _this.shape = _LineEntity2["default"].shapes.ATTACH;
    return _this;
  }

  return AttachEntity;
}(_LineEntity2["default"]);

var _default = AttachEntity;
exports["default"] = _default;

},{"../shape/LineEntity.js":50,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],46:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _JointEntity2 = _interopRequireDefault(require("./JointEntity.js"));

var _Color = _interopRequireDefault(require("../../../utils/Color.js"));

var _Vector = _interopRequireDefault(require("../../../utils/Vector.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Define an entity which represent a physics constraint (mouse constraint, ...)
 * @extends {JointEntity}
 * @property {{a: Entity, b: Entity}} entities
 * @property {{a: Vector, b: Vector}} points
 * @property {{x: number, y: number}|null} pointConstraint the point inside the entity B which describe
 *                                         the trigger of the constraint (like mouse click inside the entity)
 */
var ConstraintEntity = /*#__PURE__*/function (_JointEntity) {
  (0, _inherits2["default"])(ConstraintEntity, _JointEntity);

  var _super = _createSuper(ConstraintEntity);

  function ConstraintEntity(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, ConstraintEntity);
    _this = _super.call(this, props);
    _this.physics.stiffness = 0.1;
    _this.physics.angularStiffness = 1;
    _this.props.style = {
      color: "#".concat(_Color["default"].fromArrayInt([_this.id]))
    };
    _this.vertices = [new _Vector["default"]({
      x: 0,
      y: 0
    }), new _Vector["default"]({
      x: 0,
      y: 0
    })];
    _this.entities = {
      a: null,
      b: null
    };
    _this.attached = true;
    _this.clonable = false;
    _this.pointConstraint = null;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(ConstraintEntity, [{
    key: "setConstraintEntities",
    value: function setConstraintEntities() {
      return true;
    }
  }]);
  return ConstraintEntity;
}(_JointEntity2["default"]);

var _default = ConstraintEntity;
exports["default"] = _default;

},{"../../../utils/Color.js":163,"../../../utils/Vector.js":169,"./JointEntity.js":47,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],47:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _EntitySelector = _interopRequireDefault(require("../../../world/manager/EntitySelector.js"));

var _AttachEntity2 = _interopRequireDefault(require("./AttachEntity.js"));

var _Vector = _interopRequireDefault(require("../../../utils/Vector.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @property {Vector[]} vertices relative positions for entities A & B
 */
var JointEntity = /*#__PURE__*/function (_AttachEntity) {
  (0, _inherits2["default"])(JointEntity, _AttachEntity);

  var _super = _createSuper(JointEntity);

  function JointEntity() {
    var _this;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, JointEntity);
    props.style = props.style || {
      color: '#0000FF'
    };
    _this = _super.call(this, props);
    _this.vertices = [null, null];
    _this.entities = {
      a: null,
      b: null
    };
    _this.attached = false;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(JointEntity, [{
    key: "init",
    value: function init(world) {
      var dragDistance = this.setMeshPositionByDragDistance();
      return this.generatePoints(dragDistance) && this.setConstraintEntities(world);
    }
    /**
     * Calculate the size of the canvas using the drag distance
     * @param {Object} dragDistance
     */

  }, {
    key: "calculateSize",
    value: function calculateSize(dragDistance) {
      return {
        width: Math.abs(dragDistance.x),
        height: Math.abs(dragDistance.y)
      };
    }
    /**
     * Generate vertices from drag distance
     */

  }, {
    key: "generatePoints",
    value: function generatePoints(dragDistance) {
      this.size = this.calculateSize(dragDistance);

      if (this.size.width > 0 && this.size.height > 0) {
        this.clearBuffer();
        var pointX = Math.abs(dragDistance.x);
        var pointY = Math.abs(dragDistance.y);

        if (dragDistance.x * dragDistance.y < 0) {
          this.vertices = [new _Vector["default"]({
            x: pointX,
            y: 0
          }), new _Vector["default"]({
            x: 0,
            y: pointY
          })];
        } else {
          this.vertices = [new _Vector["default"]({
            x: 0,
            y: 0
          }), new _Vector["default"]({
            x: pointX,
            y: pointY
          })];
        }

        if (dragDistance.y < 0) {
          var point = this.vertices[0];
          this.vertices[0] = this.vertices[1];
          this.vertices[1] = point;
        }

        return this.vertices[0] && this.vertices[1];
      }

      return false;
    }
    /**
     * Find related entities using point a and b, and attach them to the constraint
     */

  }, {
    key: "setConstraintEntities",
    value: function setConstraintEntities(world) {
      var _this2 = this;

      var entitySelector = _EntitySelector["default"].get();

      this.entities.a = entitySelector.get(world, this.toAbsolutePosition(this.vertices[0]), _AttachEntity2["default"]);
      this.entities.b = entitySelector.getAll(world, this.toAbsolutePosition(this.vertices[1]), _AttachEntity2["default"]).find(function (entity) {
        return entity !== _this2.entities.a;
      });

      if (this.entities.a instanceof _AttachEntity2["default"]) {
        this.entities.a = null;
      }

      if (this.entities.b instanceof _AttachEntity2["default"]) {
        this.entities.b = null;
      }

      if (this.entities.a === this.entities.b) {
        this.entities.b = null;
      }

      this.entities.a && (this.entities.a.attachedEntities = null);
      this.entities.b && (this.entities.b.attachedEntities = null);
      return this.entities.a || this.entities.b;
    }
    /**
     * Update vertices (A, B) from an absolute positions
     * @param {Vector} pointA absolute position
     * @param {Vector} pointB absolute position
     */

  }, {
    key: "updatePoints",
    value: function updatePoints(pointA, pointB) {
      var dragDistance = {
        x: Math.floor(pointB.x - pointA.x),
        y: Math.floor(pointB.y - pointA.y)
      };

      if (this.generatePoints(dragDistance) && this.clearBuffer()) {
        var newX = pointA.x,
            newY = pointA.y;

        if (dragDistance.x <= 0) {
          newX = pointB.x;
        }

        if (dragDistance.y <= 0) {
          newY = pointB.y;
        }

        this.setPosition({
          x: parseInt(newX),
          y: parseInt(newY)
        });
      }
    }
    /**
     * @param {Entity} entityA
     * @param {Entity} entityB
     */

  }, {
    key: "setEntities",
    value: function setEntities(entityA, entityB) {
      this.entities.a = entityA;
      this.entities.b = entityB;
    }
  }]);
  return JointEntity;
}(_AttachEntity2["default"]);

var _default = JointEntity;
exports["default"] = _default;

},{"../../../utils/Vector.js":169,"../../../world/manager/EntitySelector.js":174,"./AttachEntity.js":45,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],48:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _ConstraintEntity2 = _interopRequireDefault(require("./ConstraintEntity.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {MouseConstraintEntity}
 * @extends {ConstraintEntity}
 */
var MouseConstraintEntity = /*#__PURE__*/function (_ConstraintEntity) {
  (0, _inherits2["default"])(MouseConstraintEntity, _ConstraintEntity);

  var _super = _createSuper(MouseConstraintEntity);

  function MouseConstraintEntity(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, MouseConstraintEntity);
    _this = _super.call(this, _objectSpread(_objectSpread({}, props), {}, {
      name: 'Mouse constraint'
    }));
    _this.visible = false;
    return _this;
  }

  return MouseConstraintEntity;
}(_ConstraintEntity2["default"]);

var _default = MouseConstraintEntity;
exports["default"] = _default;

},{"./ConstraintEntity.js":46,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],49:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _EntityMotion2 = _interopRequireDefault(require("../../EntityMotion.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var CircleEntity = /*#__PURE__*/function (_EntityMotion) {
  (0, _inherits2["default"])(CircleEntity, _EntityMotion);

  var _super = _createSuper(CircleEntity);

  function CircleEntity(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, CircleEntity);
    _this = _super.call(this, props);
    _this.shape = _EntityMotion2["default"].shapes.CIRCLE;
    _this.radius = 0;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(CircleEntity, [{
    key: "init",
    value: function init() {
      var dragDistance = this.setMeshPositionByDragDistance();
      this.size = {
        width: Math.abs(dragDistance.x),
        height: Math.abs(dragDistance.x)
      };
      return true;
    }
    /**
     * Draw the context
     * @param {{center: {x: number, y: number}, context: OffscreenCanvasRenderingContext2D}} dataContext
     */

  }, {
    key: "drawContext",
    value: function drawContext(dataContext) {
      var center = dataContext.center,
          context = dataContext.context;
      var sw = this.size.width;
      this.radius = Math.abs(sw / 2 - 1);
      context.ellipse(center.x, center.y, this.radius, this.radius, 0, 0, 2 * Math.PI);
    }
    /**
     * Calculate the largest rectangle for given rotation and size
     * @param {number} angleRadian
     * @param {Object} size
     */

  }, {
    key: "getLargestRectangle",
    value: function getLargestRectangle(angleRadian, size) {
      return size;
    }
    /**
     * @override
     */

  }, {
    key: "includes",
    value: function includes(point) {
      var _this$fromAbsolutePos = this.fromAbsolutePosition(point),
          x = _this$fromAbsolutePos.x,
          y = _this$fromAbsolutePos.y;

      var center = this.getCenter();
      return Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2) < Math.pow(this.radius, 2);
    }
  }]);
  return CircleEntity;
}(_EntityMotion2["default"]);

var _default = CircleEntity;
exports["default"] = _default;

},{"../../EntityMotion.js":43,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],50:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _EntityMotion2 = _interopRequireDefault(require("../../EntityMotion.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var LineEntity = /*#__PURE__*/function (_EntityMotion) {
  (0, _inherits2["default"])(LineEntity, _EntityMotion);

  var _super = _createSuper(LineEntity);

  function LineEntity(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, LineEntity);
    _this = _super.call(this, props);
    _this.shape = _EntityMotion2["default"].shapes.LINE;
    _this.vertices = [];
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(LineEntity, [{
    key: "init",
    value: function init() {
      var dragDistance = this.setMeshPositionByDragDistance();
      this.size = {
        width: Math.abs(dragDistance.x),
        height: Math.abs(dragDistance.y)
      };

      if (dragDistance.x * dragDistance.y < 0) {
        this.vertices = [{
          x: this.size.width,
          y: 0
        }, {
          x: 0,
          y: this.size.height
        }];
      } else {
        this.vertices = [{
          x: 0,
          y: 0
        }, {
          x: this.size.width,
          y: this.size.height
        }];
      }

      return true;
    }
    /**
     * @override
     */

  }, {
    key: "drawContext",
    value: function drawContext(dataContext) {
      var context = dataContext.context;
      var x0 = this.vertices[0].x,
          y0 = this.vertices[0].y;
      var x1 = this.vertices[1].x,
          y1 = this.vertices[1].y;
      context.beginPath();
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
    }
    /**
     * @return {number}
     */

  }, {
    key: "getLineWidth",
    value: function getLineWidth() {
      return Math.abs(this.vertices[1].x - this.vertices[0].x);
    }
    /**
     * @return {number}
     */

  }, {
    key: "getLineHeight",
    value: function getLineHeight() {
      return Math.abs(this.vertices[1].y - this.vertices[0].y);
    }
    /**
     * @override
     */

  }, {
    key: "toCenterPosition",
    value: function toCenterPosition() {
      return {
        x: this.position.x + this.mesh.size.width / 2,
        y: this.position.y + this.mesh.size.height / 2
      };
    }
    /**
     * @override
     */

  }, {
    key: "fromCenterPosition",
    value: function fromCenterPosition(position) {
      return {
        x: position.x - this.mesh.size.width / 2,
        y: position.y - this.mesh.size.height / 2
      };
    }
  }]);
  return LineEntity;
}(_EntityMotion2["default"]);

var _default = LineEntity;
exports["default"] = _default;

},{"../../EntityMotion.js":43,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],51:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _EntityMotion2 = _interopRequireDefault(require("../../EntityMotion.js"));

var _Window = _interopRequireDefault(require("../../../core/Window.js"));

var _Vertex = _interopRequireDefault(require("../../../utils/Vertex.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var PolyEntity = /*#__PURE__*/function (_EntityMotion) {
  (0, _inherits2["default"])(PolyEntity, _EntityMotion);

  var _super = _createSuper(PolyEntity);

  function PolyEntity(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, PolyEntity);
    _this = _super.call(this, props);
    _this.shape = _EntityMotion2["default"].shapes.POLY;
    _this.vertices = [];
    _this.nbPoints = 0;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(PolyEntity, [{
    key: "init",
    value: function init() {
      this.generatePoints();
      var minPoint = this.getMinPoint();
      this.setMeshPosition({
        x: minPoint.x,
        y: minPoint.y
      });
      this.calculateSize();
      return true;
    }
    /**
     * Get the min point
     */

  }, {
    key: "getMinPoint",
    value: function getMinPoint() {
      var x = this.vertices.reduce(function (minX, point) {
        return point.x < minX ? point.x : minX;
      }, 99999);
      var y = this.vertices.reduce(function (minY, point) {
        return point.y < minY ? point.y : minY;
      }, 99999);
      return {
        x: x,
        y: y
      };
    }
    /**
     * Get the max point
     */

  }, {
    key: "getMaxPoint",
    value: function getMaxPoint() {
      var x = this.vertices.reduce(function (maxX, point) {
        return point.x > maxX ? point.x : maxX;
      }, 0);
      var y = this.vertices.reduce(function (maxY, point) {
        return point.y > maxY ? point.y : maxY;
      }, 0);
      return {
        x: x,
        y: y
      };
    }
    /**
     * Add vertices to the poly based on the click position
     */

  }, {
    key: "generatePoints",
    value: function generatePoints() {
      var window = _Window["default"].get();

      var position = window.mouse.position;
      var currentPosition = window.mouse.currentPosition;

      if (!this.vertices.find(function (point) {
        return point.x === position.x && point.y === position.y;
      })) {
        this.vertices[this.nbPoints] = position;
        this.nbPoints = this.vertices.length;
      } else {
        this.vertices[this.nbPoints] = currentPosition;
      }
    }
    /**
     * @override
     */

  }, {
    key: "drawContext",
    value: function drawContext(dataContext) {
      var context = dataContext.context;
      this.drawPoints(context);
    }
    /**
     * @param {OffscreenCanvasRenderingContext2D} context
     */

  }, {
    key: "drawPoints",
    value: function drawPoints(context) {
      context.beginPath();
      this.vertices.forEach(function (point, iPoint) {
        if (!iPoint) {
          context.moveTo(point.x, point.y);
        } else {
          context.lineTo(point.x, point.y);
        }
      });
      context.closePath();
    }
    /**
     * @param {Vector[]} vertices
     */

  }, {
    key: "setPoints",
    value: function setPoints(vertices) {
      this.vertices = vertices;
      this.calculateSize();
    }
    /**
     * Do not calculate Size if it's defined in the props
     */

  }, {
    key: "calculateSize",
    value: function calculateSize() {
      if (this.props.size) {
        this.size = this.props.size;
      } else {
        var minPoint = this.getMinPoint();
        var maxPoint = this.getMaxPoint();
        this.size = {
          width: maxPoint.x - minPoint.x,
          height: maxPoint.y - minPoint.y
        };
      }
    }
    /**
     * Convert vertices to relative position of the Entity
     */

  }, {
    key: "convertPointToRelPosition",
    value: function convertPointToRelPosition() {
      var minPoint = this.getMinPoint();
      this.vertices = this.vertices.map(function (point) {
        return {
          x: point.x - minPoint.x,
          y: point.y - minPoint.y
        };
      });
    }
    /**
     * @override
     */

  }, {
    key: "getCenter",
    value: function getCenter() {
      return _Vertex["default"].getCenter(this.vertices);
    }
    /**
     * @override
     */

  }, {
    key: "loadVertices",
    value: function loadVertices() {
      return this.vertices;
    }
    /**
     * Trigger other drawing instruction when the drawing is ended
     */

  }, {
    key: "close",
    value: function close() {
      this.vertices.push(this.vertices[0]);
      this.build();
      this.convertPointToRelPosition();
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(PolyEntity.prototype), "close", this).call(this);
    }
  }]);
  return PolyEntity;
}(_EntityMotion2["default"]);

var _default = PolyEntity;
exports["default"] = _default;

},{"../../../core/Window.js":41,"../../../utils/Vertex.js":170,"../../EntityMotion.js":43,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":9,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],52:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _EntityMotion2 = _interopRequireDefault(require("../../EntityMotion.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var RectEntity = /*#__PURE__*/function (_EntityMotion) {
  (0, _inherits2["default"])(RectEntity, _EntityMotion);

  var _super = _createSuper(RectEntity);

  function RectEntity(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, RectEntity);
    _this = _super.call(this, props);
    _this.shape = _EntityMotion2["default"].shapes.RECT;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(RectEntity, [{
    key: "init",
    value: function init() {
      var dragDistance = this.setMeshPositionByDragDistance();
      this.size = {
        width: Math.abs(dragDistance.x),
        height: Math.abs(dragDistance.y)
      };
      return true;
    }
    /**
     * Draw the context
     * @param {DataContext} dataContext
     */

  }, {
    key: "drawContext",
    value: function drawContext(dataContext) {
      var context = dataContext.context;
      context.rect(0, 0, this.size.width, this.size.height);
    }
  }]);
  return RectEntity;
}(_EntityMotion2["default"]);

var _default = RectEntity;
exports["default"] = _default;

},{"../../EntityMotion.js":43,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],53:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _PolyEntity2 = _interopRequireDefault(require("../shape/PolyEntity.js"));

var _PerlinNoise = _interopRequireDefault(require("../../../utils/PerlinNoise.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var NoiseEntity = /*#__PURE__*/function (_PolyEntity) {
  (0, _inherits2["default"])(NoiseEntity, _PolyEntity);

  var _super = _createSuper(NoiseEntity);

  function NoiseEntity(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, NoiseEntity);
    _this = _super.call(this, _objectSpread(_objectSpread({}, props), {}, {
      name: 'Noise Terrain'
    }));

    if (!_this.noiseConfigs) {
      throw new TypeError('Configs must be set to setup the noises');
    }

    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(NoiseEntity, [{
    key: "init",
    value: function init() {
      this.setFixed(true);
      return true;
    }
    /**
     * @override
     */

  }, {
    key: "drawContext",
    value: function drawContext(dataContext) {
      var perlinNoise = new _PerlinNoise["default"](this.noiseConfigs);
      var points = [];
      var step = 10;
      var size = this.props.size;
      points.push({
        x: 0,
        y: size.height
      });

      for (var i = 0; i <= size.width; i += step) {
        var height = perlinNoise.getPerlinNoise(this.position.x + i, 0);
        points.push({
          x: i,
          y: Math.floor(height)
        });
      }

      points.push({
        x: size.width,
        y: points[points.length - 1].y
      });
      points.push({
        x: size.width,
        y: size.height
      });
      this.setPoints(points);
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(NoiseEntity.prototype), "drawContext", this).call(this, dataContext);
    }
  }]);
  return NoiseEntity;
}(_PolyEntity2["default"]);

var _default = NoiseEntity;
exports["default"] = _default;

},{"../../../utils/PerlinNoise.js":168,"../shape/PolyEntity.js":51,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/get":9,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],54:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _EntityMotion2 = _interopRequireDefault(require("../../EntityMotion.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var PlatformEntity = /*#__PURE__*/function (_EntityMotion) {
  (0, _inherits2["default"])(PlatformEntity, _EntityMotion);

  var _super = _createSuper(PlatformEntity);

  function PlatformEntity(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, PlatformEntity);
    _this = _super.call(this, _objectSpread(_objectSpread({}, props), {}, {
      name: 'Plain Terrain'
    }));
    _this.shape = _EntityMotion2["default"].shapes.RECT;
    _this.isDrawRuler = true;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(PlatformEntity, [{
    key: "init",
    value: function init(world) {
      this.setFixed(true);
      return true;
    }
    /**
     * @override
     */

  }, {
    key: "drawContext",
    value: function drawContext(dataContext) {
      var context = dataContext.context;
      context.rect(0, 0, this.size.width, this.size.height);
      this.isDrawRuler && this.drawRuler(context, this.size.width);
    }
    /**
     * Draw a ruler
     * @param {OffscreenCanvasRenderingContext2D} context
     * @param {Number} sw
     */

  }, {
    key: "drawRuler",
    value: function drawRuler(context, sw) {
      var stepRule = 40;

      for (var xRule = stepRule; xRule < sw; xRule += stepRule) {
        context.fillText(xRule.toString(), xRule, 20);
      }
    }
  }]);
  return PlatformEntity;
}(_EntityMotion2["default"]);

var _default = PlatformEntity;
exports["default"] = _default;

},{"../../EntityMotion.js":43,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],55:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _StateManager = _interopRequireDefault(require("../state/StateManager.js"));

var ExceptionHandler = /*#__PURE__*/function () {
  function ExceptionHandler() {
    (0, _classCallCheck2["default"])(this, ExceptionHandler);
  }

  (0, _createClass2["default"])(ExceptionHandler, [{
    key: "handle",

    /**
     * @type {ExceptionHandler}
     */

    /**
     * @param {Error} e
     */
    value: function handle(e) {
      _StateManager["default"].get().stopAll();

      if (e instanceof TypeError) {
        throw e;
      }

      alert(e.message);
    }
    /**
     * @return {ExceptionHandler}
     */

  }], [{
    key: "get",
    value: function get() {
      if (!this.instance) {
        this.instance = new this();
      }

      return this.instance;
    }
  }]);
  return ExceptionHandler;
}();

(0, _defineProperty2["default"])(ExceptionHandler, "instance", void 0);
var _default = ExceptionHandler;
exports["default"] = _default;

},{"../state/StateManager.js":161,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12}],56:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {PhysicError}
 * @extends {Error}
 */
var PhysicError = /*#__PURE__*/function (_Error) {
  (0, _inherits2["default"])(PhysicError, _Error);

  var _super = _createSuper(PhysicError);

  function PhysicError(message) {
    (0, _classCallCheck2["default"])(this, PhysicError);
    return _super.call(this, message);
  }

  return PhysicError;
}( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

var _default = PhysicError;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/helpers/wrapNativeSuper":23}],57:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

/**
 * Define the layout of the screen
 */
var Layout = function Layout() {
  (0, _classCallCheck2["default"])(this, Layout);
};

Layout.zone = {
  LEFT: 'left',
  TOP: 'top',
  RIGHT: 'right',
  BOTTOM: 'bottom'
};
Layout.type = {
  DRAW: 'draw',
  ACTION: 'action',
  STYLE: 'style',
  PANEL: 'panel',
  STYLE_COLOR: 'style_color',
  LAYER_ENTITY: 'layer_entity',
  LAYER_ACTION: 'layer_action',
  LIST_ELEMENT: 'list_element',
  TEXT: 'text',
  FORM: 'form',
  FORM_ELEMENT: 'form_element',
  GRAPH: 'graph',
  ICON: 'icon'
};
Layout.form = {
  CHECKBOX: 'checkbox',
  TEXT: 'text',
  DROPDOWN: 'dropdown',
  FILE: 'file'
};
var _default = Layout;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/interopRequireDefault":12}],58:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _CircleMenuItem = _interopRequireDefault(require("./items/draw/CircleMenuItem.js"));

var _RectMenuItem = _interopRequireDefault(require("./items/draw/RectMenuItem.js"));

var _JointMenuItem = _interopRequireDefault(require("./items/draw/JointMenuItem.js"));

var _AttachPointMenuItem = _interopRequireDefault(require("./items/draw/AttachPointMenuItem.js"));

var _SelectorMenuItem = _interopRequireDefault(require("./items/draw/SelectorMenuItem.js"));

var _NewProjectMenuItem = _interopRequireDefault(require("./items/project/NewProjectMenuItem.js"));

var _SaveProjectMenuItem = _interopRequireDefault(require("./items/project/SaveProjectMenuItem.js"));

var _LoadProjectMenuItem = _interopRequireDefault(require("./items/project/LoadProjectMenuItem.js"));

var _ExportProjectMenuItem = _interopRequireDefault(require("./items/project/ExportProjectMenuItem.js"));

var _SimulateStartMenuItem = _interopRequireDefault(require("./items/action/SimulateStartMenuItem.js"));

var _SimulateStopMenuItem = _interopRequireDefault(require("./items/action/SimulateStopMenuItem.js"));

var _DeleteMenuItem = _interopRequireDefault(require("./items/action/DeleteMenuItem.js"));

var _DuplicateMenuItem = _interopRequireDefault(require("./items/action/DuplicateMenuItem.js"));

var _UndoMenuItem = _interopRequireDefault(require("./items/action/UndoMenuItem.js"));

var _MoveUpMenuItem = _interopRequireDefault(require("./items/action/MoveUpMenuItem.js"));

var _MoveDownMenuItem = _interopRequireDefault(require("./items/action/MoveDownMenuItem.js"));

var _LockMenuItem = _interopRequireDefault(require("./items/action/LockMenuItem.js"));

var _UnlockMenuItem = _interopRequireDefault(require("./items/action/UnlockMenuItem.js"));

var _HideMenuItem = _interopRequireDefault(require("./items/action/HideMenuItem.js"));

var _ShowMenuItem = _interopRequireDefault(require("./items/action/ShowMenuItem.js"));

var _RotateUpMenuItem = _interopRequireDefault(require("./items/action/RotateUpMenuItem.js"));

var _MenuItemUI = _interopRequireDefault(require("../renderer/ui/MenuItemUI.js"));

var _LayerMenuItem = _interopRequireDefault(require("./items/entity/LayerMenuItem.js"));

var _AiGeneticMenuItem = _interopRequireDefault(require("./items/genetic/AiGeneticMenuItem.js"));

var _EntityMenuItem = _interopRequireDefault(require("./items/entity/EntityMenuItem.js"));

var _StyleMenuItem = _interopRequireDefault(require("./items/style/StyleMenuItem.js"));

var _ConditionMenuItem = _interopRequireDefault(require("./items/condition/ConditionMenuItem.js"));

var _AppMenuItem = _interopRequireDefault(require("./items/app/AppMenuItem.js"));

var _TerrainMenuItem = _interopRequireDefault(require("./items/terrain/TerrainMenuItem.js"));

var _CameraMenuItem = _interopRequireDefault(require("./items/camera/CameraMenuItem.js"));

var _TextureMenuItem = _interopRequireDefault(require("./items/texture/TextureMenuItem.js"));

/**
 * Define all menu items
 * @property {MenuItem[]} types
 * @property {MenuItemUI[]} items
 */
var Menu = /*#__PURE__*/function () {
  function Menu() {
    (0, _classCallCheck2["default"])(this, Menu);
    this.types = [//LEFT
    new _SelectorMenuItem["default"](), new _CircleMenuItem["default"](), new _RectMenuItem["default"](), new _JointMenuItem["default"](), new _AttachPointMenuItem["default"](), new _SimulateStartMenuItem["default"](), new _SimulateStopMenuItem["default"](), //TOP
    new _NewProjectMenuItem["default"](), new _LoadProjectMenuItem["default"](), new _SaveProjectMenuItem["default"](), new _ExportProjectMenuItem["default"](), new _DeleteMenuItem["default"](), new _DuplicateMenuItem["default"](), new _UndoMenuItem["default"](), new _MoveUpMenuItem["default"](), new _MoveDownMenuItem["default"](), new _LockMenuItem["default"](), new _UnlockMenuItem["default"](), new _HideMenuItem["default"](), new _ShowMenuItem["default"](), new _RotateUpMenuItem["default"](), //RIGHT
    new _LayerMenuItem["default"](), new _StyleMenuItem["default"](), new _EntityMenuItem["default"](), new _ConditionMenuItem["default"](), new _AiGeneticMenuItem["default"](), new _TerrainMenuItem["default"](), new _TextureMenuItem["default"](), new _CameraMenuItem["default"](), //BOTTOM
    new _AppMenuItem["default"]()];
    this.items = [];
    this.setup();
  }
  /**
   * Setup the items list which calculate the position of the each item
   * in the screen.
   */


  (0, _createClass2["default"])(Menu, [{
    key: "setup",
    value: function setup() {
      this.items = [];

      for (var iType in this.types) {
        var type = this.types[iType];
        type.menu = this;
        this.prepare(type);
      }
    }
    /**
     * Prepare the Menu and sub menu for rendering
     * @param {MenuItem} item
     * @param {Object} parent
     */

  }, {
    key: "prepare",
    value: function prepare(item) {
      var _this = this;

      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (item.isValid()) {
        var itemsZone = this.items.filter(function (pItem) {
          return pItem.element.zone === item.zone;
        });
        var existItem = this.items.find(function (pItem) {
          return pItem.element === item;
        });
        var lastIndex = itemsZone.length;

        if (existItem) {
          existItem.index = itemsZone.findIndex(function (pItem) {
            return pItem.element === item;
          });
        }

        var resultItem = existItem || new _MenuItemUI["default"](item, lastIndex, parent);
        !existItem && this.items.push(resultItem);

        if (item.items) {
          item.items.forEach(function (pItem) {
            return _this.prepare(pItem, resultItem);
          });
        }
      }
    }
    /**
     * Find menu item by index and zone
     * @param {Number} index (must start from 0)
     * @param {String} zone
     */

  }, {
    key: "findItemByZone",
    value: function findItemByZone(index, zone) {
      var itemsZone = this.items.filter(function (pItem) {
        return pItem.element.zone === zone;
      });
      return itemsZone[index];
    }
    /**
     * @param {MenuItem} element
     */

  }, {
    key: "findItemByElement",
    value: function findItemByElement(element) {
      return this.items.find(function (pItem) {
        return pItem.element === element;
      });
    }
    /**
     * Clean all menu items that is not valid anymore.
     */

  }, {
    key: "clean",
    value: function clean() {
      this.items = this.items.filter(function (item) {
        return item.element.isValid();
      });
    }
    /**
     * Select item in the menu.
     * @param {MenuItemUI} menuItem
     */

  }, {
    key: "selectItem",
    value: function selectItem(menuItem) {
      for (var iItem in this.items) {
        var item = this.items[iItem];

        if (menuItem && item.element.isSelected()) {
          menuItem !== item && item.element.stop();
        }

        if (menuItem && item.element === menuItem.element) {
          item.element.run();
        }
      }
    }
    /**
     * @return {MenuItemUI}
     */

  }, {
    key: "getSelected",
    value: function getSelected() {
      return this.items.find(function (item) {
        return item.element.isSelected();
      });
    }
  }, {
    key: "update",
    value: function update() {
      this.types.forEach(function (type) {
        return type.isValid() && type.update();
      });
      this.setup();
    }
    /**
     * Get Previous menu item
     * @param {MenuItem} type
     */

  }, {
    key: "getPrevItem",
    value: function getPrevItem(type) {
      var index = this.types.findIndex(function (pType) {
        return pType === type;
      });
      var element = this.types[index - 1];
      return this.items.find(function (pItem) {
        return pItem.element === element;
      });
    }
    /**
     * Set the UI Renderer (used to locate items in the layout)
     * @param {UIRenderer} uiRenderer
     */

  }, {
    key: "setUIRenderer",
    value: function setUIRenderer(uiRenderer) {
      this.uiRenderer = uiRenderer;
    }
    /**
     * @return {UIRenderer}
     */

  }, {
    key: "getUIRenderer",
    value: function getUIRenderer() {
      return this.uiRenderer;
    }
  }], [{
    key: "get",
    value: function get() {
      if (!Menu.instance) {
        Menu.instance = new Menu();
      }

      return Menu.instance;
    }
  }]);
  return Menu;
}();

Menu.instance = null;
var _default = Menu;
exports["default"] = _default;

},{"../renderer/ui/MenuItemUI.js":152,"./items/action/DeleteMenuItem.js":60,"./items/action/DuplicateMenuItem.js":61,"./items/action/HideMenuItem.js":62,"./items/action/LockMenuItem.js":63,"./items/action/MoveDownMenuItem.js":64,"./items/action/MoveUpMenuItem.js":65,"./items/action/RotateUpMenuItem.js":66,"./items/action/ShowMenuItem.js":67,"./items/action/SimulateStartMenuItem.js":68,"./items/action/SimulateStopMenuItem.js":69,"./items/action/UndoMenuItem.js":70,"./items/action/UnlockMenuItem.js":71,"./items/app/AppMenuItem.js":72,"./items/camera/CameraMenuItem.js":73,"./items/condition/ConditionMenuItem.js":76,"./items/draw/AttachPointMenuItem.js":77,"./items/draw/CircleMenuItem.js":78,"./items/draw/JointMenuItem.js":79,"./items/draw/RectMenuItem.js":80,"./items/draw/SelectorMenuItem.js":81,"./items/entity/EntityMenuItem.js":82,"./items/entity/LayerMenuItem.js":83,"./items/genetic/AiGeneticMenuItem.js":97,"./items/project/ExportProjectMenuItem.js":101,"./items/project/LoadProjectMenuItem.js":102,"./items/project/NewProjectMenuItem.js":103,"./items/project/SaveProjectMenuItem.js":104,"./items/style/StyleMenuItem.js":105,"./items/terrain/TerrainMenuItem.js":108,"./items/texture/TextureMenuItem.js":117,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],59:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _StateManager = _interopRequireDefault(require("../state/StateManager.js"));

var _Maths = _interopRequireDefault(require("../utils/Maths.js"));

/**
 * Define an item in the menu
 * @abstract
 *
 * @property {MenuItem|Menu} parent
 * @property {{items: MenuItem[]}} items
 * @property {MenuItem} element
 * @property {string} stateCode
 * @property {string} zone
 * @property {string} type
 * @property {callback} value The default value
 * @property {callback} event The event bound to the field
 */
var MenuItem = /*#__PURE__*/function () {
  function MenuItem(props) {
    (0, _classCallCheck2["default"])(this, MenuItem);
    this.props = props;

    if (props.stateCode === undefined) {
      throw new TypeError('State code for MenuItem is required!');
    }

    if (props.zone === undefined) {
      throw new TypeError('Zone for MenuItem is required!');
    }

    if (props.type === undefined) {
      throw new TypeError('Type for MenuItem is required!');
    }

    this.stateManager = _StateManager["default"].get();
    this.zone = props.zone;
    this.type = props.type;
    this.data = {};
    this.menu = null;
    this.id = props.id || _Maths["default"].generateId();
    this.stateCode = props.stateCode;
  }
  /**
   * Define if the menu is selected
   * @return {boolean}
   */


  (0, _createClass2["default"])(MenuItem, [{
    key: "isSelected",
    value: function isSelected() {
      return this.stateCode && this.hasState(this.stateCode, this.id);
    }
    /**
     * Run the action when the item is trigerred
     */

  }, {
    key: "run",
    value: function run() {
      this.stateCode && this.startState();
    }
    /**
     * Update the items for the menu
     */

  }, {
    key: "update",
    value: function update() {
      this.items && this.items.forEach(function (item) {
        return item.isValid() && item.update();
      });
    }
    /**
     * Is menu item valid
     * @return {boolean}
     */

  }, {
    key: "isValid",
    value: function isValid() {
      return (!this.parent || this.parent.items.includes(this)) && !this.stateManager.isRunning();
    }
    /**
     * Stop the action when the item is unselected
     */

  }, {
    key: "stop",
    value: function stop() {
      this.stopState();
    }
    /**
     * Start an action by type and data (state)
     */

  }, {
    key: "startState",
    value: function startState() {
      this.stateManager.startState(this.stateCode, this.id, this.data);
    }
    /**
     * Stop an action by type (state)
     */

  }, {
    key: "stopState",
    value: function stopState() {
      this.stateManager.stopState(this.stateCode, this.id);
    }
    /**
     * Is state has action of given type/id
     * @param {string} type
     * @param {number} id
     * @return {boolean}
     */

  }, {
    key: "hasState",
    value: function hasState(type, id) {
      return this.stateManager.hasState(type, id);
    }
    /**
     * Get previous item
     * @return {MenuItem}
     */

  }, {
    key: "getPrevItem",
    value: function getPrevItem() {
      return this.menu.getPrevItem(this);
    }
  }]);
  return MenuItem;
}();
/**
 * The event to call
 * @callback callback
 */


var _default = MenuItem;
exports["default"] = _default;

},{"../state/StateManager.js":161,"../utils/Maths.js":165,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],60:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var DeleteMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(DeleteMenuItem, _MenuItem);

  var _super = _createSuper(DeleteMenuItem);

  function DeleteMenuItem() {
    (0, _classCallCheck2["default"])(this, DeleteMenuItem);
    return _super.call(this, {
      name: 'trash-alt',
      title: 'Delete',
      stateCode: 'ACTION_DELETE',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return DeleteMenuItem;
}(_MenuItem2["default"]);

var _default = DeleteMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],61:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var DuplicateMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(DuplicateMenuItem, _MenuItem);

  var _super = _createSuper(DuplicateMenuItem);

  function DuplicateMenuItem() {
    (0, _classCallCheck2["default"])(this, DuplicateMenuItem);
    return _super.call(this, {
      name: 'copy',
      title: 'Duplicate',
      stateCode: 'ACTION_DUPLICATE',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return DuplicateMenuItem;
}(_MenuItem2["default"]);

var _default = DuplicateMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],62:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Hide selected entities
 */
var HideMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(HideMenuItem, _MenuItem);

  var _super = _createSuper(HideMenuItem);

  function HideMenuItem() {
    (0, _classCallCheck2["default"])(this, HideMenuItem);
    return _super.call(this, {
      name: 'eye-slash',
      title: 'Hide',
      stateCode: 'ACTION_HIDE',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return HideMenuItem;
}(_MenuItem2["default"]);

var _default = HideMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],63:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Lock entities for modification (move, attach, ...)
 */
var LockMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(LockMenuItem, _MenuItem);

  var _super = _createSuper(LockMenuItem);

  function LockMenuItem() {
    (0, _classCallCheck2["default"])(this, LockMenuItem);
    return _super.call(this, {
      name: 'lock',
      title: 'Lock',
      stateCode: 'ACTION_LOCK',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return LockMenuItem;
}(_MenuItem2["default"]);

var _default = LockMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],64:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Move down entities in z-index
 */
var MoveDownMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(MoveDownMenuItem, _MenuItem);

  var _super = _createSuper(MoveDownMenuItem);

  function MoveDownMenuItem() {
    (0, _classCallCheck2["default"])(this, MoveDownMenuItem);
    return _super.call(this, {
      name: 'arrow-down',
      title: 'Move down',
      stateCode: 'ACTION_MOVE_DOWN',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return MoveDownMenuItem;
}(_MenuItem2["default"]);

var _default = MoveDownMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],65:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Move up entities in z-index
 */
var MoveUpMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(MoveUpMenuItem, _MenuItem);

  var _super = _createSuper(MoveUpMenuItem);

  function MoveUpMenuItem() {
    (0, _classCallCheck2["default"])(this, MoveUpMenuItem);
    return _super.call(this, {
      name: 'arrow-up',
      title: 'Move up',
      stateCode: 'ACTION_MOVE_UP',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return MoveUpMenuItem;
}(_MenuItem2["default"]);

var _default = MoveUpMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],66:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var RotateUpMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(RotateUpMenuItem, _MenuItem);

  var _super = _createSuper(RotateUpMenuItem);

  function RotateUpMenuItem() {
    (0, _classCallCheck2["default"])(this, RotateUpMenuItem);
    return _super.call(this, {
      name: 'redo',
      title: 'Rotate',
      stateCode: 'ACTION_ROTATE_UP',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return RotateUpMenuItem;
}(_MenuItem2["default"]);

var _default = RotateUpMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],67:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Show selected entities
 */
var ShowMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(ShowMenuItem, _MenuItem);

  var _super = _createSuper(ShowMenuItem);

  function ShowMenuItem() {
    (0, _classCallCheck2["default"])(this, ShowMenuItem);
    return _super.call(this, {
      name: 'eye',
      title: 'Show',
      stateCode: 'ACTION_SHOW',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return ShowMenuItem;
}(_MenuItem2["default"]);

var _default = ShowMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],68:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var SimulateStartMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(SimulateStartMenuItem, _MenuItem);

  var _super = _createSuper(SimulateStartMenuItem);

  function SimulateStartMenuItem() {
    (0, _classCallCheck2["default"])(this, SimulateStartMenuItem);
    return _super.call(this, {
      name: 'play',
      title: 'Start the simulation',
      stateCode: 'SIMULATE',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.LEFT
    });
  }

  return SimulateStartMenuItem;
}(_MenuItem2["default"]);

var _default = SimulateStartMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],69:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var SimulateStopMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(SimulateStopMenuItem, _MenuItem);

  var _super = _createSuper(SimulateStopMenuItem);

  function SimulateStopMenuItem() {
    (0, _classCallCheck2["default"])(this, SimulateStopMenuItem);
    return _super.call(this, {
      name: 'stop-circle',
      title: 'Stop the simulation',
      stateCode: 'SIMULATE',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.LEFT
    });
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(SimulateStopMenuItem, [{
    key: "isValid",
    value: function isValid() {
      return this.stateManager.isRunning();
    }
  }]);
  return SimulateStopMenuItem;
}(_MenuItem2["default"]);

var _default = SimulateStopMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],70:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var UndoMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(UndoMenuItem, _MenuItem);

  var _super = _createSuper(UndoMenuItem);

  function UndoMenuItem() {
    (0, _classCallCheck2["default"])(this, UndoMenuItem);
    return _super.call(this, {
      name: 'reply',
      title: 'Undo',
      stateCode: 'ACTION_UNDO',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return UndoMenuItem;
}(_MenuItem2["default"]);

var _default = UndoMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],71:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Lock entities for modification (move, attach, ...)
 */
var UnlockMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(UnlockMenuItem, _MenuItem);

  var _super = _createSuper(UnlockMenuItem);

  function UnlockMenuItem() {
    (0, _classCallCheck2["default"])(this, UnlockMenuItem);
    return _super.call(this, {
      name: 'unlock',
      title: 'Unlock',
      stateCode: 'ACTION_UNLOCK',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return UnlockMenuItem;
}(_MenuItem2["default"]);

var _default = UnlockMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],72:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * AppMenuItem Menu Item
 * Menu responsible for managing application information, props, ...
 */
var AppMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(AppMenuItem, _MenuItem);

  var _super = _createSuper(AppMenuItem);

  function AppMenuItem() {
    var _this;

    (0, _classCallCheck2["default"])(this, AppMenuItem);
    _this = _super.call(this, {
      name: 'Information',
      stateCode: '',
      type: _Layout["default"].type.TEXT,
      zone: _Layout["default"].zone.BOTTOM
    });
    _this.startTimeFPS = Date.now();
    _this.nbFrame = 0;
    _this.fps = 0;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(AppMenuItem, [{
    key: "update",
    value: function update() {
      this.updateFPS();
      this.text = ["FPS : ".concat(this.fps)];
    }
    /**
     * Update the FPS and show it in the title
     */

  }, {
    key: "updateFPS",
    value: function updateFPS() {
      var deltaTime = (Date.now() - this.startTimeFPS) / 1000;

      if (deltaTime > 1) {
        this.fps = Math.floor(this.nbFrame / deltaTime);
        this.nbFrame = 0;
        this.startTimeFPS = Date.now();
      } else {
        this.nbFrame++;
      }
    }
    /**
     * @override
     */

  }, {
    key: "isValid",
    value: function isValid() {
      return true;
    }
  }]);
  return AppMenuItem;
}(_MenuItem2["default"]);

var _default = AppMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],73:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _PropsFormMenuItem = _interopRequireDefault(require("./PropsFormMenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Menu responsible for managing camera properties
 */
var CameraMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(CameraMenuItem, _MenuItem);

  var _super = _createSuper(CameraMenuItem);

  function CameraMenuItem() {
    var _this;

    (0, _classCallCheck2["default"])(this, CameraMenuItem);
    _this = _super.call(this, {
      name: 'Camera',
      stateCode: '',
      type: _Layout["default"].type.PANEL,
      zone: _Layout["default"].zone.RIGHT
    });
    _this.items = [new _PropsFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this))];
    return _this;
  }

  return CameraMenuItem;
}(_MenuItem2["default"]);

var _default = CameraMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"./PropsFormMenuItem.js":74,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],74:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

var _FormMenuItem2 = _interopRequireDefault(require("../form/FormMenuItem.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Form properties
 */
var PropsFormMenuItem = /*#__PURE__*/function (_FormMenuItem) {
  (0, _inherits2["default"])(PropsFormMenuItem, _FormMenuItem);

  var _super = _createSuper(PropsFormMenuItem);

  function PropsFormMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, PropsFormMenuItem);
    _this = _super.call(this, {
      name: '',
      stateCode: '',
      type: _Layout["default"].type.FORM,
      zone: parent.zone
    });
    _this.parent = parent;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(PropsFormMenuItem, [{
    key: "getFields",
    value: function getFields() {
      return [{
        bind: 'positionX',
        label: 'X',
        type: _Layout["default"].form.TEXT
      }, {
        bind: 'positionY',
        label: 'Y',
        type: _Layout["default"].form.TEXT
      }, {
        bind: 'positionZ',
        label: 'Z',
        type: _Layout["default"].form.TEXT
      }];
    }
    /**
     * @override
     */

  }, {
    key: "getFormObject",
    value: function getFormObject() {
      return _World["default"].get().getCamera();
    }
  }]);
  return PropsFormMenuItem;
}(_FormMenuItem2["default"]);

var _default = PropsFormMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../../Layout.js":57,"../form/FormMenuItem.js":91,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],75:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _EntitySelector = _interopRequireDefault(require("../../../world/manager/EntitySelector.js"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

var _FormMenuItem2 = _interopRequireDefault(require("../form/FormMenuItem.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Form properties
 */
var ConditionFormMenuItem = /*#__PURE__*/function (_FormMenuItem) {
  (0, _inherits2["default"])(ConditionFormMenuItem, _FormMenuItem);

  var _super = _createSuper(ConditionFormMenuItem);

  function ConditionFormMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, ConditionFormMenuItem);
    _this = _super.call(this, {
      name: 'Conditions',
      stateCode: '',
      type: _Layout["default"].type.FORM,
      zone: parent.zone
    });
    _this.parent = parent;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(ConditionFormMenuItem, [{
    key: "getFields",
    value: function getFields() {
      var _this2 = this;

      var bodyEntities = _World["default"].get().getEntityManager().getBodyEntities().filter(function (entity) {
        return entity !== _this2.object;
      }).map(function (entity) {
        return {
          value: entity.id,
          label: entity.name
        };
      });

      return [{
        bind: 'dieCondition',
        label: 'Die when collide',
        type: _Layout["default"].form.DROPDOWN,
        list: bodyEntities
      }];
    }
    /**
     * @override
     */

  }, {
    key: "getFormObject",
    value: function getFormObject() {
      return _EntitySelector["default"].get().getFirstSelected(_World["default"].get());
    }
  }]);
  return ConditionFormMenuItem;
}(_FormMenuItem2["default"]);

var _default = ConditionFormMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../../../world/manager/EntitySelector.js":174,"../../Layout.js":57,"../form/FormMenuItem.js":91,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],76:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _ConditionFormMenuItem = _interopRequireDefault(require("./ConditionFormMenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Condition Menu Item
 * Menu responsible for managing physics and ai conditions (when die, ...)
 */
var ConditionMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(ConditionMenuItem, _MenuItem);

  var _super = _createSuper(ConditionMenuItem);

  function ConditionMenuItem() {
    var _this;

    (0, _classCallCheck2["default"])(this, ConditionMenuItem);
    _this = _super.call(this, {
      name: 'Conditions',
      stateCode: '',
      type: _Layout["default"].type.PANEL,
      zone: _Layout["default"].zone.RIGHT
    });
    _this.items = [new _ConditionFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this))];
    return _this;
  }

  return ConditionMenuItem;
}(_MenuItem2["default"]);

var _default = ConditionMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"./ConditionFormMenuItem.js":75,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],77:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var AttachPointMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(AttachPointMenuItem, _MenuItem);

  var _super = _createSuper(AttachPointMenuItem);

  function AttachPointMenuItem() {
    (0, _classCallCheck2["default"])(this, AttachPointMenuItem);
    return _super.call(this, {
      id: 1,
      name: 'thumbtack',
      title: 'Pin joints',
      stateCode: 'DRAW_ATTACH_POINT',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.LEFT
    });
  }

  return AttachPointMenuItem;
}(_MenuItem2["default"]);

var _default = AttachPointMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],78:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var CircleMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(CircleMenuItem, _MenuItem);

  var _super = _createSuper(CircleMenuItem);

  function CircleMenuItem() {
    (0, _classCallCheck2["default"])(this, CircleMenuItem);
    return _super.call(this, {
      id: 1,
      name: 'circle',
      title: 'Draw circle',
      stateCode: 'DRAW_CIRCLE',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.LEFT
    });
  }

  return CircleMenuItem;
}(_MenuItem2["default"]);

var _default = CircleMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],79:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var JointMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(JointMenuItem, _MenuItem);

  var _super = _createSuper(JointMenuItem);

  function JointMenuItem() {
    (0, _classCallCheck2["default"])(this, JointMenuItem);
    return _super.call(this, {
      id: 1,
      name: 'bone',
      title: 'Rigid joints',
      stateCode: 'DRAW_JOINT',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.LEFT
    });
  }

  return JointMenuItem;
}(_MenuItem2["default"]);

var _default = JointMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],80:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var RectMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(RectMenuItem, _MenuItem);

  var _super = _createSuper(RectMenuItem);

  function RectMenuItem() {
    (0, _classCallCheck2["default"])(this, RectMenuItem);
    return _super.call(this, {
      id: 1,
      name: 'stop',
      title: 'Draw a rectangle',
      stateCode: 'DRAW_RECT',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.LEFT
    });
  }

  return RectMenuItem;
}(_MenuItem2["default"]);

var _default = RectMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],81:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var SelectorMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(SelectorMenuItem, _MenuItem);

  var _super = _createSuper(SelectorMenuItem);

  function SelectorMenuItem() {
    (0, _classCallCheck2["default"])(this, SelectorMenuItem);
    return _super.call(this, {
      id: 1,
      name: 'mouse-pointer',
      title: 'Select/Move',
      stateCode: 'DRAW_SELECT',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.LEFT
    });
  }

  return SelectorMenuItem;
}(_MenuItem2["default"]);

var _default = SelectorMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],82:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _PropsFormMenuItem = _interopRequireDefault(require("./PropsFormMenuItem.js"));

var _SizeFormMenuItem = _interopRequireDefault(require("./SizeFormMenuItem.js"));

var _PositionFormMenuItem = _interopRequireDefault(require("./PositionFormMenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Entity Menu Item
 * Menu responsible for managing entity's props
 */
var EntityMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(EntityMenuItem, _MenuItem);

  var _super = _createSuper(EntityMenuItem);

  function EntityMenuItem() {
    var _this;

    (0, _classCallCheck2["default"])(this, EntityMenuItem);
    _this = _super.call(this, {
      name: 'Properties',
      stateCode: '',
      type: _Layout["default"].type.PANEL,
      zone: _Layout["default"].zone.RIGHT
    });
    _this.items = [new _PropsFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this)), new _PositionFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this)), new _SizeFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this))];
    return _this;
  }

  return EntityMenuItem;
}(_MenuItem2["default"]);

var _default = EntityMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"./PositionFormMenuItem.js":85,"./PropsFormMenuItem.js":86,"./SizeFormMenuItem.js":87,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],83:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

var _ListFormMenuItem2 = _interopRequireDefault(require("../form/ListFormMenuItem.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Layer Menu Item
 * Menu responsible for managing entities (z-index, ...)
 */
var LayerMenuItem = /*#__PURE__*/function (_ListFormMenuItem) {
  (0, _inherits2["default"])(LayerMenuItem, _ListFormMenuItem);

  var _super = _createSuper(LayerMenuItem);

  function LayerMenuItem() {
    (0, _classCallCheck2["default"])(this, LayerMenuItem);
    return _super.call(this, {
      name: 'Layer',
      stateCode: 'ACTION_SELECT_ENTITY'
    });
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(LayerMenuItem, [{
    key: "getFormObject",
    value: function getFormObject() {
      return _World["default"].get().getEntityManager().getValidBodyEntities().filter(function (entity) {
        return !entity.isSubEntity();
      }).reverse();
    }
  }]);
  return LayerMenuItem;
}(_ListFormMenuItem2["default"]);

var _default = LayerMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../form/ListFormMenuItem.js":94,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],84:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _EntitySelector = _interopRequireDefault(require("../../../world/manager/EntitySelector.js"));

var _FormMenuItem2 = _interopRequireDefault(require("../form/FormMenuItem.js"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Entity's noise configs properties
 */
var NoiseFormMenuItem = /*#__PURE__*/function (_FormMenuItem) {
  (0, _inherits2["default"])(NoiseFormMenuItem, _FormMenuItem);

  var _super = _createSuper(NoiseFormMenuItem);

  function NoiseFormMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, NoiseFormMenuItem);
    _this = _super.call(this, {
      name: '',
      stateCode: '',
      type: _Layout["default"].type.FORM,
      zone: parent.zone
    });
    _this.parent = parent;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(NoiseFormMenuItem, [{
    key: "getFields",
    value: function getFields() {
      return [{
        bind: 'seed',
        label: 'Seed',
        type: _Layout["default"].form.TEXT
      }, {
        bind: 'octaves',
        label: 'Octaves',
        type: _Layout["default"].form.TEXT
      }, {
        bind: 'amplitude',
        label: 'Amplitude',
        type: _Layout["default"].form.TEXT
      }, {
        bind: 'persistence',
        label: 'Persistence',
        type: _Layout["default"].form.TEXT
      }, {
        bind: 'smoothness',
        label: 'Smoothness',
        type: _Layout["default"].form.TEXT
      }];
    }
    /**
     * @override
     */

  }, {
    key: "getFormObject",
    value: function getFormObject() {
      return _EntitySelector["default"].get().getFirstSelected(_World["default"].get());
    }
  }]);
  return NoiseFormMenuItem;
}(_FormMenuItem2["default"]);

var _default = NoiseFormMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../../../world/manager/EntitySelector.js":174,"../../Layout.js":57,"../form/FormMenuItem.js":91,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],85:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _EntitySelector = _interopRequireDefault(require("../../../world/manager/EntitySelector.js"));

var _FormMenuItem2 = _interopRequireDefault(require("../form/FormMenuItem.js"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Entity's position properties
 */
var PositionFormMenuItem = /*#__PURE__*/function (_FormMenuItem) {
  (0, _inherits2["default"])(PositionFormMenuItem, _FormMenuItem);

  var _super = _createSuper(PositionFormMenuItem);

  function PositionFormMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, PositionFormMenuItem);
    _this = _super.call(this, {
      name: '',
      stateCode: '',
      type: _Layout["default"].type.FORM,
      zone: parent.zone
    });
    _this.parent = parent;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(PositionFormMenuItem, [{
    key: "getFields",
    value: function getFields() {
      return [{
        bind: 'positionX',
        label: 'X',
        type: _Layout["default"].form.TEXT
      }, {
        bind: 'positionY',
        label: 'Y',
        type: _Layout["default"].form.TEXT
      }];
    }
    /**
     * @override
     */

  }, {
    key: "getFormObject",
    value: function getFormObject() {
      return _EntitySelector["default"].get().getFirstSelected(_World["default"].get());
    }
  }]);
  return PositionFormMenuItem;
}(_FormMenuItem2["default"]);

var _default = PositionFormMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../../../world/manager/EntitySelector.js":174,"../../Layout.js":57,"../form/FormMenuItem.js":91,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],86:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _EntitySelector = _interopRequireDefault(require("../../../world/manager/EntitySelector.js"));

var _FormMenuItem2 = _interopRequireDefault(require("../form/FormMenuItem.js"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Form physics properties
 */
var PropsFormMenuItem = /*#__PURE__*/function (_FormMenuItem) {
  (0, _inherits2["default"])(PropsFormMenuItem, _FormMenuItem);

  var _super = _createSuper(PropsFormMenuItem);

  function PropsFormMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, PropsFormMenuItem);
    _this = _super.call(this, {
      name: '',
      stateCode: '',
      type: _Layout["default"].type.FORM,
      zone: parent.zone
    });
    _this.parent = parent;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(PropsFormMenuItem, [{
    key: "getFields",
    value: function getFields() {
      return [{
        bind: 'name',
        label: 'Name',
        type: _Layout["default"].form.TEXT
      }, {
        bind: 'fixed',
        label: 'Static',
        type: _Layout["default"].form.CHECKBOX
      }, {
        bind: 'motion',
        label: 'Motion',
        type: _Layout["default"].form.CHECKBOX
      }, {
        bind: 'controlled',
        label: 'Controlled',
        type: _Layout["default"].form.CHECKBOX
      }];
    }
    /**
     * @override
     */

  }, {
    key: "getFormObject",
    value: function getFormObject() {
      return _EntitySelector["default"].get().getFirstSelected(_World["default"].get());
    }
  }]);
  return PropsFormMenuItem;
}(_FormMenuItem2["default"]);

var _default = PropsFormMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../../../world/manager/EntitySelector.js":174,"../../Layout.js":57,"../form/FormMenuItem.js":91,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],87:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _EntitySelector = _interopRequireDefault(require("../../../world/manager/EntitySelector.js"));

var _FormMenuItem2 = _interopRequireDefault(require("../form/FormMenuItem.js"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Entity's size properties
 */
var SizeFormMenuItem = /*#__PURE__*/function (_FormMenuItem) {
  (0, _inherits2["default"])(SizeFormMenuItem, _FormMenuItem);

  var _super = _createSuper(SizeFormMenuItem);

  function SizeFormMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, SizeFormMenuItem);
    _this = _super.call(this, {
      name: '',
      stateCode: '',
      type: _Layout["default"].type.FORM,
      zone: parent.zone
    });
    _this.parent = parent;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(SizeFormMenuItem, [{
    key: "getFields",
    value: function getFields() {
      return [{
        bind: 'width',
        label: 'Width',
        type: _Layout["default"].form.TEXT
      }, {
        bind: 'height',
        label: 'Height',
        type: _Layout["default"].form.TEXT
      }, {
        bind: 'rotationDegree',
        label: 'Rotation ()',
        type: _Layout["default"].form.TEXT
      }];
    }
    /**
     * @override
     */

  }, {
    key: "getFormObject",
    value: function getFormObject() {
      return _EntitySelector["default"].get().getFirstSelected(_World["default"].get());
    }
  }]);
  return SizeFormMenuItem;
}(_FormMenuItem2["default"]);

var _default = SizeFormMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../../../world/manager/EntitySelector.js":174,"../../Layout.js":57,"../form/FormMenuItem.js":91,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],88:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _InputMenuItem2 = _interopRequireDefault(require("./InputMenuItem.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Checkbox Menu Item
 */
var CheckboxMenuItem = /*#__PURE__*/function (_InputMenuItem) {
  (0, _inherits2["default"])(CheckboxMenuItem, _InputMenuItem);

  var _super = _createSuper(CheckboxMenuItem);

  /**
   * @override
   */
  function CheckboxMenuItem(parent, props, value, event) {
    var _this;

    (0, _classCallCheck2["default"])(this, CheckboxMenuItem);
    _this = _super.call(this, parent, props, value, event);
    _this.field = _Layout["default"].form.CHECKBOX;
    return _this;
  }

  return CheckboxMenuItem;
}(_InputMenuItem2["default"]);

var _default = CheckboxMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"./InputMenuItem.js":92,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],89:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _InputMenuItem2 = _interopRequireDefault(require("./InputMenuItem.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Checkbox Menu Item
 */
var DropdownMenuItem = /*#__PURE__*/function (_InputMenuItem) {
  (0, _inherits2["default"])(DropdownMenuItem, _InputMenuItem);

  var _super = _createSuper(DropdownMenuItem);

  /**
   * @param {MenuItem} parent
   * @param {Object} props
   * @param {any} value The default value
   * @param {Function} event The event binded to the field
   */
  function DropdownMenuItem(parent, props, value, event) {
    var _this;

    (0, _classCallCheck2["default"])(this, DropdownMenuItem);
    _this = _super.call(this, parent, props, value, event);
    _this.field = _Layout["default"].form.DROPDOWN;
    return _this;
  }

  return DropdownMenuItem;
}(_InputMenuItem2["default"]);

var _default = DropdownMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"./InputMenuItem.js":92,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],90:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _InputMenuItem2 = _interopRequireDefault(require("./InputMenuItem.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * File Menu Item
 */
var FileMenuItem = /*#__PURE__*/function (_InputMenuItem) {
  (0, _inherits2["default"])(FileMenuItem, _InputMenuItem);

  var _super = _createSuper(FileMenuItem);

  /**
   * @param {MenuItem} parent
   * @param {Object} props
   * @param {any} value The default value
   * @param {Function} event The event bound to the field
   */
  function FileMenuItem(parent, props, value, event) {
    var _this;

    (0, _classCallCheck2["default"])(this, FileMenuItem);
    _this = _super.call(this, parent, props, value, event);
    _this.field = _Layout["default"].form.FILE;
    return _this;
  }

  return FileMenuItem;
}(_InputMenuItem2["default"]);

var _default = FileMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"./InputMenuItem.js":92,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],91:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _FileMenuItem = _interopRequireDefault(require("./FileMenuItem.js"));

var _TextMenuItem = _interopRequireDefault(require("./TextMenuItem.js"));

var _CheckboxMenuItem = _interopRequireDefault(require("./CheckboxMenuItem.js"));

var _DropdownMenuItem = _interopRequireDefault(require("./DropdownMenuItem.js"));

var _Maths = _interopRequireDefault(require("../../../utils/Maths.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Form menu item
 * @property {FormField[]} fields
 */
var FormMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(FormMenuItem, _MenuItem);

  var _super = _createSuper(FormMenuItem);

  function FormMenuItem(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, FormMenuItem);
    _this = _super.call(this, props);

    _this.init();

    return _this;
  }
  /**
   * Init the form menu
   */


  (0, _createClass2["default"])(FormMenuItem, [{
    key: "init",
    value: function init() {
      this.bindObject = null;
      this.object = null;
      this.items = [];
      this.version = 0;
      this.fields = this.getFields();
    }
    /**
     * @abstract
     * Get all fields
     * @return {FormField[]}
     */

  }, {
    key: "getFields",
    value: function getFields() {
      throw new TypeError('"getFields" method must be implemented');
    }
    /**
     * @abstract
     * Get the object bound to the form
     * @return {Object}
     */

  }, {
    key: "getFormObject",
    value: function getFormObject() {
      throw new TypeError('"getFormObject" method must be implemented');
    }
    /**
     * Check if the form has to be updated
     * @return {boolean}
     */

  }, {
    key: "shouldUpdate",
    value: function shouldUpdate() {
      return true;
    }
    /**
     * @override
     */

  }, {
    key: "update",
    value: function update() {
      var object = this.getFormObject();
      this.bindObject = object;

      if (object) {
        if (this.isFormUpdated(object)) {
          this.object = _.cloneDeep(object);
          this.shouldUpdate() && this.updateForm();
        }
      } else {
        this.init();
      }
    }
    /**
     * Update the form
     */

  }, {
    key: "updateForm",
    value: function updateForm() {
      this.items = [];
      this.buildFormItems();
      this.version = _Maths["default"].generateId();
    }
    /**
     * Check if the form is updated
     * @return {boolean}
     */

  }, {
    key: "isFormUpdated",
    value: function isFormUpdated(object) {
      if (!this.object || object.id !== this.object.id) {
        return true;
      }

      for (var iField in this.fields) {
        if (this.fields.hasOwnProperty(iField)) {
          var field = this.fields[iField];
          var getterString = this.getGetterString(field);

          try {
            if (object[getterString]() !== this.object[getterString]()) {
              return true;
            }
          } catch (e) {
            throw new ReferenceError("Error comparing ".concat(getterString, " for ").concat(object.constructor.name));
          }
        }
      }

      return false;
    }
    /**
     * Get the bound object
     * @return {Object}
     */

  }, {
    key: "getBindObject",
    value: function getBindObject() {
      return this.bindObject;
    }
    /**
     * Build form items
     */

  }, {
    key: "buildFormItems",
    value: function buildFormItems() {
      var _this2 = this;

      this.items = this.items.concat(this.fields.map(function (field) {
        var getter = _this2.getGetter(field);

        var setter = _this2.getSetter(field);

        var typeMenuItem = _this2.getMenuItem(field);

        return new typeMenuItem(_this2, {
          name: field.label,
          list: field.list || []
        }, getter, setter);
      }));
    }
    /**
     * Get the getter if the field
     * @param {FormField} field
     * @return {callback}
     */

  }, {
    key: "getGetter",
    value: function getGetter(field) {
      var getterString = this.getGetterString(field);

      if (field.type !== _Layout["default"].form.FILE) {
        return function (getter, self) {
          return function () {
            return self.bindObject[getter]();
          };
        }(getterString, this);
      }

      return function () {
        return null;
      };
    }
    /**
     * Get the getter name
     * @param {FormField} field
     * @return {string}
     */

  }, {
    key: "getGetterString",
    value: function getGetterString(field) {
      var prefix = field.type === _Layout["default"].form.CHECKBOX ? "is" : "get";
      return "".concat(prefix).concat(field.bind.charAt(0).toUpperCase() + field.bind.slice(1));
    }
    /**
     * Get the setter if the field
     * @param {FormField} field
     * @return {callback}
     */

  }, {
    key: "getSetter",
    value: function getSetter(field) {
      var setterString = this.getSetterString(field);
      return function (setter, self) {
        return function (value) {
          return self.bindObject[setter](value);
        };
      }(setterString, this);
    }
    /**
     * Get the setter name
     * @param {FormField} field
     * @return {string}
     */

  }, {
    key: "getSetterString",
    value: function getSetterString(field) {
      return "set".concat(field.bind.charAt(0).toUpperCase() + field.bind.slice(1));
    }
    /**
     * Get the menu item
     * @param {FormField} field
     * @return {InputMenuItem}
     */

  }, {
    key: "getMenuItem",
    value: function getMenuItem(field) {
      switch (field.type) {
        case _Layout["default"].form.FILE:
          return _FileMenuItem["default"];

        case _Layout["default"].form.TEXT:
          return _TextMenuItem["default"];

        case _Layout["default"].form.CHECKBOX:
          return _CheckboxMenuItem["default"];

        case _Layout["default"].form.DROPDOWN:
          return _DropdownMenuItem["default"];

        default:
          return null;
      }
    }
  }]);
  return FormMenuItem;
}(_MenuItem2["default"]);
/**
 * @typedef {{bind: string, label: string, type: string, list?: { value: string|number, label: string }[]}} FormField
 */


var _default = FormMenuItem;
exports["default"] = _default;

},{"../../../utils/Maths.js":165,"../../Layout.js":57,"../../MenuItem.js":59,"./CheckboxMenuItem.js":88,"./DropdownMenuItem.js":89,"./FileMenuItem.js":90,"./TextMenuItem.js":95,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],92:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Input Menu Item
 * Can be used many times by the different menu items;
 * Start/run action must be handled differently
 */
var InputMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(InputMenuItem, _MenuItem);

  var _super = _createSuper(InputMenuItem);

  /**
   * @param {MenuItem} parent
   * @param {Object} props
   * @param {callback} value The default value
   * @param {callback} event The event bound to the field
   */
  function InputMenuItem(parent, props, value, event) {
    var _this;

    (0, _classCallCheck2["default"])(this, InputMenuItem);
    _this = _super.call(this, _objectSpread({
      stateCode: 'ACTION_FORM_UPDATE',
      zone: parent.zone,
      type: _Layout["default"].type.FORM_ELEMENT
    }, props));
    _this.parent = parent;
    _this.event = _this.callbackExecute(event);
    _this.value = _this.callbackExecute(value);
    _this.data = {
      event: event,
      item: (0, _assertThisInitialized2["default"])(_this)
    };
    return _this;
  }
  /**
   * Execute callback
   */


  (0, _createClass2["default"])(InputMenuItem, [{
    key: "callbackExecute",
    value: function callbackExecute(callback) {
      return function () {
        try {
          return callback();
        } catch (e) {
          console.warn("Callback error! ", e);
        }
      };
    }
    /**
     * Input menu item must be valid as the parent keeps valid
     * @override
     */

  }, {
    key: "isValid",
    value: function isValid() {
      return this.parent.isValid();
    }
  }]);
  return InputMenuItem;
}(_MenuItem2["default"]);

var _default = InputMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],93:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {ListElementFormMenuItem}
 * @property {{bind: Object}} data
 */
var ListElementFormMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(ListElementFormMenuItem, _MenuItem);

  var _super = _createSuper(ListElementFormMenuItem);

  function ListElementFormMenuItem(parent, data) {
    var _this;

    (0, _classCallCheck2["default"])(this, ListElementFormMenuItem);
    _this = _super.call(this, {
      name: '',
      stateCode: parent.stateCode,
      type: _Layout["default"].type.LIST_ELEMENT,
      zone: parent.zone
    });
    _this.parent = parent;
    _this.data = data;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(ListElementFormMenuItem, [{
    key: "isSelected",
    value: function isSelected() {
      return this.getDataBind().isSelected();
    }
    /**
     * @override
     */

  }, {
    key: "isValid",
    value: function isValid() {
      return (0, _get2["default"])((0, _getPrototypeOf2["default"])(ListElementFormMenuItem.prototype), "isValid", this).call(this) && this.parent.getFormObject().includes(this.getDataBind());
    }
    /**
     * @return {Object}
     */

  }, {
    key: "getDataBind",
    value: function getDataBind() {
      return this.data.bind;
    }
  }]);
  return ListElementFormMenuItem;
}(_MenuItem2["default"]);

var _default = ListElementFormMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":9,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],94:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _ListElementFormMenuItem = _interopRequireDefault(require("./ListElementFormMenuItem.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {ListFormMenuItem}
 */
var ListFormMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(ListFormMenuItem, _MenuItem);

  var _super = _createSuper(ListFormMenuItem);

  function ListFormMenuItem(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, ListFormMenuItem);
    _this = _super.call(this, _objectSpread({
      name: '',
      stateCode: 'ACTION_SELECT_LIST_ELEMENT',
      type: _Layout["default"].type.PANEL,
      zone: _Layout["default"].zone.RIGHT
    }, props));
    _this.items = [];
    return _this;
  }
  /**
   * @return {*[]}
   * @abstract
   */


  (0, _createClass2["default"])(ListFormMenuItem, [{
    key: "getFormObject",
    value: function getFormObject() {
      throw new TypeError('ListFormMenuItem.getFormObject must be implemented');
    }
    /**
     * @override
     */

  }, {
    key: "update",
    value: function update() {
      var _this2 = this;

      var list = this.getFormObject();
      this.items = list.map(function (each, index) {
        var element = _this2.items[index];

        if (element && element.data.bind !== each) {
          element.data.bind = each;
        }

        return element || new _ListElementFormMenuItem["default"](_this2, {
          bind: each,
          list: list
        });
      });
    }
  }]);
  return ListFormMenuItem;
}(_MenuItem2["default"]);

var _default = ListFormMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"./ListElementFormMenuItem.js":93,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],95:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _InputMenuItem2 = _interopRequireDefault(require("./InputMenuItem.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Text Menu Item
 */
var TextMenuItem = /*#__PURE__*/function (_InputMenuItem) {
  (0, _inherits2["default"])(TextMenuItem, _InputMenuItem);

  var _super = _createSuper(TextMenuItem);

  /**
   * @param {MenuItem} parent
   * @param {Object} props
   * @param {any} value The default value
   * @param {Function} event The event binded to the field
   */
  function TextMenuItem(parent, props, value, event) {
    var _this;

    (0, _classCallCheck2["default"])(this, TextMenuItem);
    _this = _super.call(this, parent, props, value, event);
    _this.field = _Layout["default"].form.TEXT;
    return _this;
  }

  return TextMenuItem;
}(_InputMenuItem2["default"]);

var _default = TextMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"./InputMenuItem.js":92,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],96:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

var _FormMenuItem2 = _interopRequireDefault(require("../form/FormMenuItem.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Form AI Engine properties
 */
var AiFormMenuItem = /*#__PURE__*/function (_FormMenuItem) {
  (0, _inherits2["default"])(AiFormMenuItem, _FormMenuItem);

  var _super = _createSuper(AiFormMenuItem);

  function AiFormMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, AiFormMenuItem);
    _this = _super.call(this, {
      name: 'Properties',
      stateCode: '',
      type: _Layout["default"].type.FORM,
      zone: parent.zone
    });
    _this.parent = parent;

    _this.init();

    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(AiFormMenuItem, [{
    key: "getFields",
    value: function getFields() {
      return [{
        bind: 'nbPerGeneration',
        label: 'Nb. Generation',
        type: _Layout["default"].form.TEXT
      }, {
        bind: 'maxLifeInSec',
        label: 'Max. life (sec)',
        type: _Layout["default"].form.TEXT
      }, {
        bind: 'mutationProb',
        label: 'Mutation rate',
        type: _Layout["default"].form.TEXT
      }];
    }
    /**
     * @override
     */

  }, {
    key: "getFormObject",
    value: function getFormObject() {
      return _World["default"].get().getAiEngine();
    }
  }]);
  return AiFormMenuItem;
}(_FormMenuItem2["default"]);

var _default = AiFormMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../../Layout.js":57,"../form/FormMenuItem.js":91,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],97:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _InfosMenuItem = _interopRequireDefault(require("./InfosMenuItem.js"));

var _FitnessGraphMenuItem = _interopRequireDefault(require("./FitnessGraphMenuItem.js"));

var _AiFormMenuItem = _interopRequireDefault(require("./AiFormMenuItem.js"));

var _FormSimulationMenuItem = _interopRequireDefault(require("./FormSimulationMenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _GeneticEngine = _interopRequireDefault(require("../../../ai/genetic/GeneticEngine.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * AI Genetic Menu Item
 * Menu responsible for managing Ai Genetic
 */
var AiGeneticMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(AiGeneticMenuItem, _MenuItem);

  var _super = _createSuper(AiGeneticMenuItem);

  function AiGeneticMenuItem() {
    var _this;

    (0, _classCallCheck2["default"])(this, AiGeneticMenuItem);
    _this = _super.call(this, {
      name: 'AI Genetic',
      stateCode: '',
      type: _Layout["default"].type.PANEL,
      zone: _Layout["default"].zone.RIGHT
    });
    _this.items = [new _InfosMenuItem["default"]((0, _assertThisInitialized2["default"])(_this)), new _FitnessGraphMenuItem["default"]((0, _assertThisInitialized2["default"])(_this)), new _AiFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this)), new _FormSimulationMenuItem["default"]((0, _assertThisInitialized2["default"])(_this))];
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(AiGeneticMenuItem, [{
    key: "isValid",
    value: function isValid() {
      return _GeneticEngine["default"].get();
    }
  }]);
  return AiGeneticMenuItem;
}(_MenuItem2["default"]);

var _default = AiGeneticMenuItem;
exports["default"] = _default;

},{"../../../ai/genetic/GeneticEngine.js":27,"../../Layout.js":57,"../../MenuItem.js":59,"./AiFormMenuItem.js":96,"./FitnessGraphMenuItem.js":98,"./FormSimulationMenuItem.js":99,"./InfosMenuItem.js":100,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],98:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _GeneticEngine = _interopRequireDefault(require("../../../ai/genetic/GeneticEngine.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * FitnessGraphMenuItem class
 * Show/Manage all informations for AI Genetic
 */
var FitnessGraphMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(FitnessGraphMenuItem, _MenuItem);

  var _super = _createSuper(FitnessGraphMenuItem);

  function FitnessGraphMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, FitnessGraphMenuItem);
    _this = _super.call(this, {
      name: 'Fitness graph',
      stateCode: '',
      type: _Layout["default"].type.GRAPH,
      zone: parent.zone
    });
    _this.parent = parent;

    _this.init();

    return _this;
  }
  /**
   * Initialize
   */


  (0, _createClass2["default"])(FitnessGraphMenuItem, [{
    key: "init",
    value: function init() {
      this.fitnessList = [];
      this.graph = {
        type: 'line',
        maxY: 100,
        maxX: 200,
        data: [],
        version: 0
      };

      var aiEngine = _GeneticEngine["default"].get();

      this.engineVersion = aiEngine && aiEngine.getVersion();
    }
    /**
     * @override
     */

  }, {
    key: "update",
    value: function update() {
      var aiEngine = _GeneticEngine["default"].get();

      if (this.engineVersion !== aiEngine.getVersion()) {
        this.init();
      }

      var numGeneration = aiEngine.numGeneration,
          bestGenomes = aiEngine.bestGenomes;
      this.updateData(numGeneration, bestGenomes);
    }
    /**
     * Update the data of the graph
     */

  }, {
    key: "updateData",
    value: function updateData(numGeneration, bestGenomes) {
      var isToUpdate = this.graph.version !== numGeneration;

      if (bestGenomes.length && isToUpdate) {
        var fitness = bestGenomes[0].distance;
        this.fitnessList.push(fitness);
        this.graph.version = numGeneration;
        this.setupData();
      }
    }
    /**
     * Setup data (setup Y-axis, ...)
     */

  }, {
    key: "setupData",
    value: function setupData() {
      var _this$graph = this.graph,
          maxY = _this$graph.maxY,
          maxX = _this$graph.maxX;
      var maxFitness = this.fitnessList.reduce(function (max, fitness) {
        return max > fitness ? max : fitness;
      }, 0);
      var maxListX = this.fitnessList.length;
      this.graph.data = this.fitnessList.map(function (fitness, nGeneration) {
        return {
          x: Math.round(maxListX ? nGeneration / maxListX * maxX : 0),
          y: Math.round(maxFitness - (maxFitness ? fitness / maxFitness * maxY : 0))
        };
      });
    }
    /**
     * @override
     */

  }, {
    key: "isValid",
    value: function isValid() {
      return this.stateManager.isRunning() && _GeneticEngine["default"].get();
    }
  }]);
  return FitnessGraphMenuItem;
}(_MenuItem2["default"]);

var _default = FitnessGraphMenuItem;
exports["default"] = _default;

},{"../../../ai/genetic/GeneticEngine.js":27,"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],99:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

var _FormMenuItem2 = _interopRequireDefault(require("../form/FormMenuItem.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Form AI Engine properties
 */
var FormSimulationMenuItem = /*#__PURE__*/function (_FormMenuItem) {
  (0, _inherits2["default"])(FormSimulationMenuItem, _FormMenuItem);

  var _super = _createSuper(FormSimulationMenuItem);

  function FormSimulationMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, FormSimulationMenuItem);
    _this = _super.call(this, {
      name: 'Form Simulation',
      stateCode: '',
      type: _Layout["default"].type.FORM,
      zone: parent.zone
    });
    _this.parent = parent;

    _this.init();

    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(FormSimulationMenuItem, [{
    key: "getFields",
    value: function getFields() {
      return [{
        bind: 'showOnlyBest',
        label: 'Show only best',
        type: _Layout["default"].form.CHECKBOX
      }, {
        bind: 'randomizeColor',
        label: 'Randomize color',
        type: _Layout["default"].form.CHECKBOX
      }];
    }
    /**
     * @override
     */

  }, {
    key: "isValid",
    value: function isValid() {
      return true;
    }
    /**
     * @override
     */

  }, {
    key: "getFormObject",
    value: function getFormObject() {
      return _World["default"].get().getAiEngine();
    }
  }]);
  return FormSimulationMenuItem;
}(_FormMenuItem2["default"]);

var _default = FormSimulationMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../../Layout.js":57,"../form/FormMenuItem.js":91,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],100:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _GeneticEngine = _interopRequireDefault(require("../../../ai/genetic/GeneticEngine.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * InfosMenuItem class
 * Show/Manage all informations for AI Genetic
 */
var InfosMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(InfosMenuItem, _MenuItem);

  var _super = _createSuper(InfosMenuItem);

  function InfosMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, InfosMenuItem);
    _this = _super.call(this, {
      name: 'AI Genetic',
      stateCode: '',
      type: _Layout["default"].type.TEXT,
      zone: parent.zone
    });
    _this.parent = parent;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(InfosMenuItem, [{
    key: "update",
    value: function update() {
      var aiEngine = _GeneticEngine["default"].get();

      var numGeneration = aiEngine.numGeneration,
          nbPerGeneration = aiEngine.nbPerGeneration,
          bestGenomes = aiEngine.bestGenomes,
          maxLifeInSec = aiEngine.maxLifeInSec,
          timeToReactInSec = aiEngine.timeToReactInSec,
          genomes = aiEngine.genomes;
      this.text = ["Generation : ".concat(numGeneration), "Life (sec) : ".concat(Math.round(maxLifeInSec - timeToReactInSec * genomes[0].stepBehavior)), "Population : ".concat(nbPerGeneration), "Best distance : ".concat(bestGenomes.length && bestGenomes[0].distance || 0)];
    }
    /**
     * @override
     */

  }, {
    key: "isValid",
    value: function isValid() {
      return this.stateManager.isRunning() && _GeneticEngine["default"].get();
    }
  }]);
  return InfosMenuItem;
}(_MenuItem2["default"]);

var _default = InfosMenuItem;
exports["default"] = _default;

},{"../../../ai/genetic/GeneticEngine.js":27,"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],101:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {ExportProjectMenuItem}
 */
var ExportProjectMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(ExportProjectMenuItem, _MenuItem);

  var _super = _createSuper(ExportProjectMenuItem);

  function ExportProjectMenuItem() {
    (0, _classCallCheck2["default"])(this, ExportProjectMenuItem);
    return _super.call(this, {
      name: 'file-export',
      title: 'Export project',
      stateCode: 'ACTION_EXPORT_PROJECT',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return ExportProjectMenuItem;
}(_MenuItem2["default"]);

var _default = ExportProjectMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],102:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {LoadProjectMenuItem}
 */
var LoadProjectMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(LoadProjectMenuItem, _MenuItem);

  var _super = _createSuper(LoadProjectMenuItem);

  function LoadProjectMenuItem() {
    (0, _classCallCheck2["default"])(this, LoadProjectMenuItem);
    return _super.call(this, {
      name: 'file-upload',
      title: 'Load project',
      stateCode: 'ACTION_LOAD_PROJECT',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return LoadProjectMenuItem;
}(_MenuItem2["default"]);

var _default = LoadProjectMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],103:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Create new project
 */
var NewProjectMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(NewProjectMenuItem, _MenuItem);

  var _super = _createSuper(NewProjectMenuItem);

  function NewProjectMenuItem() {
    (0, _classCallCheck2["default"])(this, NewProjectMenuItem);
    return _super.call(this, {
      name: 'file',
      title: 'New project',
      stateCode: 'ACTION_NEW_PROJECT',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return NewProjectMenuItem;
}(_MenuItem2["default"]);

var _default = NewProjectMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],104:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Save the project
 */
var SaveProjectMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(SaveProjectMenuItem, _MenuItem);

  var _super = _createSuper(SaveProjectMenuItem);

  function SaveProjectMenuItem() {
    (0, _classCallCheck2["default"])(this, SaveProjectMenuItem);
    return _super.call(this, {
      name: 'save',
      title: 'Save project',
      stateCode: 'ACTION_SAVE_PROJECT',
      type: _Layout["default"].type.ICON,
      zone: _Layout["default"].zone.TOP
    });
  }

  return SaveProjectMenuItem;
}(_MenuItem2["default"]);

var _default = SaveProjectMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],105:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _TextureFormMenuItem = _interopRequireDefault(require("./TextureFormMenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Style Menu Item
 * Menu responsible for managing entity's styles
 */
var StyleMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(StyleMenuItem, _MenuItem);

  var _super = _createSuper(StyleMenuItem);

  function StyleMenuItem() {
    var _this;

    (0, _classCallCheck2["default"])(this, StyleMenuItem);
    _this = _super.call(this, {
      name: 'Style',
      stateCode: '',
      type: _Layout["default"].type.PANEL,
      zone: _Layout["default"].zone.RIGHT
    });
    _this.items = [new _TextureFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this))];
    return _this;
  }

  return StyleMenuItem;
}(_MenuItem2["default"]);

var _default = StyleMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"./TextureFormMenuItem.js":106,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],106:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _FormMenuItem2 = _interopRequireDefault(require("../form/FormMenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _EntitySelector = _interopRequireDefault(require("../../../world/manager/EntitySelector.js"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {TextureFormMenuItem}
 * @property {Entity} bindObject
 */
var TextureFormMenuItem = /*#__PURE__*/function (_FormMenuItem) {
  (0, _inherits2["default"])(TextureFormMenuItem, _FormMenuItem);

  var _super = _createSuper(TextureFormMenuItem);

  function TextureFormMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, TextureFormMenuItem);
    _this = _super.call(this, {
      name: '',
      stateCode: '',
      type: _Layout["default"].type.FORM,
      zone: parent.zone
    });
    _this.parent = parent;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(TextureFormMenuItem, [{
    key: "getFields",
    value: function getFields() {
      var textures = _World["default"].get().getTextureManager().getTextures().map(function (texture) {
        return {
          value: texture.id,
          label: texture.name
        };
      });

      return [{
        bind: 'backgroundImageRepeat',
        label: 'Texture repeat',
        type: _Layout["default"].form.CHECKBOX
      }, {
        bind: 'textureId',
        label: 'Texture',
        type: _Layout["default"].form.DROPDOWN,
        list: textures
      }];
    }
    /**
     * @override
     */

  }, {
    key: "shouldUpdate",
    value: function shouldUpdate() {
      return this.bindObject && !_World["default"].get().getEntityManager().isAttachEntity(this.bindObject);
    }
    /**
     * @override
     */

  }, {
    key: "getFormObject",
    value: function getFormObject() {
      return _EntitySelector["default"].get().getFirstSelected(_World["default"].get());
    }
  }]);
  return TextureFormMenuItem;
}(_FormMenuItem2["default"]);

var _default = TextureFormMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../../../world/manager/EntitySelector.js":174,"../../Layout.js":57,"../form/FormMenuItem.js":91,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],107:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

var _FormMenuItem2 = _interopRequireDefault(require("../form/FormMenuItem.js"));

var _TerrainManager = _interopRequireDefault(require("../../../world/terrain/TerrainManager.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Form AI Engine properties
 */
var TerrainFormMenuItem = /*#__PURE__*/function (_FormMenuItem) {
  (0, _inherits2["default"])(TerrainFormMenuItem, _FormMenuItem);

  var _super = _createSuper(TerrainFormMenuItem);

  function TerrainFormMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, TerrainFormMenuItem);
    _this = _super.call(this, {
      name: 'Terrain form',
      stateCode: '',
      type: _Layout["default"].type.FORM,
      zone: parent.zone
    });
    _this.parent = parent;

    _this.init();

    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(TerrainFormMenuItem, [{
    key: "getFields",
    value: function getFields() {
      return [{
        bind: 'terrainType',
        label: 'Type',
        type: _Layout["default"].form.DROPDOWN,
        list: [{
          value: _TerrainManager["default"].TYPES.PLAIN,
          label: 'Plain'
        }, {
          value: _TerrainManager["default"].TYPES.NOISE,
          label: 'Noise'
        }]
      }];
    }
    /**
     * @override
     */

  }, {
    key: "getFormObject",
    value: function getFormObject() {
      return _World["default"].get().getTerrainManager();
    }
  }]);
  return TerrainFormMenuItem;
}(_FormMenuItem2["default"]);

var _default = TerrainFormMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../../../world/terrain/TerrainManager.js":177,"../../Layout.js":57,"../form/FormMenuItem.js":91,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],108:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _TerrainFormMenuItem = _interopRequireDefault(require("./TerrainFormMenuItem.js"));

var _TypeMenuItem = _interopRequireDefault(require("./type/TypeMenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Terrain Menu Item
 * Menu responsible for managing terrains
 */
var TerrainMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(TerrainMenuItem, _MenuItem);

  var _super = _createSuper(TerrainMenuItem);

  function TerrainMenuItem() {
    var _this;

    (0, _classCallCheck2["default"])(this, TerrainMenuItem);
    _this = _super.call(this, {
      name: 'Terrain',
      stateCode: '',
      type: _Layout["default"].type.PANEL,
      zone: _Layout["default"].zone.RIGHT
    });
    _this.items = [new _TerrainFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this)), new _TypeMenuItem["default"]((0, _assertThisInitialized2["default"])(_this))];
    return _this;
  }

  return TerrainMenuItem;
}(_MenuItem2["default"]);

var _default = TerrainMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"./TerrainFormMenuItem.js":107,"./type/TypeMenuItem.js":110,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],109:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _TextureFormMenuItem2 = _interopRequireDefault(require("../../style/TextureFormMenuItem.js"));

var _World = _interopRequireDefault(require("../../../../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Plain terrain background Menu Item
 */
var TypeBackgroundMenuItem = /*#__PURE__*/function (_TextureFormMenuItem) {
  (0, _inherits2["default"])(TypeBackgroundMenuItem, _TextureFormMenuItem);

  var _super = _createSuper(TypeBackgroundMenuItem);

  function TypeBackgroundMenuItem() {
    (0, _classCallCheck2["default"])(this, TypeBackgroundMenuItem);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(TypeBackgroundMenuItem, [{
    key: "getFormObject",

    /**
     * @override
     */
    value: function getFormObject() {
      var terrain = _World["default"].get().getTerrainManager().getTerrain();

      return terrain && terrain.getEntity(_World["default"].get());
    }
  }]);
  return TypeBackgroundMenuItem;
}(_TextureFormMenuItem2["default"]);

var _default = TypeBackgroundMenuItem;
exports["default"] = _default;

},{"../../../../world/World.js":171,"../../style/TextureFormMenuItem.js":106,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],110:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../../MenuItem.js"));

var _TypePosFormMenuItem = _interopRequireDefault(require("./TypePosFormMenuItem.js"));

var _TypeSizeFormMenuItem = _interopRequireDefault(require("./TypeSizeFormMenuItem.js"));

var _TypeStyleMenuItem = _interopRequireDefault(require("./TypeStyleMenuItem.js"));

var _TypeNoiseFormMenuItem = _interopRequireDefault(require("./TypeNoiseFormMenuItem.js"));

var _Layout = _interopRequireDefault(require("../../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Terrain Menu Item
 */
var TypeMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(TypeMenuItem, _MenuItem);

  var _super = _createSuper(TypeMenuItem);

  function TypeMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, TypeMenuItem);
    _this = _super.call(this, {
      name: '',
      stateCode: '',
      type: _Layout["default"].type.PANEL,
      zone: parent.zone
    });
    _this.parent = parent;
    _this.items = [new _TypePosFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this)), new _TypeSizeFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this)), new _TypeStyleMenuItem["default"]((0, _assertThisInitialized2["default"])(_this)), new _TypeNoiseFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this))];
    return _this;
  }

  return TypeMenuItem;
}(_MenuItem2["default"]);

var _default = TypeMenuItem;
exports["default"] = _default;

},{"../../../Layout.js":57,"../../../MenuItem.js":59,"./TypeNoiseFormMenuItem.js":111,"./TypePosFormMenuItem.js":112,"./TypeSizeFormMenuItem.js":113,"./TypeStyleMenuItem.js":114,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],111:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _NoiseFormMenuItem2 = _interopRequireDefault(require("../../entity/NoiseFormMenuItem.js"));

var _World = _interopRequireDefault(require("../../../../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Terrain's noise configs form
 */
var TypeNoiseFormMenuItem = /*#__PURE__*/function (_NoiseFormMenuItem) {
  (0, _inherits2["default"])(TypeNoiseFormMenuItem, _NoiseFormMenuItem);

  var _super = _createSuper(TypeNoiseFormMenuItem);

  function TypeNoiseFormMenuItem() {
    (0, _classCallCheck2["default"])(this, TypeNoiseFormMenuItem);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(TypeNoiseFormMenuItem, [{
    key: "getFormObject",

    /**
     * @override
     */
    value: function getFormObject() {
      var terrain = _World["default"].get().getTerrainManager().getTerrain();

      return terrain && terrain.getEntity(_World["default"].get());
    }
  }]);
  return TypeNoiseFormMenuItem;
}(_NoiseFormMenuItem2["default"]);

var _default = TypeNoiseFormMenuItem;
exports["default"] = _default;

},{"../../../../world/World.js":171,"../../entity/NoiseFormMenuItem.js":84,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],112:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _PositionFormMenuItem2 = _interopRequireDefault(require("../../entity/PositionFormMenuItem.js"));

var _World = _interopRequireDefault(require("../../../../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Terrain's position form
 */
var TypePosFormMenuItem = /*#__PURE__*/function (_PositionFormMenuItem) {
  (0, _inherits2["default"])(TypePosFormMenuItem, _PositionFormMenuItem);

  var _super = _createSuper(TypePosFormMenuItem);

  function TypePosFormMenuItem() {
    (0, _classCallCheck2["default"])(this, TypePosFormMenuItem);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(TypePosFormMenuItem, [{
    key: "getFormObject",

    /**
     * @override
     */
    value: function getFormObject() {
      var terrain = _World["default"].get().getTerrainManager().getTerrain();

      return terrain && terrain.getEntity(_World["default"].get());
    }
  }]);
  return TypePosFormMenuItem;
}(_PositionFormMenuItem2["default"]);

var _default = TypePosFormMenuItem;
exports["default"] = _default;

},{"../../../../world/World.js":171,"../../entity/PositionFormMenuItem.js":85,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],113:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _SizeFormMenuItem2 = _interopRequireDefault(require("../../entity/SizeFormMenuItem.js"));

var _World = _interopRequireDefault(require("../../../../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Terrain's size form
 */
var TypeSizeFormMenuItem = /*#__PURE__*/function (_SizeFormMenuItem) {
  (0, _inherits2["default"])(TypeSizeFormMenuItem, _SizeFormMenuItem);

  var _super = _createSuper(TypeSizeFormMenuItem);

  function TypeSizeFormMenuItem() {
    (0, _classCallCheck2["default"])(this, TypeSizeFormMenuItem);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(TypeSizeFormMenuItem, [{
    key: "getFormObject",

    /**
     * @override
     */
    value: function getFormObject() {
      var terrain = _World["default"].get().getTerrainManager().getTerrain();

      return terrain && terrain.getEntity(_World["default"].get());
    }
  }]);
  return TypeSizeFormMenuItem;
}(_SizeFormMenuItem2["default"]);

var _default = TypeSizeFormMenuItem;
exports["default"] = _default;

},{"../../../../world/World.js":171,"../../entity/SizeFormMenuItem.js":87,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],114:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../../MenuItem.js"));

var _TypeBackgroundMenuItem = _interopRequireDefault(require("./TypeBackgroundMenuItem.js"));

var _Layout = _interopRequireDefault(require("../../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Terrain style Menu Item
 */
var TypeStyleMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(TypeStyleMenuItem, _MenuItem);

  var _super = _createSuper(TypeStyleMenuItem);

  function TypeStyleMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, TypeStyleMenuItem);
    _this = _super.call(this, {
      name: '',
      stateCode: '',
      type: _Layout["default"].type.PANEL,
      zone: parent.zone
    });
    _this.parent = parent;
    _this.items = [new _TypeBackgroundMenuItem["default"]((0, _assertThisInitialized2["default"])(_this))];
    return _this;
  }

  return TypeStyleMenuItem;
}(_MenuItem2["default"]);

var _default = TypeStyleMenuItem;
exports["default"] = _default;

},{"../../../Layout.js":57,"../../../MenuItem.js":59,"./TypeBackgroundMenuItem.js":109,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],115:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _FormMenuItem2 = _interopRequireDefault(require("../form/FormMenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {AddTextureFormMenuItem}
 */
var AddTextureFormMenuItem = /*#__PURE__*/function (_FormMenuItem) {
  (0, _inherits2["default"])(AddTextureFormMenuItem, _FormMenuItem);

  var _super = _createSuper(AddTextureFormMenuItem);

  function AddTextureFormMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, AddTextureFormMenuItem);
    _this = _super.call(this, {
      name: '',
      stateCode: '',
      type: _Layout["default"].type.FORM,
      zone: parent.zone
    });
    _this.parent = parent;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(AddTextureFormMenuItem, [{
    key: "getFields",
    value: function getFields() {
      return [{
        bind: 'texture',
        label: 'Add Texture',
        type: _Layout["default"].form.FILE
      }];
    }
    /**
     * @override
     */

  }, {
    key: "getFormObject",
    value: function getFormObject() {
      return _World["default"].get().getTextureManager();
    }
  }]);
  return AddTextureFormMenuItem;
}(_FormMenuItem2["default"]);

var _default = AddTextureFormMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../../Layout.js":57,"../form/FormMenuItem.js":91,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],116:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _ListFormMenuItem2 = _interopRequireDefault(require("../form/ListFormMenuItem.js"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {ListTextureFormMenuItem}
 */
var ListTextureFormMenuItem = /*#__PURE__*/function (_ListFormMenuItem) {
  (0, _inherits2["default"])(ListTextureFormMenuItem, _ListFormMenuItem);

  var _super = _createSuper(ListTextureFormMenuItem);

  function ListTextureFormMenuItem(parent, props) {
    (0, _classCallCheck2["default"])(this, ListTextureFormMenuItem);
    return _super.call(this, props);
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(ListTextureFormMenuItem, [{
    key: "getFormObject",
    value: function getFormObject() {
      return _World["default"].get().getTextureManager().getTextures();
    }
  }]);
  return ListTextureFormMenuItem;
}(_ListFormMenuItem2["default"]);

var _default = ListTextureFormMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../form/ListFormMenuItem.js":94,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],117:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _MenuItem2 = _interopRequireDefault(require("../../MenuItem.js"));

var _AddTextureFormMenuItem = _interopRequireDefault(require("./AddTextureFormMenuItem.js"));

var _UpdateTextureFormMenuItem = _interopRequireDefault(require("./UpdateTextureFormMenuItem.js"));

var _ListTextureFormMenuItem = _interopRequireDefault(require("./ListTextureFormMenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {TextureMenuItem}
 * Menu responsible for managing textures
 */
var TextureMenuItem = /*#__PURE__*/function (_MenuItem) {
  (0, _inherits2["default"])(TextureMenuItem, _MenuItem);

  var _super = _createSuper(TextureMenuItem);

  function TextureMenuItem() {
    var _this;

    (0, _classCallCheck2["default"])(this, TextureMenuItem);
    _this = _super.call(this, {
      name: 'Textures',
      stateCode: '',
      type: _Layout["default"].type.PANEL,
      zone: _Layout["default"].zone.RIGHT
    });
    _this.items = [new _AddTextureFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this)), new _ListTextureFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this)), new _UpdateTextureFormMenuItem["default"]((0, _assertThisInitialized2["default"])(_this))];
    return _this;
  }

  return TextureMenuItem;
}(_MenuItem2["default"]);

var _default = TextureMenuItem;
exports["default"] = _default;

},{"../../Layout.js":57,"../../MenuItem.js":59,"./AddTextureFormMenuItem.js":115,"./ListTextureFormMenuItem.js":116,"./UpdateTextureFormMenuItem.js":118,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],118:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _FormMenuItem2 = _interopRequireDefault(require("../form/FormMenuItem.js"));

var _Layout = _interopRequireDefault(require("../../Layout.js"));

var _World = _interopRequireDefault(require("../../../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {UpdateTextureFormMenuItem}
 */
var UpdateTextureFormMenuItem = /*#__PURE__*/function (_FormMenuItem) {
  (0, _inherits2["default"])(UpdateTextureFormMenuItem, _FormMenuItem);

  var _super = _createSuper(UpdateTextureFormMenuItem);

  function UpdateTextureFormMenuItem(parent) {
    var _this;

    (0, _classCallCheck2["default"])(this, UpdateTextureFormMenuItem);
    _this = _super.call(this, {
      name: '',
      stateCode: '',
      type: _Layout["default"].type.FORM,
      zone: parent.zone
    });
    _this.parent = parent;
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(UpdateTextureFormMenuItem, [{
    key: "getFields",
    value: function getFields() {
      return [{
        bind: 'name',
        label: 'Name',
        type: _Layout["default"].form.TEXT
      }];
    }
    /**
     * @override
     */

  }, {
    key: "getFormObject",
    value: function getFormObject() {
      return _World["default"].get().getTextureManager().getSelectedTexture();
    }
  }]);
  return UpdateTextureFormMenuItem;
}(_FormMenuItem2["default"]);

var _default = UpdateTextureFormMenuItem;
exports["default"] = _default;

},{"../../../world/World.js":171,"../../Layout.js":57,"../form/FormMenuItem.js":91,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],119:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Scene2 = _interopRequireDefault(require("./Scene.js"));

var _World = _interopRequireDefault(require("../world/World.js"));

var _ConstraintRunner = _interopRequireDefault(require("../runner/constraint/ConstraintRunner.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {Game}
 * @extends {Loop}
 */
var Game = /*#__PURE__*/function (_Scene) {
  (0, _inherits2["default"])(Game, _Scene);

  var _super = _createSuper(Game);

  /**
   * @type {Game}
   */
  function Game() {
    var _this;

    (0, _classCallCheck2["default"])(this, Game);
    _this = _super.call(this);
    _this.runners = [_ConstraintRunner["default"]];
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(Game, [{
    key: "init",
    value: function () {
      var _init = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var world;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return (0, _get2["default"])((0, _getPrototypeOf2["default"])(Game.prototype), "init", this).call(this);

              case 2:
                world = _World["default"].get();
                world.getPhysics().run(world);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
    /**
     * @override
     */

  }, {
    key: "loop",
    value: function loop() {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(Game.prototype), "loop", this).call(this);

      var world = _World["default"].get();

      world.getPhysics().update(world, world.getAiEngine());
      world.updateCamera();
    }
  }]);
  return Game;
}(_Scene2["default"]);

(0, _defineProperty2["default"])(Game, "instance", void 0);
var _default = Game;
exports["default"] = _default;

},{"../runner/constraint/ConstraintRunner.js":154,"../world/World.js":171,"./Scene.js":122,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/get":9,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/regenerator":25}],120:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

/**
 * @class {Loop}
 */
var Loop = /*#__PURE__*/function () {
  function Loop() {
    (0, _classCallCheck2["default"])(this, Loop);
    (0, _defineProperty2["default"])(this, "runners", void 0);
    this.loop = this.loop.bind(this);
    this.runners = [];
  }
  /**
   * @type {Class[]}
   */


  (0, _createClass2["default"])(Loop, [{
    key: "getRunners",

    /**
     * @return {Class[]}
     */
    value: function getRunners() {
      return this.runners;
    }
  }, {
    key: "init",
    value: function () {
      var _init = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                throw new TypeError('Loop.init must be implemented!');

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "loop",
    value: function loop() {
      throw new TypeError('Loop.loop must be implemented!');
    }
  }], [{
    key: "get",
    value: function get() {
      if (!this.instance) {
        this.instance = new this();
      }

      return this.instance;
    }
  }]);
  return Loop;
}();

var _default = Loop;
exports["default"] = _default;

},{"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/regenerator":25}],121:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Game2 = _interopRequireDefault(require("./Game.js"));

var _World = _interopRequireDefault(require("../world/World.js"));

var _Storage = _interopRequireDefault(require("../core/Storage.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {RunGame}
 * @extends {Game}
 */
var RunGame = /*#__PURE__*/function (_Game) {
  (0, _inherits2["default"])(RunGame, _Game);

  var _super = _createSuper(RunGame);

  function RunGame() {
    (0, _classCallCheck2["default"])(this, RunGame);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(RunGame, [{
    key: "init",

    /**
     * @type {PreviewGame}
     */

    /**
     * @override
     */
    value: function () {
      var _init = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _Storage["default"].get().load(_Storage["default"].type.WORLD, EngineWorldData.world, _World["default"].get());

              case 2:
                _context.next = 4;
                return (0, _get2["default"])((0, _getPrototypeOf2["default"])(RunGame.prototype), "init", this).call(this);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }]);
  return RunGame;
}(_Game2["default"]);

(0, _defineProperty2["default"])(RunGame, "instance", void 0);
var _default = RunGame;
exports["default"] = _default;

},{"../core/Storage.js":39,"../world/World.js":171,"./Game.js":119,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/get":9,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/regenerator":25}],122:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Loop2 = _interopRequireDefault(require("./Loop.js"));

var _ObjectRenderer = _interopRequireDefault(require("../renderer/ObjectRenderer.js"));

var _World = _interopRequireDefault(require("../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {Scene}
 * @extends {Loop}
 */
var Scene = /*#__PURE__*/function (_Loop) {
  (0, _inherits2["default"])(Scene, _Loop);

  var _super = _createSuper(Scene);

  /**
   * @type {Scene}
   */
  function Scene() {
    var _this;

    (0, _classCallCheck2["default"])(this, Scene);
    _this = _super.call(this);
    _this.objectRenderer = new _ObjectRenderer["default"]();
    return _this;
  }

  (0, _createClass2["default"])(Scene, [{
    key: "init",
    value: function () {
      var _init = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "loop",
    value: function loop() {
      var world = _World["default"].get();

      world.update();
      world.draw(this.objectRenderer);
      this.objectRenderer.render(world.getCamera());
    }
  }]);
  return Scene;
}(_Loop2["default"]);

(0, _defineProperty2["default"])(Scene, "instance", void 0);
var _default = Scene;
exports["default"] = _default;

},{"../renderer/ObjectRenderer.js":150,"../world/World.js":171,"./Loop.js":120,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/regenerator":25}],123:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _PhysicsData2 = _interopRequireDefault(require("../project/data/PhysicsData.js"));

var _MatterEngine = _interopRequireDefault(require("./engine/matter/MatterEngine.js"));

var _PhysicError = _interopRequireDefault(require("../exception/type/PhysicError.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var Physics = /*#__PURE__*/function (_PhysicsData) {
  (0, _inherits2["default"])(Physics, _PhysicsData);

  var _super = _createSuper(Physics);

  function Physics() {
    var _this;

    (0, _classCallCheck2["default"])(this, Physics);
    _this = _super.call(this);
    _this.physicsEngine = new _MatterEngine["default"]();

    _this.physicsEngine.setPhysicsManager((0, _assertThisInitialized2["default"])(_this));

    _this.toRestart = false;
    _this.isRunning = false;
    return _this;
  }
  /**
   * Update physics, and train AI
   * @param {World} world
   * @param {AiEngine} aiEngine
   */


  (0, _createClass2["default"])(Physics, [{
    key: "update",
    value: function update(world, aiEngine) {
      if (this.toRestart) {
        this.restart(world);
      } else {
        this.updateEntities(world);
        this.updateEngine(world, aiEngine);
      }
    }
    /**
     * Update entities props from Physics engine results
     * @param {World} world
     */

  }, {
    key: "updateEntities",
    value: function updateEntities(world) {
      var _this2 = this;

      var entityManager = world.getEntityManager();
      var bodyEntities = entityManager.getBodyEntities();
      var jointEntites = entityManager.getAttachEntities();
      this.physicsEngine.getBodies().map(function (body, index) {
        var entity = bodyEntities[index];

        var _entity$fromCenterPos = entity.fromCenterPosition(body.position),
            x = _entity$fromCenterPos.x,
            y = _entity$fromCenterPos.y;

        var rotation = body.angle ? body.angle % (Math.PI * 2) : 0;
        entity.setPosition({
          x: parseInt(x),
          y: parseInt(y)
        });
        entity.setRotationAndGenerate(Math.round(rotation * 100) / 100);
        entity.setVelocity(body.velocity);
        entity.setAngularVelocity(body.angularVelocity);
        entityManager.haveToDie(entity, _this2.physicsEngine);
      });
      this.physicsEngine.getJoints().map(function (joint, index) {
        var entity = jointEntites[index];
        var pointA = entity.entities.a ? entity.entities.a.fromRelativeCenterPosition(joint.pointA) : joint.pointA;
        var pointB = entity.entities.b ? entity.entities.b.fromRelativeCenterPosition(joint.pointB) : joint.pointB;
        entity.updatePoints(pointA, pointB);
      });
    }
    /**
     * Update the World using AI and physics Engine
     * @param {World} world
     * @param {AiEngine} aiEngine
     * @TODO: updating the constraint entities crash the physics, to be revisited
     */

  }, {
    key: "updateEngine",
    value: function updateEngine(world, aiEngine) {
      var _this3 = this;

      var entityManager = world.getEntityManager();
      entityManager.getAttachEntities().forEach(function (entity) {
        _this3.physicsEngine.update(entity);
      });
      entityManager.getBodyEntities().forEach(function (entity) {
        _this3.physicsEngine.update(entity);
      });
      this.physicsEngine.updateEngine();
      aiEngine && aiEngine.update();
    }
    /**
     * @param {AttachEntity} entity
     * @param {Constraint} constraint
     */

  }, {
    key: "updateConstraint",
    value: function updateConstraint(entity, constraint) {
      var shape = this.physicsEngine.findShapeFromEntity(entity);

      if (shape) {
        this.physicsEngine.updateConstraint(entity, constraint);
      } else {
        throw new _PhysicError["default"]("Shape not founded for the constraint entity ".concat(entity.id));
      }
    }
    /**
     * Get the body phyiscs from the given entity
     * @param {Entity} entity
     */

  }, {
    key: "getBodyFromEntity",
    value: function getBodyFromEntity(entity) {
      var shape = this.physicsEngine.findShapeFromEntity(entity);
      var bodies = this.physicsEngine.getBodies();
      var joints = this.physicsEngine.getJoints();

      if (!shape || !bodies.includes(shape) && !joints.includes(shape)) {
        throw new _PhysicError["default"]("Shape not founded for the entity ".concat(entity.id));
      }

      return shape;
    }
    /**
     * Get an entity from an ID
     * @param {World} world
     * @param {number} entityId
     */

  }, {
    key: "getEntityById",
    value: function getEntityById(world, entityId) {
      return world.getEntityManager().findById(entityId);
    }
    /**
     * Stop the engine
     */

  }, {
    key: "stop",
    value: function stop() {
      this.physicsEngine.stop();
      this.isRunning = false;
    }
    /**
     * Unload the physics for entities
     * @param {World} world
     */

  }, {
    key: "unload",
    value: function unload(world) {
      var _this4 = this;

      world.getEntityManager().entities.map(function (entity) {
        return entity.unloadPhysics(_this4.physicsEngine);
      });
    }
    /**
     * Load the physics for entities
     * @param {World} world
     */

  }, {
    key: "load",
    value: function load(world) {
      return this.before(world) && this.setup(world) && this.after(world);
    }
    /**
     * Init the phyiscs for entities before loading
     * @param {World} world
     */

  }, {
    key: "before",
    value: function before(world) {
      var _this5 = this;

      var jointEntities = world.getEntityManager().getAttachEntities();
      jointEntities.map(function (entity) {
        return entity.updateJointPosition(world, _this5.physicsEngine);
      });
      return true;
    }
    /**
     * Setup the physics for entities
     * @param {World} world
     */

  }, {
    key: "setup",
    value: function setup(world) {
      var _this6 = this;

      var entityManager = world.getEntityManager();
      var bodyEntities = entityManager.getBodyEntities();
      var attachEntities = entityManager.getAttachEntities();
      bodyEntities.map(function (entity) {
        return entity.loadPhysics(_this6.physicsEngine);
      });
      attachEntities.map(function (entity) {
        return entity.loadPhysics(_this6.physicsEngine);
      });
      return true;
    }
    /**
     * Complete the physics after setup
     * @param {World} world
     */

  }, {
    key: "after",
    value: function after(world) {
      var _this7 = this;

      var bodyEntities = world.getEntityManager().getBodyEntities();
      bodyEntities.map(function (entity) {
        return entity.updateCollisionFilters(_this7.physicsEngine);
      });
      return true;
    }
    /**
     * Run the physics
     * @param {World} world
     */

  }, {
    key: "run",
    value: function run(world) {
      this.unload(world);
      this.physicsEngine.init();
      this.load(world);
      this.physicsEngine.run(world);
      this.isRunning = true;
    }
    /**
     * Remove an entity from physics engine
     * @param {Entity} entity
     */

  }, {
    key: "loadEntity",
    value: function loadEntity(entity) {
      if (this.isRunning) {
        entity.loadPhysics(this.physicsEngine);
      }
    }
    /**
     * Remove an entity from physics engine
     * @param {Entity} entity
     */

  }, {
    key: "unloadEntity",
    value: function unloadEntity(entity) {
      if (this.isRunning) {
        entity.unloadPhysics(this.physicsEngine);
      }
    }
    /**
     * Flag the physics to restart
     * @param {Boolean} toRestart
     */

  }, {
    key: "setToRestart",
    value: function setToRestart(toRestart) {
      this.toRestart = toRestart;
    }
    /**
     * @param {PhysicsEngine} physicsEngine
     */

  }, {
    key: "setPhysicsEngine",
    value: function setPhysicsEngine(physicsEngine) {
      this.physicsEngine = physicsEngine;
    }
    /**
     * @param {boolean} value
     */

  }, {
    key: "setIsRunning",
    value: function setIsRunning(value) {
      this.isRunning = value;
    }
    /**
     * Restart the engine
     * @param {World} world
     */

  }, {
    key: "restart",
    value: function restart(world) {
      this.stop();
      this.run(world);
      this.setToRestart(false);
    }
  }]);
  return Physics;
}(_PhysicsData2["default"]);

var _default = Physics;
exports["default"] = _default;

},{"../exception/type/PhysicError.js":56,"../project/data/PhysicsData.js":144,"./engine/matter/MatterEngine.js":127,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],124:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Physics Engine class
 * Used as interface between the application and engine (third party Engine)
 * @abstract
 */
var PhysicsEngine = /*#__PURE__*/function () {
  function PhysicsEngine() {
    (0, _classCallCheck2["default"])(this, PhysicsEngine);

    if (this.constructor === PhysicsEngine) {
      throw new TypeError('Abstract class PhysicsEngine cannot be instantiated directly');
    }

    this.mapShapeToEntity = [];
  }
  /**
   * Initialize the engine.
   */


  (0, _createClass2["default"])(PhysicsEngine, [{
    key: "init",
    value: function init() {
      throw new TypeError('"init" method must be implemented');
    }
    /**
     * Add physics to the entity.
     * @param {Entity} entity
     */

  }, {
    key: "add",
    value: function add(entity) {
      this.mapShapeToEntity.push({
        entityId: entity.id,
        shape: this.loadShape(entity)
      });
    }
    /**
     * Get the shape for entity.
     * @param {Entity} entity
     * @return {Body}
     */

  }, {
    key: "loadShape",
    value: function loadShape(entity) {
      throw new TypeError('"loadShape" method must be implemented');
    }
    /**
     * Update physics of the body from the entity.
     * @param {Entity} entity
     */

  }, {
    key: "update",
    value: function update(entity) {
      throw new TypeError('"update" method must be implemented');
    }
    /**
     * Get the Engine (third party)
     * @return {*}
     */

  }, {
    key: "getEngine",
    value: function getEngine() {
      throw new TypeError('"getEngine" method must be implemented');
    }
    /**
     * Run the physics engine.
     */

  }, {
    key: "run",
    value: function run() {
      throw new TypeError('"run" method must be implemented');
    }
    /**
     * Stop the physics engine and reset the mapping.
     */

  }, {
    key: "stop",
    value: function stop() {
      this.stopEngine();
      this.mapShapeToEntity = [];
    }
    /**
     * Stop the physics engine.
     */

  }, {
    key: "stopEngine",
    value: function stopEngine() {
      throw new TypeError('"stopEngine" method must be implemented');
    }
    /**
     * Update the physics engine.
     */

  }, {
    key: "updateEngine",
    value: function updateEngine() {
      throw new TypeError('"updatEngine" method must be implemented');
    }
    /**
     * Get bodies informations (position, ...)
     * @return {*[]}
     */

  }, {
    key: "getBodies",
    value: function getBodies() {
      throw new TypeError('"getBodies" method must be implemented');
    }
    /**
     * Get joints information (position, ...)
     * @return {*[]}
     */

  }, {
    key: "getJoints",
    value: function getJoints() {
      throw new TypeError('"getJoints" method must be implemented');
    }
    /**
     * Create new group of collision
     * @return {*}
     */

  }, {
    key: "newGroup",
    value: function newGroup() {
      throw new TypeError('"newGroup" method must be implemented');
    }
    /**
     * Update collision filters for the entity.
     * @param {Entity} entity
     */

  }, {
    key: "updateCollisionFilters",
    value: function updateCollisionFilters(entity) {
      throw new TypeError('"updateCollisionFilters" method must be implemented');
    }
    /**
     * Update constraint bodies using the given constraint param
     * @param {Entity} entity
     * @param {Constraint} constraint
     */

  }, {
    key: "updateConstraint",
    value: function updateConstraint(entity, constraint) {
      throw new TypeError('"updateConstraint" method must be implemented');
    }
    /**
     * Apply force to the entity
     * @param {Object} body
     * @param {EntityMotion} entity
     */

  }, {
    key: "applyPhysics",
    value: function applyPhysics(body, entity) {
      throw new TypeError('"applyForce" method must be implemented');
    }
    /**
     * Remove the entity from physics engine
     * @param {Entity} entity
     * @abstract
     */

  }, {
    key: "removeShape",
    value: function removeShape(entity) {
      throw new TypeError('"removeShape" method must be implemented');
    }
    /**
     * Check if two entity collide
     * @abstract
     * @param {Number} entityAId
     * @param {Number} entityBId
     */

  }, {
    key: "isCollide",
    value: function isCollide(entityAId, entityBId) {
      throw new TypeError('"isCollide" method must be implemented');
    }
    /**
     * Set the physics manager that loaded the phyiscs engine
     * @param {Physics} physicsManager
     */

  }, {
    key: "setPhysicsManager",
    value: function setPhysicsManager(physicsManager) {
      this.physicsManager = physicsManager;
    }
    /**
     * Get the physics manager that loaded the phyiscs engine
     */

  }, {
    key: "getPhysicsManager",
    value: function getPhysicsManager() {
      return this.physicsManager;
    }
    /**
     * Get body physics from the entity
     * @param {Entity} entity
     */

  }, {
    key: "getBodyFromEntity",
    value: function getBodyFromEntity(entity) {
      return this.physicsManager.getBodyFromEntity(entity);
    }
    /**
     * Find the shape from the entity
     * @param {Entity} entity
     */

  }, {
    key: "findShapeFromEntity",
    value: function findShapeFromEntity(entity) {
      var shapeEntity = this.mapShapeToEntity.find(function (mShape) {
        return mShape.entityId === parseInt(entity.id);
      });
      return shapeEntity && shapeEntity.shape;
    }
    /**
     * Update constraint position
     * @abstract
     * @param {World} world
     * @param {Entity} entity
     * @return {boolean}
     */

  }, {
    key: "updateJointPosition",
    value: function updateJointPosition(world, entity) {
      throw new TypeError('"updateJointPosition" method must be implemented');
    }
  }]);
  return PhysicsEngine;
}();

var _default = PhysicsEngine;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],125:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _AttachEntity = _interopRequireDefault(require("../../entity/types/constraint/AttachEntity.js"));

/**
 * Shape class
 * Used as interface between an Entity (managed by the app)
 * and Body (managed by the Engine).
 * Used to synchronize information between the Body and related Entity
 * @abstract
 *
 * @property {Shape} instance
 */
var Shape = /*#__PURE__*/function () {
  function Shape(physicEngine) {
    (0, _classCallCheck2["default"])(this, Shape);

    if (this.constructor === Shape) {
      throw new TypeError('Abstract class Shape cannot be instantiated directly');
    }

    this.physicEngine = physicEngine;
  }
  /**
   * Generate the body for the given entity
   * @param {EntityMotion} entity
   * @return {Body}
   */


  (0, _createClass2["default"])(Shape, [{
    key: "generate",
    value: function generate(entity) {
      throw new TypeError('"Shape.generate" method must be implemented');
    }
    /**
     * Load the body for the given entity, and update physics
     * @param {Entity} entity
     * @return {Body}
     */

  }, {
    key: "load",
    value: function load(entity) {
      var body = this.generate(entity);
      this.setup(entity, body);
      this.update(entity, body);
      return body;
    }
    /**
     * Get the body physics from the entity
     * @param {Entity} entity
     * @return {Body | Constraint}
     */

  }, {
    key: "getBodyFromEntity",
    value: function getBodyFromEntity(entity) {
      return this.physicEngine.getBodyFromEntity(entity);
    }
    /**
     * Get the engine (third party)
     */

  }, {
    key: "getEngine",
    value: function getEngine() {
      return this.physicEngine.getEngine();
    }
    /**
     * Setup the body for the given entity
     * @param {EntityMotion} entity
     * @param {Matter.Body} body
     */

  }, {
    key: "setup",
    value: function setup(entity, body) {
      entity.isControlled() && entity.setCollisionGroup(-1);
      body.isStatic = body.isStatic || entity.isControlled() || entity.isFixed();
    }
    /**
     * Synchronize informations from entity to body
     * Do not apply force to Attach entities
     * @param {EntityMotion | AttachEntity} entity
     * @param {Body | Constraint} physicEntity
     */

  }, {
    key: "update",
    value: function update(entity, physicEntity) {
      if (!(entity instanceof _AttachEntity["default"])) {
        this.physicEngine.applyPhysics(physicEntity, entity);
      }
    }
    /**
     * Get the instance of type using the given physics engine
     * @param {Shape} type
     * @param {PhysicsEngine} physicEngine
     *
     * @return {Shape}
     */

  }], [{
    key: "get",
    value: function get(type) {
      var physicEngine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (physicEngine && !type.instance) {
        type.instance = new type(physicEngine);
      }

      return type.instance;
    }
  }]);
  return Shape;
}();

var _default = Shape;
exports["default"] = _default;

},{"../../entity/types/constraint/AttachEntity.js":45,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],126:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _Entity = _interopRequireDefault(require("../../entity/Entity.js"));

var _RectangleShape = _interopRequireDefault(require("./matter/shapes/RectangleShape.js"));

var _EllipseShape = _interopRequireDefault(require("./matter/shapes/EllipseShape.js"));

var _PolyShape = _interopRequireDefault(require("./matter/shapes/PolyShape.js"));

var _CircleShape = _interopRequireDefault(require("./matter/shapes/CircleShape.js"));

var _JointShape = _interopRequireDefault(require("./matter/shapes/JointShape.js"));

var _Shape = _interopRequireDefault(require("./Shape.js"));

/**
 * Shape Loader class
 * Manage and load shapes
 *
 * @property {Object<string, Shape>} mapShapes
 */
var ShapeLoader = /*#__PURE__*/function () {
  function ShapeLoader(physicEngine) {
    var _this$mapShapes;

    (0, _classCallCheck2["default"])(this, ShapeLoader);
    this.mapShapes = (_this$mapShapes = {}, (0, _defineProperty2["default"])(_this$mapShapes, _Entity["default"].shapes.RECT, _RectangleShape["default"]), (0, _defineProperty2["default"])(_this$mapShapes, _Entity["default"].shapes.ELLIPSE, _EllipseShape["default"]), (0, _defineProperty2["default"])(_this$mapShapes, _Entity["default"].shapes.POLY, _PolyShape["default"]), (0, _defineProperty2["default"])(_this$mapShapes, _Entity["default"].shapes.CIRCLE, _CircleShape["default"]), (0, _defineProperty2["default"])(_this$mapShapes, _Entity["default"].shapes.ATTACH, _JointShape["default"]), _this$mapShapes);
    this.physicEngine = physicEngine;
  }
  /**
   * Load entity shape to the Engine world
   * @param {Entity} entity
   *
   * @return {Body}
   */


  (0, _createClass2["default"])(ShapeLoader, [{
    key: "load",
    value: function load(entity) {
      if (!this.mapShapes.hasOwnProperty(entity.shape)) {
        throw new TypeError("Shape ".concat(entity.shape, " is not configured"));
      }

      var type = this.mapShapes[entity.shape];
      return type && _Shape["default"].get(type, this.physicEngine).load(entity);
    }
    /**
     * Update the physics props from entity
     * @param {Entity} entity
     */

  }, {
    key: "update",
    value: function update(entity) {
      var type = this.mapShapes[entity.shape];
      var body = this.physicEngine.getBodyFromEntity(entity);
      return _Shape["default"].get(type).update(entity, body);
    }
  }]);
  return ShapeLoader;
}();

var _default = ShapeLoader;
exports["default"] = _default;

},{"../../entity/Entity.js":42,"./Shape.js":125,"./matter/shapes/CircleShape.js":128,"./matter/shapes/EllipseShape.js":129,"./matter/shapes/JointShape.js":130,"./matter/shapes/PolyShape.js":131,"./matter/shapes/RectangleShape.js":132,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12}],127:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _PhysicsEngine2 = _interopRequireDefault(require("../PhysicsEngine.js"));

var _ShapeLoader = _interopRequireDefault(require("../ShapeLoader.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Matter Physics Engine class
 * @extends {PhysicsEngine}
 */
var MatterEngine = /*#__PURE__*/function (_PhysicsEngine) {
  (0, _inherits2["default"])(MatterEngine, _PhysicsEngine);

  var _super = _createSuper(MatterEngine);

  function MatterEngine() {
    (0, _classCallCheck2["default"])(this, MatterEngine);
    return _super.call(this);
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(MatterEngine, [{
    key: "init",
    value: function init() {
      this.engine = Matter.Engine.create();
      this.shapeLoader = new _ShapeLoader["default"](this);
    }
    /**
     * @override
     */

  }, {
    key: "loadShape",
    value: function loadShape(entity) {
      var shape = this.shapeLoader.load(entity);
      Matter.World.add(this.engine.world, shape);
      return shape;
    }
    /**
     * @override
     */

  }, {
    key: "update",
    value: function update(entity) {
      this.shapeLoader.update(entity);
    }
    /**
     * Run the physics engine
     */

  }, {
    key: "run",
    value: function run() {//Matter.Engine.run(this.engine)
    }
    /**
     * Stop the physics engine
     */

  }, {
    key: "stopEngine",
    value: function stopEngine() {
      Matter.World.clear(this.engine.world);
      Matter.Engine.clear(this.engine);
      this.engine = null;
    }
    /**
     * @override
     */

  }, {
    key: "updateEngine",
    value: function updateEngine() {
      Matter.Engine.update(this.engine);
    }
    /**
     * @override
     */

  }, {
    key: "getEngine",
    value: function getEngine() {
      return Matter;
    }
    /**
     * @override
     */

  }, {
    key: "getBodies",
    value: function getBodies() {
      return Matter.Composite.allBodies(this.engine.world);
    }
    /**
     * @override
     */

  }, {
    key: "getJoints",
    value: function getJoints() {
      return Matter.Composite.allConstraints(this.engine.world);
    }
    /**
     * @override
     */

  }, {
    key: "newGroup",
    value: function newGroup() {
      return Matter.Body.nextGroup(true);
    }
    /**
     * @override
     */

  }, {
    key: "updateCollisionFilters",
    value: function updateCollisionFilters(entity) {
      var body = this.getBodyFromEntity(entity);
      body.collisionFilter = entity.collision;
      return true;
    }
    /**
     * @override
     */

  }, {
    key: "updateJointPosition",
    value: function updateJointPosition(world, entity) {
      var vertices = entity.vertices,
          entities = entity.entities;
      var pointA = entity.toAbsolutePosition(vertices[0]);
      var pointB = entity.toAbsolutePosition(vertices[1]);

      if (entity.attached) {
        entities.a && entities.a.movePointTo(pointA, pointB);
        entity.movePointTo(pointA, pointB);
        entity.updatePoints(pointB, {
          x: pointB.x + 1,
          y: pointB.y + 1
        });
        return true;
      }

      return false;
    }
    /**
     * @override
     */

  }, {
    key: "updateConstraint",
    value: function updateConstraint(entity, constraint) {
      var entityB = constraint.entityB,
          pointA = constraint.pointA,
          pointB = constraint.pointB;
      var body = this.getBodyFromEntity(entity);
      var bodyB = entityB && this.getBodyFromEntity(entityB);

      if (entityB && !bodyB) {
        throw new TypeError("updateConstraint failed! Body not found for entity ".concat(entity.id));
      }

      body.bodyB = bodyB;
      body.angleB = bodyB && bodyB.angle;
      body.pointA = pointA;
      body.pointB = pointB;
    }
    /**
     * @override
     * @todo Implement an intelligent controlling physics
     */

  }, {
    key: "applyPhysics",
    value: function applyPhysics(body, entity) {
      var force = entity.physics.force;

      if (entity.isControlled()) {
        var moveSpeed = 2;
        this.getEngine().Body.setPosition(body, {
          x: body.position.x + moveSpeed,
          y: body.position.y
        });
      } else {
        this.getEngine().Body.applyForce(body, entity.getForcePosition(), force);
      }
    }
    /**
     * @override
     */

  }, {
    key: "removeShape",
    value: function removeShape(entity) {
      var body = this.getBodyFromEntity(entity);
      this.getEngine().World.remove(this.engine.world, body);
    }
    /**
     * @override
     */

  }, {
    key: "isCollide",
    value: function isCollide(entityAId, entityBId) {
      var physicsManager = this.getPhysicsManager();
      var entityA = physicsManager.getEntityById(entityAId);
      var entityB = physicsManager.getEntityById(entityBId);

      if (!entityA || !entityB) {
        throw new TypeError("Cannot check collision - entity not founded (A: ".concat(!!entityA, ", B: ").concat(!!entityB, ")"));
      }

      var bodyA = this.getBodyFromEntity(entityA);
      var bodyB = this.getBodyFromEntity(entityB);

      if (!bodyA || !bodyB) {
        throw new TypeError("Cannot check collision - body not founded (A: ".concat(!!bodyA, ", B: ").concat(!!bodyB, ")"));
      }

      var collision = Matter.SAT.collides(bodyA, bodyB);
      return collision.collided;
    }
  }]);
  return MatterEngine;
}(_PhysicsEngine2["default"]);

var _default = MatterEngine;
exports["default"] = _default;

},{"../PhysicsEngine.js":124,"../ShapeLoader.js":126,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],128:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Shape2 = _interopRequireDefault(require("../../Shape.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Circle Shape class
 * Define the shape for circles (CircleEntity)
 */
var CircleShape = /*#__PURE__*/function (_Shape) {
  (0, _inherits2["default"])(CircleShape, _Shape);

  var _super = _createSuper(CircleShape);

  function CircleShape() {
    (0, _classCallCheck2["default"])(this, CircleShape);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(CircleShape, [{
    key: "generate",

    /**
     * @override
     */
    value: function generate(entity) {
      var centerPosition = entity.toCenterPosition();
      var engine = this.getEngine();
      return engine.Bodies.circle(centerPosition.x, centerPosition.y, entity.radius);
    }
  }]);
  return CircleShape;
}(_Shape2["default"]);

var _default = CircleShape;
exports["default"] = _default;

},{"../../Shape.js":125,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],129:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Shape2 = _interopRequireDefault(require("../../Shape.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var EllipseShape = /*#__PURE__*/function (_Shape) {
  (0, _inherits2["default"])(EllipseShape, _Shape);

  var _super = _createSuper(EllipseShape);

  function EllipseShape() {
    (0, _classCallCheck2["default"])(this, EllipseShape);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(EllipseShape, [{
    key: "generate",
    value: function generate(entity, bodies) {
      var centerPosition = entity.toCenterPosition();
      var maxRadiusSqr = Math.pow(Math.max(entity.radius.x, entity.radius.y), 2);
      var minRadiusSqr = Math.pow(Math.min(entity.radius.x, entity.radius.y), 2);

      var ellipseFunc = function ellipseFunc(x) {
        return Math.sqrt((maxRadiusSqr * minRadiusSqr - minRadiusSqr * Math.pow(x, 2)) / maxRadiusSqr);
      };

      var vertices = [];

      for (var x = 0; x < entity.size.width; x += 1) {
        vertices.push({
          x: x,
          y: Math.ceil(ellipseFunc(x - entity.size.width / 2) || 0)
        });
      }

      for (var _x = entity.size.width - 2; _x > 0; _x -= 1) {
        vertices.push({
          x: _x,
          y: Math.ceil(ellipseFunc(_x - entity.size.width / 2) || 0) * -1
        });
      }

      return bodies.fromVertices(centerPosition.x, centerPosition.y, vertices);
    }
  }]);
  return EllipseShape;
}(_Shape2["default"]);

var _default = EllipseShape;
exports["default"] = _default;

},{"../../Shape.js":125,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],130:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Shape2 = _interopRequireDefault(require("../../Shape.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Joint Shape class
 * Define a Shape for AttachEntity type
 */
var JointShape = /*#__PURE__*/function (_Shape) {
  (0, _inherits2["default"])(JointShape, _Shape);

  var _super = _createSuper(JointShape);

  function JointShape() {
    (0, _classCallCheck2["default"])(this, JointShape);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(JointShape, [{
    key: "generate",

    /**
     * @override
     */
    value: function generate(entity) {
      var engine = this.getEngine();
      entity.attached && this.addGroup(entity);
      return engine.Constraint.create(this.getConstraint(entity));
    }
    /**
     * @param {EntityMotion} entity
     * @return {Object}
     */

  }, {
    key: "getConstraint",
    value: function getConstraint(entity) {
      var vertices = entity.vertices,
          entities = entity.entities;
      var bodyA = entities.a && this.getBodyFromEntity(entities.a);
      var bodyB = entities.b && this.getBodyFromEntity(entities.b);
      var pointA = entities.a ? entities.a.getRelativeCenterPosition(entity, vertices[0]) : entity.fromRelativePosition(vertices[0]);
      var pointB = entities.b ? entities.b.getRelativeCenterPosition(entity, vertices[1]) : entity.fromRelativePosition(vertices[1]);
      var _entity$physics = entity.physics,
          stiffness = _entity$physics.stiffness,
          angularStiffness = _entity$physics.angularStiffness,
          angleA = _entity$physics.angleA,
          angleB = _entity$physics.angleB;

      if (entities.a && !bodyA || entities.b && !bodyB) {
        throw new ReferenceError('Body not yet created or entity not founded');
      }

      return {
        bodyA: bodyA,
        pointA: pointA,
        bodyB: bodyB,
        pointB: pointB,
        stiffness: stiffness,
        angularStiffness: angularStiffness,
        angleA: angleA,
        angleB: angleB
      };
    }
    /**
     * Add the constraint and the attached entities to the same collision group
     * (disable collision between attached bodies)
     * @param {Entity} entity
     */

  }, {
    key: "addGroup",
    value: function addGroup(entity) {
      var collisionGroup = entity.collision.group || entity.entities.a && entity.entities.a.collision.group || entity.entities.b && entity.entities.b.collision.group || this.physicEngine.newGroup();
      entity.collision.group = collisionGroup;
      entity.entities.a && (entity.entities.a.collision.group = collisionGroup);
      entity.entities.b && (entity.entities.b.collision.group = collisionGroup);
    }
  }]);
  return JointShape;
}(_Shape2["default"]);

var _default = JointShape;
exports["default"] = _default;

},{"../../Shape.js":125,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],131:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Shape2 = _interopRequireDefault(require("../../Shape.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var PolyShape = /*#__PURE__*/function (_Shape) {
  (0, _inherits2["default"])(PolyShape, _Shape);

  var _super = _createSuper(PolyShape);

  function PolyShape() {
    (0, _classCallCheck2["default"])(this, PolyShape);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(PolyShape, [{
    key: "generate",

    /**
     * @override
     */
    value: function generate(entity) {
      var centerPosition = entity.toCenterPosition();
      var engine = this.getEngine();
      return engine.Bodies.fromVertices(centerPosition.x, centerPosition.y, entity.vertices);
    }
  }]);
  return PolyShape;
}(_Shape2["default"]);

var _default = PolyShape;
exports["default"] = _default;

},{"../../Shape.js":125,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],132:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Shape2 = _interopRequireDefault(require("../../Shape.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Rectangle Shape class
 * Define the shape for rectangles (RectEntity)
 */
var RectangleShape = /*#__PURE__*/function (_Shape) {
  (0, _inherits2["default"])(RectangleShape, _Shape);

  var _super = _createSuper(RectangleShape);

  function RectangleShape() {
    (0, _classCallCheck2["default"])(this, RectangleShape);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(RectangleShape, [{
    key: "generate",

    /**
     * @override
     */
    value: function generate(entity) {
      var centerPosition = entity.toCenterPosition();
      var engine = this.getEngine();
      return engine.Bodies.rectangle(centerPosition.x, centerPosition.y, entity.size.width, entity.size.height, {
        density: entity.physics.density,
        angle: entity.rotation
      });
    }
  }]);
  return RectangleShape;
}(_Shape2["default"]);

var _default = RectangleShape;
exports["default"] = _default;

},{"../../Shape.js":125,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],133:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var EntityProps = /*#__PURE__*/function () {
  function EntityProps() {
    (0, _classCallCheck2["default"])(this, EntityProps);
    (0, _defineProperty2["default"])(this, "style", void 0);
    (0, _defineProperty2["default"])(this, "name", void 0);
    (0, _defineProperty2["default"])(this, "position", void 0);
    (0, _defineProperty2["default"])(this, "rotation", void 0);
    (0, _defineProperty2["default"])(this, "size", void 0);
    (0, _defineProperty2["default"])(this, "advancedStyle", void 0);
    (0, _defineProperty2["default"])(this, "noiseConfigs", void 0);
  }

  (0, _createClass2["default"])(EntityProps, [{
    key: "setAdvancedStyle",

    /**
     * @param {Style} advancedStyle
     */
    value: function setAdvancedStyle(advancedStyle) {
      this.advancedStyle = advancedStyle;
    }
    /**
     * @return {Style}
     */

  }, {
    key: "getAdvancedStyle",
    value: function getAdvancedStyle() {
      return this.advancedStyle;
    }
    /**
     * @param {PerlinNoiseConfig} noiseConfigs
     */

  }, {
    key: "setNoiseConfigs",
    value: function setNoiseConfigs(noiseConfigs) {
      this.noiseConfigs = noiseConfigs;
    }
    /**
     * @return {PerlinNoiseConfig}
     */

  }, {
    key: "getNoiseConfigs",
    value: function getNoiseConfigs() {
      return this.noiseConfigs;
    }
    /**
     * @param {string} name
     */

  }, {
    key: "setName",
    value: function setName(name) {
      this.name = name;
    }
    /**
     * @return {string}
     */

  }, {
    key: "getName",
    value: function getName() {
      return this.name;
    }
    /**
     * Set the entity's position
     * @param {Vector} position
     */

  }, {
    key: "setPosition",
    value: function setPosition(position) {
      this.position = position;
    }
    /**
     * @return {Vector}
     */

  }, {
    key: "getPosition",
    value: function getPosition() {
      return this.position;
    }
    /**
     * @param {Size} value
     */

  }, {
    key: "setSize",
    value: function setSize(value) {
      this.size = value;
    }
    /**
     * @return {Size}
     */

  }, {
    key: "getSize",
    value: function getSize() {
      return this.size;
    }
    /**
     * @param {string} style
     */

  }, {
    key: "setStyle",
    value: function setStyle(style) {
      this.style = style;
    }
    /**
     * @return {string}
     */

  }, {
    key: "getStyle",
    value: function getStyle() {
      return this.style;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setRotation",
    value: function setRotation(value) {
      this.rotation = value;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getRotation",
    value: function getRotation() {
      return this.rotation;
    }
  }]);
  return EntityProps;
}();

var _default = EntityProps;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12}],134:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * @class {PerlinNoiseConfig}
 */
var PerlinNoiseConfig = /*#__PURE__*/function () {
  function PerlinNoiseConfig() {
    (0, _classCallCheck2["default"])(this, PerlinNoiseConfig);
    this.seed = null;
    this.octaves = null;
    this.amplitude = null;
    this.persistence = null;
    this.smoothness = null;
  }
  /**
   * @param {number} value
   */


  (0, _createClass2["default"])(PerlinNoiseConfig, [{
    key: "setSeed",
    value: function setSeed(value) {
      this.seed = value;
    }
    /**
     * @returns {number}
     */

  }, {
    key: "getSeed",
    value: function getSeed() {
      return this.seed;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setOctaves",
    value: function setOctaves(value) {
      this.octaves = value;
    }
    /**
     * @returns {number}
     */

  }, {
    key: "getOctaves",
    value: function getOctaves() {
      return this.octaves;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setAmplitude",
    value: function setAmplitude(value) {
      this.amplitude = value;
    }
    /**
     * @returns {number}
     */

  }, {
    key: "getAmplitude",
    value: function getAmplitude() {
      return this.amplitude;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setPersistence",
    value: function setPersistence(value) {
      this.persistence = value;
    }
    /**
     * @returns {number}
     */

  }, {
    key: "getPersistence",
    value: function getPersistence() {
      return this.persistence;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setSmoothness",
    value: function setSmoothness(value) {
      this.smoothness = value;
    }
    /**
     * @returns {number}
     */

  }, {
    key: "getSmoothness",
    value: function getSmoothness() {
      return this.smoothness;
    }
  }]);
  return PerlinNoiseConfig;
}();

var _default = PerlinNoiseConfig;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],135:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var PhysicsProps = /*#__PURE__*/function () {
  function PhysicsProps() {
    (0, _classCallCheck2["default"])(this, PhysicsProps);
    (0, _defineProperty2["default"])(this, "velocity", void 0);
    (0, _defineProperty2["default"])(this, "angularVelocity", void 0);
    (0, _defineProperty2["default"])(this, "speed", void 0);
    (0, _defineProperty2["default"])(this, "density", void 0);
    (0, _defineProperty2["default"])(this, "force", void 0);
    (0, _defineProperty2["default"])(this, "fixed", void 0);
    (0, _defineProperty2["default"])(this, "motion", void 0);
  }

  (0, _createClass2["default"])(PhysicsProps, [{
    key: "setVelocity",

    /**
     * @param {Vector} velocity
     */
    value: function setVelocity(velocity) {
      this.velocity = velocity;
    }
    /**
     * @return {Vector}
     */

  }, {
    key: "getVelocity",
    value: function getVelocity() {
      return this.velocity;
    }
    /**
     * @param {number} angularVelocity
     */

  }, {
    key: "setAngularVelocity",
    value: function setAngularVelocity(angularVelocity) {
      this.angularVelocity = angularVelocity;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getAngularVelocity",
    value: function getAngularVelocity() {
      return this.angularVelocity;
    }
    /**
     * @param {number} speed
     */

  }, {
    key: "setSpeed",
    value: function setSpeed(speed) {
      this.speed = speed;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getSpeed",
    value: function getSpeed() {
      return this.speed;
    }
    /**
     * @param {number} density
     */

  }, {
    key: "setDensity",
    value: function setDensity(density) {
      this.density = density;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getDensity",
    value: function getDensity() {
      return this.density;
    }
    /**
     * @param {Vector} force
     */

  }, {
    key: "setForce",
    value: function setForce(force) {
      this.force = force;
    }
    /**
     * @return {Vector}
     */

  }, {
    key: "getForce",
    value: function getForce() {
      return this.force;
    }
    /**
     * @param {boolean} fixed
     */

  }, {
    key: "setFixed",
    value: function setFixed(fixed) {
      this.fixed = fixed;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "getFixed",
    value: function getFixed() {
      return this.fixed;
    }
    /**
     * @param {boolean} motion
     */

  }, {
    key: "setMotion",
    value: function setMotion(motion) {
      this.motion = motion;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "getMotion",
    value: function getMotion() {
      return this.motion;
    }
  }]);
  return PhysicsProps;
}();

var _default = PhysicsProps;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12}],136:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * @class {Size}
 */
var Size = /*#__PURE__*/function () {
  /**
   * @param {number|{width: number, height: number}} size
   */
  function Size(size) {
    (0, _classCallCheck2["default"])(this, Size);
    var width = 0,
        height = 0;

    if ((0, _typeof2["default"])(size) !== 'object') {
      width = size;
      height = size;
    } else if (size) {
      width = size.width || width;
      height = size.height || height;
    }

    this.width = width;
    this.height = height;
  }
  /**
   * @param {number} width
   */


  (0, _createClass2["default"])(Size, [{
    key: "setWidth",
    value: function setWidth(width) {
      this.width = width;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.width;
    }
    /**
     * @param {number} height
     */

  }, {
    key: "setHeight",
    value: function setHeight(height) {
      this.height = height;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.height;
    }
  }]);
  return Size;
}();

var _default = Size;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/typeof":21}],137:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

/**
 * @class {Style}
 */
var Style = /*#__PURE__*/function () {
  function Style() {
    (0, _classCallCheck2["default"])(this, Style);
    (0, _defineProperty2["default"])(this, "color", void 0);
    (0, _defineProperty2["default"])(this, "fillColor", void 0);
    (0, _defineProperty2["default"])(this, "backgroundImageRepeat", void 0);
    (0, _defineProperty2["default"])(this, "opacity", void 0);
    (0, _defineProperty2["default"])(this, "borderSize", void 0);
  }

  (0, _createClass2["default"])(Style, [{
    key: "setColor",

    /**
     * @param {string} color
     */
    value: function setColor(color) {
      this.color = color;
    }
    /**
     * @return {string}
     */

  }, {
    key: "getColor",
    value: function getColor() {
      return this.color;
    }
    /**
     * @param {string} fillColor
     */

  }, {
    key: "setFillColor",
    value: function setFillColor(fillColor) {
      this.fillColor = fillColor;
    }
    /**
     * @return {string}
     */

  }, {
    key: "getFillColor",
    value: function getFillColor() {
      return this.fillColor;
    }
    /**
     * @param {boolean} backgroundImageRepeat
     */

  }, {
    key: "setBackgroundImageRepeat",
    value: function setBackgroundImageRepeat(backgroundImageRepeat) {
      this.backgroundImageRepeat = backgroundImageRepeat;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "getBackgroundImageRepeat",
    value: function getBackgroundImageRepeat() {
      return this.backgroundImageRepeat;
    }
    /**
     * @param {number} opacity
     */

  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      this.opacity = opacity;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getOpacity",
    value: function getOpacity() {
      return this.opacity;
    }
    /**
     * @param {number} borderSize
     */

  }, {
    key: "setBorderSize",
    value: function setBorderSize(borderSize) {
      this.borderSize = borderSize;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getBorderSize",
    value: function getBorderSize() {
      return this.borderSize;
    }
  }]);
  return Style;
}();

var _default = Style;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12}],138:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Data2 = _interopRequireDefault(require("./Data.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {CameraData}
 * @extends {Data}
 */
var CameraData = /*#__PURE__*/function (_Data) {
  (0, _inherits2["default"])(CameraData, _Data);

  var _super = _createSuper(CameraData);

  function CameraData() {
    var _this;

    (0, _classCallCheck2["default"])(this, CameraData);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "position", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "entityId", void 0);
    return _this;
  }

  (0, _createClass2["default"])(CameraData, [{
    key: "setPosition",

    /**
     * @param {Vector} position
     */
    value: function setPosition(position) {
      this.position = position;
    }
    /**
     * @return {Vector}
     */

  }, {
    key: "getPosition",
    value: function getPosition() {
      return this.position;
    }
    /**
     * @param {number} entityId
     */

  }, {
    key: "setEntityId",
    value: function setEntityId(entityId) {
      this.entityId = entityId;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getEntityId",
    value: function getEntityId() {
      return this.entityId;
    }
    /**
     * @param {string} x
     */

  }, {
    key: "setPositionX",
    value: function setPositionX(x) {
      this.position.x = parseFloat(x);
    }
    /**
     * @param {string} y
     */

  }, {
    key: "setPositionY",
    value: function setPositionY(y) {
      this.position.y = parseFloat(y);
    }
    /**
     * @param {string} z
     */

  }, {
    key: "setPositionZ",
    value: function setPositionZ(z) {
      this.position.z = parseFloat(z);
    }
    /**
     * @return {number}
     */

  }, {
    key: "getPositionX",
    value: function getPositionX() {
      return this.position.x;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getPositionY",
    value: function getPositionY() {
      return this.position.y;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getPositionZ",
    value: function getPositionZ() {
      return this.position.z;
    }
  }]);
  return CameraData;
}(_Data2["default"]);

var _default = CameraData;
exports["default"] = _default;

},{"./Data.js":139,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],139:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

/**
 * @class {Data}
 */
var Data = /*#__PURE__*/function () {
  function Data() {
    (0, _classCallCheck2["default"])(this, Data);
    (0, _defineProperty2["default"])(this, "dataId", void 0);
  }

  (0, _createClass2["default"])(Data, [{
    key: "setDataId",

    /**
     * Generated when serializing object
     * @param {number} id
     */
    value: function setDataId(id) {
      this.dataId = id;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getDataId",
    value: function getDataId() {
      return this.dataId;
    }
  }]);
  return Data;
}();

(0, _defineProperty2["default"])(Data, "instance", void 0);
var _default = Data;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12}],140:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _World = _interopRequireDefault(require("../../world/World.js"));

var _EntityManager = _interopRequireDefault(require("../../world/manager/EntityManager.js"));

var _ConstraintEntity = _interopRequireDefault(require("../../entity/types/constraint/ConstraintEntity.js"));

var _MouseConstraintEntity = _interopRequireDefault(require("../../entity/types/constraint/MouseConstraintEntity.js"));

var _VirtualEntity = _interopRequireDefault(require("../../entity/VirtualEntity.js"));

var _NoiseEntity = _interopRequireDefault(require("../../entity/types/terrain/NoiseEntity.js"));

var _PlatformEntity = _interopRequireDefault(require("../../entity/types/terrain/PlatformEntity.js"));

var _CircleEntity = _interopRequireDefault(require("../../entity/types/shape/CircleEntity.js"));

var _RectEntity = _interopRequireDefault(require("../../entity/types/shape/RectEntity.js"));

var _Camera = _interopRequireDefault(require("../../core/Camera.js"));

var _Physics = _interopRequireDefault(require("../../physics/Physics.js"));

var _TerrainManager = _interopRequireDefault(require("../../world/terrain/TerrainManager.js"));

var _TextureManager = _interopRequireDefault(require("../../world/manager/TextureManager.js"));

var _Terrain = _interopRequireDefault(require("../../world/terrain/Terrain.js"));

var _NoiseTerrain = _interopRequireDefault(require("../../world/terrain/types/NoiseTerrain.js"));

var _PlainTerrain = _interopRequireDefault(require("../../world/terrain/types/PlainTerrain.js"));

var _EntityProps = _interopRequireDefault(require("../../pobject/EntityProps.js"));

var _Texture = _interopRequireDefault(require("../../core/Texture.js"));

/**
 * @class {DataSchema}
 * Used to protect loading data when importing a project
 * the dataId will be generated when the project is saved, and used to instantiate data and check the validity
 */
var DataSchema = /*#__PURE__*/function () {
  function DataSchema() {
    (0, _classCallCheck2["default"])(this, DataSchema);
  }

  (0, _createClass2["default"])(DataSchema, null, [{
    key: "getId",

    /**
     * @param {Class} type
     * @return {number}
     */
    value: function getId(type) {
      var schemaType = this.schema.find(function (vSchema) {
        return vSchema.type === type;
      });

      if (!schemaType) {
        throw new TypeError("Type ".concat(type.name, " not found in DataSchema!"));
      }

      return schemaType.id;
    }
    /**
     * @param {number|string} pDataId
     * @param {Class} prototype
     * @return {Data}
     */

  }, {
    key: "newInstance",
    value: function newInstance(pDataId, prototype) {
      var dataId = parseInt(pDataId);
      if (!dataId) return null;
      var schemaType = this.schema.find(function (vSchema) {
        return vSchema.id === dataId;
      });

      if (!schemaType) {
        throw new TypeError("ID ".concat(dataId, " not found in DataSchema!"));
      }

      var type = schemaType.type;

      if (type !== prototype && !(type.prototype instanceof prototype)) {
        throw new TypeError("Type ".concat(type.name, " attached to ID ").concat(dataId, " not match the given prototype ").concat(prototype.name, " !"));
      }

      return new type();
    }
  }]);
  return DataSchema;
}();

(0, _defineProperty2["default"])(DataSchema, "schema", [{
  id: 1,
  type: _World["default"]
}, {
  id: 2,
  type: _EntityManager["default"]
}, {
  id: 3,
  type: _ConstraintEntity["default"]
}, {
  id: 4,
  type: _Camera["default"]
}, {
  id: 5,
  type: _Physics["default"]
}, {
  id: 6,
  type: _TerrainManager["default"]
}, {
  id: 7,
  type: _Terrain["default"]
}, {
  id: 8,
  type: _VirtualEntity["default"]
}, {
  id: 9,
  type: _NoiseEntity["default"]
}, {
  id: 10,
  type: _NoiseTerrain["default"]
}, {
  id: 11,
  type: _PlatformEntity["default"]
}, {
  id: 12,
  type: _PlainTerrain["default"]
}, {
  id: 13,
  type: _CircleEntity["default"]
}, {
  id: 14,
  type: _RectEntity["default"]
}, {
  id: 15,
  type: _EntityProps["default"]
}, {
  id: 16,
  type: _TextureManager["default"]
}, {
  id: 17,
  type: _Texture["default"]
}, {
  id: 18,
  type: _MouseConstraintEntity["default"]
}]);
var _default = DataSchema;
exports["default"] = _default;

},{"../../core/Camera.js":32,"../../core/Texture.js":40,"../../entity/VirtualEntity.js":44,"../../entity/types/constraint/ConstraintEntity.js":46,"../../entity/types/constraint/MouseConstraintEntity.js":48,"../../entity/types/shape/CircleEntity.js":49,"../../entity/types/shape/RectEntity.js":52,"../../entity/types/terrain/NoiseEntity.js":53,"../../entity/types/terrain/PlatformEntity.js":54,"../../physics/Physics.js":123,"../../pobject/EntityProps.js":133,"../../world/World.js":171,"../../world/manager/EntityManager.js":173,"../../world/manager/TextureManager.js":175,"../../world/terrain/Terrain.js":176,"../../world/terrain/TerrainManager.js":177,"../../world/terrain/types/NoiseTerrain.js":178,"../../world/terrain/types/PlainTerrain.js":179,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12}],141:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Data2 = _interopRequireDefault(require("./Data.js"));

var _Maths = _interopRequireDefault(require("../../utils/Maths.js"));

var _Size = _interopRequireDefault(require("../../pobject/Size.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Class define all entity's data and props (getters and setters)
 * @abstract
 * @extends {Data}
 */
var EntityData = /*#__PURE__*/function (_Data) {
  (0, _inherits2["default"])(EntityData, _Data);

  var _super = _createSuper(EntityData);

  /**
   * @param {EntityProps} props
   */
  function EntityData() {
    var _this;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, EntityData);
    _this = _super.call(this);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "shape", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "radius", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "vertices", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "physics", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "textureId", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "selectable", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "locked", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "visible", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "clonable", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "subEntity", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "style", void 0);
    _this.id = _Maths["default"].generateId();
    _this.selectable = true;
    _this.locked = false;
    _this.visible = false;
    _this.clonable = true;
    _this.subEntity = false;

    _this.setProps(props);

    return _this;
  }
  /**
   * @param {number} id
   */


  (0, _createClass2["default"])(EntityData, [{
    key: "setId",
    value: function setId(id) {
      this.id = id;
    }
    /**
     * @param {string} shape
     */

  }, {
    key: "setShape",
    value: function setShape(shape) {
      this.shape = shape;
    }
    /**
     * @return {string}
     */

  }, {
    key: "getShape",
    value: function getShape() {
      return this.shape;
    }
    /**
     * @param {number} radius
     */

  }, {
    key: "setRadius",
    value: function setRadius(radius) {
      this.radius = radius;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getRadius",
    value: function getRadius() {
      return this.radius;
    }
    /**
     * @param {number[]} vertices
     */

  }, {
    key: "setVertices",
    value: function setVertices(vertices) {
      this.vertices = vertices;
    }
    /**
     * @return {number[]}
     */

  }, {
    key: "getVertices",
    value: function getVertices() {
      return this.vertices;
    }
    /**
     * @param {Style} advancedStyle
     */

  }, {
    key: "setAdvancedStyle",
    value: function setAdvancedStyle(advancedStyle) {
      this.advancedStyle = advancedStyle;
    }
    /**
     * @return {Style}
     */

  }, {
    key: "getAdvancedStyle",
    value: function getAdvancedStyle() {
      return this.advancedStyle;
    }
    /**
     * @param {PerlinNoiseConfig} noiseConfigs
     */

  }, {
    key: "setNoiseConfigs",
    value: function setNoiseConfigs(noiseConfigs) {
      this.noiseConfigs = noiseConfigs;
    }
    /**
     * @return {PerlinNoiseConfig}
     */

  }, {
    key: "getNoiseConfigs",
    value: function getNoiseConfigs() {
      return this.noiseConfigs;
    }
    /**
     * @param {EntityProps} props
     */

  }, {
    key: "setProps",
    value: function setProps(props) {
      this.props = props;
      props.style = props.style || {
        color: '#000000',
        fillColor: ''
      };
      this.name = props.name;
      this.position = props.position;
      this.rotation = props.rotation || 0;
      this.size = props.size || new _Size["default"](1);
      this.style = props.style;
      this.advancedStyle = Object.assign({
        backgroundImageBlob: '',
        backgroundImageRepeat: false
      }, props.advancedStyle || {});
      this.noiseConfigs = props.noiseConfigs || {};
    }
    /**
     * @return {EntityProps}
     */

  }, {
    key: "getProps",
    value: function getProps() {
      return this.props;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getId",
    value: function getId() {
      return this.id;
    }
    /**
     * @return {string}
     */

  }, {
    key: "getName",
    value: function getName() {
      return this.name;
    }
    /**
     * @param {string} name
     */

  }, {
    key: "setName",
    value: function setName(name) {
      this.name = name;
    }
    /**
     * @param {string} backgroundImageBlob
     */

  }, {
    key: "setBackgroundImageBlob",
    value: function setBackgroundImageBlob(backgroundImageBlob) {
      this.advancedStyle.backgroundImageBlob = backgroundImageBlob;
    }
    /**
     * @return {string}
     */

  }, {
    key: "getBackgroundImageBlob",
    value: function getBackgroundImageBlob() {
      return this.advancedStyle.backgroundImageBlob;
    }
    /**
     * @param {boolean} repeat
     */

  }, {
    key: "setBackgroundImageRepeat",
    value: function setBackgroundImageRepeat(repeat) {
      this.advancedStyle.backgroundImageRepeat = repeat;
      this.regenerate();
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "getBackgroundImageRepeat",
    value: function getBackgroundImageRepeat() {
      return this.advancedStyle.backgroundImageRepeat;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "isBackgroundImageRepeat",
    value: function isBackgroundImageRepeat() {
      return this.getBackgroundImageRepeat();
    }
    /**
     * Set the entity's position
     * @param {Vector} position
     */

  }, {
    key: "setPosition",
    value: function setPosition(position) {
      this.position = position;
    }
    /**
     * @return {Vector}
     */

  }, {
    key: "getPosition",
    value: function getPosition() {
      return this.position;
    }
    /**
     * @param {string} x
     */

  }, {
    key: "setPositionX",
    value: function setPositionX(x) {
      this.setPositionAndGenerate({
        x: parseInt(x),
        y: this.position.y
      });
    }
    /**
     * @param {string} y
     */

  }, {
    key: "setPositionY",
    value: function setPositionY(y) {
      this.setPositionAndGenerate({
        x: this.position.x,
        y: parseInt(y)
      });
    }
    /**
     * @return {number}
     */

  }, {
    key: "getPositionX",
    value: function getPositionX() {
      return this.position.x;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getPositionY",
    value: function getPositionY() {
      return this.position.y;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setRotation",
    value: function setRotation(value) {
      this.rotation = value;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getRotation",
    value: function getRotation() {
      return this.rotation;
    }
    /**
     * @param {{width: number, height: number}} value
     */

  }, {
    key: "setSize",
    value: function setSize(value) {
      this.size = value;
    }
    /**
     * @return {Size}
     */

  }, {
    key: "getSize",
    value: function getSize() {
      return this.size;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.size.width;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.size.height;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getRotationDegree",
    value: function getRotationDegree() {
      return _Maths["default"].toDegree(this.rotation);
    }
    /**
     * @param {string|number} width
     */

  }, {
    key: "setWidth",
    value: function setWidth(width) {
      this.setSizeAndGenerate({
        width: parseInt(width),
        height: this.size.height
      });
    }
    /**
     * @param {string|number} height
     */

  }, {
    key: "setHeight",
    value: function setHeight(height) {
      this.setSizeAndGenerate({
        width: this.size.width,
        height: parseInt(height)
      });
    }
    /**
     * @param {number} angle
     */

  }, {
    key: "setRotationDegree",
    value: function setRotationDegree(angle) {
      this.setRotationAndGenerate(_Maths["default"].fromDegree(angle));
    }
    /**
     * @param {string} style
     */

  }, {
    key: "setStyle",
    value: function setStyle(style) {
      this.style = style;
    }
    /**
     * @return {Style}
     */

  }, {
    key: "getStyle",
    value: function getStyle() {
      return this.style;
    }
    /**
     * @param {boolean} value
     */

  }, {
    key: "setVisible",
    value: function setVisible(value) {
      this.visible = value;
    }
    /**
     * @param {boolean} selectable
     */

  }, {
    key: "setSelectable",
    value: function setSelectable(selectable) {
      this.selectable = selectable;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "getSelectable",
    value: function getSelectable() {
      return this.selectable;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "isSelectable",
    value: function isSelectable() {
      return this.getSelectable();
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "isSelected",
    value: function isSelected() {
      return this.selected;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "getVisible",
    value: function getVisible() {
      return this.visible;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "isVisible",
    value: function isVisible() {
      return this.getVisible();
    }
    /**
     * @param {boolean} locked
     */

  }, {
    key: "setLocked",
    value: function setLocked(locked) {
      this.locked = locked;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "getLocked",
    value: function getLocked() {
      return this.locked;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "isLocked",
    value: function isLocked() {
      return this.getLocked();
    }
    /**
     * @param {boolean} clonable
     */

  }, {
    key: "setClonable",
    value: function setClonable(clonable) {
      this.clonable = clonable;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "getClonable",
    value: function getClonable() {
      return this.clonable;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setSeed",
    value: function setSeed(value) {
      this.noiseConfigs.seed = value;
    }
    /**
     * @returns {number}
     */

  }, {
    key: "getSeed",
    value: function getSeed() {
      return this.noiseConfigs.seed;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setOctaves",
    value: function setOctaves(value) {
      this.noiseConfigs.octaves = value;
    }
    /**
     * @returns {number}
     */

  }, {
    key: "getOctaves",
    value: function getOctaves() {
      return this.noiseConfigs.octaves;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setAmplitude",
    value: function setAmplitude(value) {
      this.noiseConfigs.amplitude = value;
    }
    /**
     * @returns {number}
     */

  }, {
    key: "getAmplitude",
    value: function getAmplitude() {
      return this.noiseConfigs.amplitude;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setPersistence",
    value: function setPersistence(value) {
      this.noiseConfigs.persistence = value;
    }
    /**
     * @returns {number}
     */

  }, {
    key: "getPersistence",
    value: function getPersistence() {
      return this.noiseConfigs.persistence;
    }
    /**
     * @param {number} value
     */

  }, {
    key: "setSmoothness",
    value: function setSmoothness(value) {
      this.noiseConfigs.smoothness = value;
    }
    /**
     * @returns {number}
     */

  }, {
    key: "getSmoothness",
    value: function getSmoothness() {
      return this.noiseConfigs.smoothness;
    }
    /**
     * @param {PhysicsProps} physics
     */

  }, {
    key: "setPhysics",
    value: function setPhysics(physics) {
      this.physics = physics;
    }
    /**
     * @return {PhysicsProps}
     */

  }, {
    key: "getPhysics",
    value: function getPhysics() {
      return this.physics;
    }
    /**
     * @param {number} textureId
     */

  }, {
    key: "setTextureId",
    value: function setTextureId(textureId) {
      this.textureId = textureId;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getTextureId",
    value: function getTextureId() {
      return this.textureId;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "getSubEntity",
    value: function getSubEntity() {
      return this.subEntity;
    }
    /**
     * @param {boolean} subEntity
     */

  }, {
    key: "setSubEntity",
    value: function setSubEntity(subEntity) {
      this.subEntity = subEntity;
    }
    /**
     * @return {boolean}
     */

  }, {
    key: "isSubEntity",
    value: function isSubEntity() {
      return this.getSubEntity();
    }
  }]);
  return EntityData;
}(_Data2["default"]);

EntityData.shapes = {
  ELLIPSE: 'ellipse',
  RECT: 'rect',
  LINE: 'line',
  POLY: 'poly',
  CIRCLE: 'circle',
  ATTACH: 'attach',
  GROUP: 'group',
  VIRTUAL: 'virtual'
};
var _default = EntityData;
exports["default"] = _default;

},{"../../pobject/Size.js":136,"../../utils/Maths.js":165,"./Data.js":139,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],142:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Data2 = _interopRequireDefault(require("./Data.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {EntityManagerData}
 * @extends {Data}
 */
var EntityManagerData = /*#__PURE__*/function (_Data) {
  (0, _inherits2["default"])(EntityManagerData, _Data);

  var _super = _createSuper(EntityManagerData);

  function EntityManagerData() {
    var _this;

    (0, _classCallCheck2["default"])(this, EntityManagerData);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "entities", void 0);
    return _this;
  }

  (0, _createClass2["default"])(EntityManagerData, [{
    key: "setEntities",

    /**
     * @param {EntityData} entities
     */
    value: function setEntities(entities) {
      this.entities = entities;
    }
    /**
     * @return {EntityData[]}
     */

  }, {
    key: "getEntities",
    value: function getEntities() {
      return this.entities;
    }
  }]);
  return EntityManagerData;
}(_Data2["default"]);

var _default = EntityManagerData;
exports["default"] = _default;

},{"./Data.js":139,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],143:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var MeshData = /*#__PURE__*/function () {
  function MeshData() {
    (0, _classCallCheck2["default"])(this, MeshData);
    (0, _defineProperty2["default"])(this, "size", void 0);
    (0, _defineProperty2["default"])(this, "position", void 0);
    (0, _defineProperty2["default"])(this, "dataUrl", void 0);
  }

  (0, _createClass2["default"])(MeshData, [{
    key: "setSize",

    /**
     * @param {Size} size
     */
    value: function setSize(size) {
      this.size = size;
    }
    /**
     * @return {Size}
     */

  }, {
    key: "getSize",
    value: function getSize() {
      return this.size;
    }
    /**
     * @param {Vector} position
     */

  }, {
    key: "setPosition",
    value: function setPosition(position) {
      this.position = position;
    }
    /**
     * @return {Vector}
     */

  }, {
    key: "getPosition",
    value: function getPosition() {
      return this.position;
    }
    /**
     * @param {string} dataUrl
     */

  }, {
    key: "setDataUrl",
    value: function () {
      var _setDataUrl = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(dataUrl) {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.dataUrl = dataUrl;

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setDataUrl(_x) {
        return _setDataUrl.apply(this, arguments);
      }

      return setDataUrl;
    }()
    /**
     * @return {string}
     */

  }, {
    key: "getDataUrl",
    value: function getDataUrl() {
      return this.dataUrl;
    }
  }]);
  return MeshData;
}();

var _default = MeshData;
exports["default"] = _default;

},{"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/regenerator":25}],144:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Data2 = _interopRequireDefault(require("./Data.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {PhysicsData}
 * @extends {Data}
 */
var PhysicsData = /*#__PURE__*/function (_Data) {
  (0, _inherits2["default"])(PhysicsData, _Data);

  var _super = _createSuper(PhysicsData);

  function PhysicsData() {
    (0, _classCallCheck2["default"])(this, PhysicsData);
    return _super.apply(this, arguments);
  }

  return PhysicsData;
}(_Data2["default"]);

var _default = PhysicsData;
exports["default"] = _default;

},{"./Data.js":139,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],145:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Data2 = _interopRequireDefault(require("./Data.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {TerrainData}
 * @extends {Data}
 */
var TerrainData = /*#__PURE__*/function (_Data) {
  (0, _inherits2["default"])(TerrainData, _Data);

  var _super = _createSuper(TerrainData);

  function TerrainData() {
    var _this;

    (0, _classCallCheck2["default"])(this, TerrainData);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "entityId", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "size", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "chunksNbr", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "chunkIds", void 0);
    return _this;
  }

  (0, _createClass2["default"])(TerrainData, [{
    key: "setEntityId",

    /**
     * @param {number} entityId
     */
    value: function setEntityId(entityId) {
      this.entityId = entityId;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getEntityId",
    value: function getEntityId() {
      return this.entityId;
    }
    /**
     * @param {number} chunksNbr
     */

  }, {
    key: "setChunksNbr",
    value: function setChunksNbr(chunksNbr) {
      this.chunksNbr = chunksNbr;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getChunksNbr",
    value: function getChunksNbr() {
      return this.chunksNbr;
    }
    /**
     * @param {number[]} chunkIds
     */

  }, {
    key: "setChunkIds",
    value: function setChunkIds(chunkIds) {
      this.chunkIds = chunkIds;
    }
    /**
     * @return {number[]}
     */

  }, {
    key: "getChunkIds",
    value: function getChunkIds() {
      return this.chunkIds;
    }
    /**
     * @param {Size} size
     */

  }, {
    key: "setSize",
    value: function setSize(size) {
      this.size = size;
    }
    /**
     * @return {Size}
     */

  }, {
    key: "getSize",
    value: function getSize() {
      return this.size;
    }
  }]);
  return TerrainData;
}(_Data2["default"]);

var _default = TerrainData;
exports["default"] = _default;

},{"./Data.js":139,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],146:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Data2 = _interopRequireDefault(require("./Data.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {TerrainManagerData}
 * @extends {Data}
 */
var TerrainManagerData = /*#__PURE__*/function (_Data) {
  (0, _inherits2["default"])(TerrainManagerData, _Data);

  var _super = _createSuper(TerrainManagerData);

  function TerrainManagerData() {
    var _this;

    (0, _classCallCheck2["default"])(this, TerrainManagerData);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "terrains", void 0);
    return _this;
  }

  (0, _createClass2["default"])(TerrainManagerData, [{
    key: "getTerrains",

    /**
     * @return {Terrain[]}
     */
    value: function getTerrains() {
      return this.terrains;
    }
    /**
     * @param {Terrain[]} terrains
     */

  }, {
    key: "setTerrains",
    value: function setTerrains(terrains) {
      this.terrains = terrains;
    }
  }]);
  return TerrainManagerData;
}(_Data2["default"]);

var _default = TerrainManagerData;
exports["default"] = _default;

},{"./Data.js":139,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],147:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Data2 = _interopRequireDefault(require("./Data.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @abstract
 * @extends {Data}
 */
var TextureData = /*#__PURE__*/function (_Data) {
  (0, _inherits2["default"])(TextureData, _Data);

  var _super = _createSuper(TextureData);

  function TextureData() {
    var _this;

    (0, _classCallCheck2["default"])(this, TextureData);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "id", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "name", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "mesh", void 0);
    return _this;
  }

  (0, _createClass2["default"])(TextureData, [{
    key: "setId",

    /**
     * @param {number} id
     */
    value: function setId(id) {
      this.id = id;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getId",
    value: function getId() {
      return this.id;
    }
    /**
     * @param {string} name
     */

  }, {
    key: "setName",
    value: function setName(name) {
      this.name = name;
    }
    /**
     * @return {string}
     */

  }, {
    key: "getName",
    value: function getName() {
      return this.name;
    }
    /**
     * @param {Mesh} mesh
     */

  }, {
    key: "setMesh",
    value: function setMesh(mesh) {
      this.mesh = mesh;
    }
    /**
     * @return {Mesh}
     */

  }, {
    key: "getMesh",
    value: function getMesh() {
      return this.mesh;
    }
  }]);
  return TextureData;
}(_Data2["default"]);

var _default = TextureData;
exports["default"] = _default;

},{"./Data.js":139,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],148:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Data2 = _interopRequireDefault(require("./Data.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {TextureManagerData}
 * @extends {Data}
 */
var TextureManagerData = /*#__PURE__*/function (_Data) {
  (0, _inherits2["default"])(TextureManagerData, _Data);

  var _super = _createSuper(TextureManagerData);

  function TextureManagerData() {
    var _this;

    (0, _classCallCheck2["default"])(this, TextureManagerData);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "textures", void 0);
    return _this;
  }

  (0, _createClass2["default"])(TextureManagerData, [{
    key: "getTextures",

    /**
     * @return {Texture[]}
     */
    value: function getTextures() {
      return this.textures;
    }
    /**
     * @param {Texture[]} textures
     */

  }, {
    key: "setTextures",
    value: function setTextures(textures) {
      this.textures = textures;
    }
  }]);
  return TextureManagerData;
}(_Data2["default"]);

var _default = TextureManagerData;
exports["default"] = _default;

},{"./Data.js":139,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],149:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Data2 = _interopRequireDefault(require("./Data.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {WorldData}
 * @extends {Data}
 *
 * @property {AiEngine} aiEngine
 * @property {Camera} camera
 */
var WorldData = /*#__PURE__*/function (_Data) {
  (0, _inherits2["default"])(WorldData, _Data);

  var _super = _createSuper(WorldData);

  function WorldData() {
    var _this;

    (0, _classCallCheck2["default"])(this, WorldData);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "entityManager", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "camera", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "physics", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "terrainManager", void 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "textureManager", void 0);
    return _this;
  }

  (0, _createClass2["default"])(WorldData, [{
    key: "set",

    /**
     * @param {World} data
     */
    value: function set(data) {
      var _this2 = this;

      if (data instanceof WorldData) {
        Object.getOwnPropertyNames(this).map(function (prop) {
          return _this2[prop] = data[prop];
        });
        this.reload();
      } else {
        throw new TypeError('Cannot set the new world, data must be instance of World class');
      }
    }
  }, {
    key: "reload",
    value: function reload() {
      throw new TypeError('World.reload must be implemented!');
    }
    /**
     * @param {EntityManagerData} entityManager
     */

  }, {
    key: "setEntityManager",
    value: function setEntityManager(entityManager) {
      this.entityManager = entityManager;
    }
    /**
     * @param {CameraData} camera
     */

  }, {
    key: "setCamera",
    value: function setCamera(camera) {
      this.camera = camera;
    }
    /**
     * @param {PhysicsData} physics
     */

  }, {
    key: "setPhysics",
    value: function setPhysics(physics) {
      this.physics = physics;
    }
    /**
     * @param {TerrainManagerData} terrainManager
     */

  }, {
    key: "setTerrainManager",
    value: function setTerrainManager(terrainManager) {
      this.terrainManager = terrainManager;
    }
    /**
     * @param {TextureManagerData} textureManager
     */

  }, {
    key: "setTextureManager",
    value: function setTextureManager(textureManager) {
      this.textureManager = textureManager;
    }
    /**
     * Get the physics manager
     * @return {Physics}
     */

  }, {
    key: "getPhysics",
    value: function getPhysics() {
      return this.physics;
    }
    /**
     * @return {EntityManager}
     */

  }, {
    key: "getEntityManager",
    value: function getEntityManager() {
      return this.entityManager;
    }
    /**
     * Get the Ai engine
     */

  }, {
    key: "getAiEngine",
    value: function getAiEngine() {
      return this.aiEngine;
    }
    /**
     * @return {TerrainManager}
     */

  }, {
    key: "getTerrainManager",
    value: function getTerrainManager() {
      return this.terrainManager;
    }
    /**
     * @return {TextureManager}
     */

  }, {
    key: "getTextureManager",
    value: function getTextureManager() {
      return this.textureManager;
    }
    /**
     * Get the principal camera (active)
     */

  }, {
    key: "getCamera",
    value: function getCamera() {
      return this.camera;
    }
  }], [{
    key: "new",
    value: function _new() {
      this.instance = new this();
    }
  }]);
  return WorldData;
}(_Data2["default"]);

(0, _defineProperty2["default"])(WorldData, "instance", void 0);
var _default = WorldData;
exports["default"] = _default;

},{"./Data.js":139,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],150:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Renderer2 = _interopRequireDefault(require("./Renderer.js"));

var _Vector = _interopRequireDefault(require("../utils/Vector.js"));

var _Constant = require("../core/Constant.js");

var _Context = require("../core/Context.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * ObjectRenderer class
 * Manager the renderer for entities
 * @extends {Renderer}
 */
var ObjectRenderer = /*#__PURE__*/function (_Renderer) {
  (0, _inherits2["default"])(ObjectRenderer, _Renderer);

  var _super = _createSuper(ObjectRenderer);

  function ObjectRenderer() {
    var _this;

    (0, _classCallCheck2["default"])(this, ObjectRenderer);
    _this = _super.call(this);
    _this.meshes = [];
    _this.canvas = new OffscreenCanvas(_Constant.SCENE_WIDTH, _Constant.SCENE_HEIGHT);
    _this.context = _this.canvas.getContext(_Constant.CANVAS_CONTEXT_TYPE);
    return _this;
  }
  /**
   * @override
   */


  (0, _createClass2["default"])(ObjectRenderer, [{
    key: "draw",
    value: function draw(object) {
      this.add(object.mesh);
    }
    /**
     * @override
     */

  }, {
    key: "clear",
    value: function clear() {
      _Context.objectContext.canvas.width = _Constant.SCENE_WIDTH;
      this.context.canvas.width = _Constant.SCENE_WIDTH;
    }
    /**
     * Render the meshes to the screen
     * @param {Camera} camera
     * @todo Optimize this to not delete all meshes (rerender just entities updated)
     */

  }, {
    key: "render",
    value: function render(camera) {
      this.clear();

      for (var iMesh in this.meshes) {
        if (this.meshes.hasOwnProperty(iMesh)) {
          var mesh = this.meshes[iMesh];

          var _camera$toCanvasCoord = camera.toCanvasCoord(mesh.position),
              x = _camera$toCanvasCoord.x,
              y = _camera$toCanvasCoord.y;

          var _this$toSceneCoord = this.toSceneCoord({
            x: x,
            y: y
          }),
              sceneX = _this$toSceneCoord.x,
              sceneY = _this$toSceneCoord.y;

          _Context.objectContext.drawImage(mesh.context.canvas, sceneX, sceneY);
        }
      }

      this.meshes = [];
    }
    /**
     * Add a mesh
     * @param {Mesh} mesh
     */

  }, {
    key: "add",
    value: function add(mesh) {
      this.meshes.push(mesh);
    }
    /**
     * Convert position to scene coordinates
     * @param {Vector} position
     * @return {Vector}
     */

  }, {
    key: "toSceneCoord",
    value: function toSceneCoord(_ref) {
      var x = _ref.x,
          y = _ref.y;

      var _objectContext$canvas = _Context.objectContext.canvas.getBoundingClientRect(),
          sceneCanvasX = _objectContext$canvas.left,
          sceneCanvasY = _objectContext$canvas.top;

      return new _Vector["default"]({
        x: x - sceneCanvasX,
        y: y - sceneCanvasY
      });
    }
  }]);
  return ObjectRenderer;
}(_Renderer2["default"]);

var _default = ObjectRenderer;
exports["default"] = _default;

},{"../core/Constant.js":33,"../core/Context.js":34,"../utils/Vector.js":169,"./Renderer.js":151,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],151:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * @abstract
 * Renderer class
 * Render elements (entities, menus, ...) to the screen
 */
var Renderer = /*#__PURE__*/function () {
  function Renderer() {
    (0, _classCallCheck2["default"])(this, Renderer);
  }

  (0, _createClass2["default"])(Renderer, [{
    key: "draw",

    /**
     * @abstract
     * @param {Entity} object
     */
    value: function draw(object) {
      throw new TypeError('Renderer.draw must be implemented');
    }
    /**
     * @abstract
     */

  }, {
    key: "clear",
    value: function clear() {
      throw new TypeError('Renderer.clear must be implemented');
    }
    /**
     * @abstract
     * Render the meshes to the screen (layout, entities, ...)
     * @param {Camera|Menu} object
     */

  }, {
    key: "render",
    value: function render(object) {
      throw new TypeError('Renderer.render must be implemented');
    }
  }]);
  return Renderer;
}();

var _default = Renderer;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],152:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _Constant = require("../../core/Constant.js");

/**
 * @class {MenuItemUI}
 * @property {MenuItem} element
 * @property {MenuItemUI} parent
 * @property {number} version
 */
var MenuItemUI = /*#__PURE__*/function () {
  function MenuItemUI(item, index, parent) {
    (0, _classCallCheck2["default"])(this, MenuItemUI);
    this.element = item;
    this.index = index;
    this.parent = parent;
    this.version = 0;
  }
  /**
   * @param {UIRenderer} uiRenderer
   */


  (0, _createClass2["default"])(MenuItemUI, [{
    key: "draw",
    value: function draw(uiRenderer) {
      uiRenderer.getType(this).draw(this, uiRenderer);
    }
    /**
     * @return {string}
     */

  }, {
    key: "getId",
    value: function getId() {
      var zone = this.element.zone;
      var parentIndex = this.parent && this.parent.index || 0;
      return "".concat(_Constant.HTML_ID_PREFIX).concat(zone, "-").concat(parentIndex, "-").concat(this.index);
    }
  }]);
  return MenuItemUI;
}();

var _default = MenuItemUI;
exports["default"] = _default;

},{"../../core/Constant.js":33,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],153:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * @class {Runner}
 * @abstract
 */
var Runner = /*#__PURE__*/function () {
  function Runner() {
    (0, _classCallCheck2["default"])(this, Runner);

    if (this.constructor === Runner) {
      throw new TypeError('Abstract class Runner cannot be instantiated directly');
    }
  }
  /**
   * @abstract
   * @param {Window} window
   * @return {boolean}
   */


  (0, _createClass2["default"])(Runner, [{
    key: "isHandle",
    value: function isHandle(window) {
      throw new TypeError('"Runner.isHandle" method must be implemented');
    }
    /**
     * @abstract
     * Execute actions.
     */

  }, {
    key: "execute",
    value: function execute() {
      throw new TypeError('"Runner.execute" method must be implemented');
    }
  }], [{
    key: "get",
    value: function get() {
      if (!this.instance) {
        this.instance = new this();
      }

      return this.instance;
    }
  }]);
  return Runner;
}();

var _default = Runner;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],154:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Runner2 = _interopRequireDefault(require("../Runner.js"));

var _Mouse = _interopRequireDefault(require("../../core/Mouse.js"));

var _World = _interopRequireDefault(require("../../world/World.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var MouseButton = _Mouse["default"].MouseButton;
/**
 * Manage all the entity constraints (mouse constraint, ...)
 * @property {Entity} entity
 */

var ConstraintRunner = /*#__PURE__*/function (_Runner) {
  (0, _inherits2["default"])(ConstraintRunner, _Runner);

  var _super = _createSuper(ConstraintRunner);

  function ConstraintRunner() {
    (0, _classCallCheck2["default"])(this, ConstraintRunner);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(ConstraintRunner, [{
    key: "isHandle",

    /**
     * @override
     */
    value: function isHandle(window) {
      return true;
    }
    /**
     * Execute all constraints (mouse constraint, ...)
     * @param {Mouse} mouse
     */

  }, {
    key: "execute",
    value: function execute(mouse) {
      var world = _World["default"].get();

      this.mouseConstraint(world, mouse);
    }
    /**
     * Check for mouse constraint
     * @param {World} world
     * @param {Mouse} mouse
     * @TODO: review & optimize the implementation
     */

  }, {
    key: "mouseConstraint",
    value: function mouseConstraint(world, mouse) {
      var mouseConstraint = world.getMouseConstraint();
      var worldMousePosition = world.getWorldPosition(mouse.currentPosition);

      if (mouseConstraint) {
        if (mouse.isButtonPressed(MouseButton.LEFT) && !mouseConstraint.entities.b) {
          var clickEntity = world.findBodyEntity(mouse.currentPosition);

          if (clickEntity) {
            mouseConstraint.pointConstraint = clickEntity.toRelativeCenterPosition(worldMousePosition);
          }

          mouseConstraint.entities.b = clickEntity;
        } else if (mouse.isButtonClicked(MouseButton.LEFT)) {
          mouseConstraint.entities.b = null;
          mouseConstraint.pointConstraint = null;
        }

        this.updateConstraint(mouseConstraint, world, mouse);
      }
    }
    /**
     * Update the physics constraint from entity.
     * Must set the default position for the pointB to (1,1) and the pointA to (0,0), else the mesh of
     * the constraint wouldn't updated because the size will be 0
     * @param {Entity} constraint
     * @param {World} world
     * @param {Mouse} mouse
     */

  }, {
    key: "updateConstraint",
    value: function updateConstraint(constraint, world, mouse) {
      var physics = world.getPhysics();
      var mousePosition = world.getWorldPosition(mouse.currentPosition);
      var entity = constraint.entities.b;
      constraint.setEntities(null, entity);
      physics.updateConstraint(constraint, {
        pointA: entity ? mousePosition : {
          x: 0,
          y: 0
        },
        entityB: entity,
        pointB: entity ? constraint.pointConstraint : {
          x: 1,
          y: 1
        }
      });
    }
  }], [{
    key: "get",
    value: function get() {
      if (!ConstraintRunner.instance) {
        ConstraintRunner.instance = new ConstraintRunner();
      }

      return ConstraintRunner.instance;
    }
  }]);
  return ConstraintRunner;
}(_Runner2["default"]);

ConstraintRunner.instance = null;
var _default = ConstraintRunner;
exports["default"] = _default;

},{"../../core/Mouse.js":38,"../../world/World.js":171,"../Runner.js":153,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],155:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _SchemaMeta = _interopRequireDefault(require("./SchemaMeta.js"));

var _Data = _interopRequireDefault(require("../project/data/Data.js"));

var _DataSchema = _interopRequireDefault(require("../project/data/DataSchema.js"));

var _ClassHelper = _interopRequireDefault(require("../utils/ClassHelper.js"));

/**
 * @class {Schema}
 */
var Schema = /*#__PURE__*/function () {
  function Schema() {
    (0, _classCallCheck2["default"])(this, Schema);
  }

  (0, _createClass2["default"])(Schema, null, [{
    key: "getMeta",

    /**
     * @param {string} prefix
     * @param {SchemaMeta} rootMeta
     * @returns {SchemaMeta}
     */
    value: function getMeta() {
      var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var rootMeta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      !rootMeta && (rootMeta = _SchemaMeta["default"]);
      var resultMeta = {};

      for (var eMetaData in rootMeta) {
        if (rootMeta.hasOwnProperty(eMetaData)) {
          var _rootMeta$eMetaData = rootMeta[eMetaData],
              type = _rootMeta$eMetaData.type,
              meta = _rootMeta$eMetaData.meta,
              prototype = _rootMeta$eMetaData.prototype;
          var metaPrefix = "".concat(prefix).concat(eMetaData);
          resultMeta[metaPrefix] = {
            prototype: prototype || this.getPrototypeOf(type),
            type: type || prototype
          };
          var subMeta = meta;

          if (subMeta) {
            resultMeta = Object.assign(resultMeta, this.getMeta("".concat(metaPrefix, "."), subMeta));
          }
        }
      }

      return resultMeta;
    }
    /**
     * Get the prototype from the given type
     * @param {Class|string} type
     * @return {Class|string|null}
     */

  }, {
    key: "getPrototypeOf",
    value: function getPrototypeOf(type) {
      var prototype = type;

      if (!_.isString(type) && type !== Array) {
        prototype = this.findDataPrototypeOf(type);

        if (!prototype) {
          throw new TypeError("".concat(type.name, " must extends Data type class!"));
        }
      }

      return prototype;
    }
    /**
     * Find parent Data class
     * @param {Class} type
     * @return {Class|null}
     */

  }, {
    key: "findDataPrototypeOf",
    value: function findDataPrototypeOf(type) {
      var prototype = Object.getPrototypeOf(type);

      if (prototype && prototype.name) {
        if (prototype.name.match(/^[a-zA-Z]+Data$/)) {
          return prototype;
        } else {
          return this.findDataPrototypeOf(prototype);
        }
      }

      return null;
    }
    /**
     * @param {string} key
     * @param {Object|Array|Data} data
     * @param {SchemaMeta} schema
     * @param {string} schemaPrefix
     * @param {{serialize: boolean}} options
     * @return {Object|Array}
     * @todo: Refactor/Simplify the implementation
     */

  }, {
    key: "validate",
    value: function () {
      var _validate = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(key, data, schema, options) {
        var schemaPrefix,
            schemaMeta,
            schemaMetaProto,
            prototype,
            result,
            props,
            iProp,
            prop,
            subResult,
            setter,
            _setter,
            _args = arguments;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                schemaPrefix = _args.length > 4 && _args[4] !== undefined ? _args[4] : '';
                schemaMeta = "".concat(schemaPrefix).concat(key);
                schemaMetaProto = schema[schemaMeta];

                if (!schemaMetaProto) {
                  _context.next = 34;
                  break;
                }

                prototype = options.serialize ? schemaMetaProto.prototype : schemaMetaProto.type;

                if (_.isString(prototype)) {
                  _context.next = 32;
                  break;
                }

                if (prototype.prototype instanceof _Data["default"]) {
                  if (options.serialize) {
                    result = new prototype();
                    data && data.setDataId(_DataSchema["default"].getId(data.constructor));
                  } else {
                    result = _DataSchema["default"].newInstance(data.dataId, prototype);
                  }
                } else {
                  result = new prototype();
                }

                if (!result) {
                  _context.next = 31;
                  break;
                }

                props = this.getProperties(data, schemaMetaProto.prototype);
                _context.t0 = _regenerator["default"].keys(props);

              case 10:
                if ((_context.t1 = _context.t0()).done) {
                  _context.next = 31;
                  break;
                }

                iProp = _context.t1.value;
                prop = props[iProp];
                _context.next = 15;
                return this.validate(prop.key, prop.value, schema, options, "".concat(schemaMeta, "."));

              case 15:
                subResult = _context.sent;

                if (!subResult) {
                  _context.next = 26;
                  break;
                }

                if (!_.isArray(result)) {
                  _context.next = 21;
                  break;
                }

                result.push(subResult);
                _context.next = 24;
                break;

              case 21:
                setter = _ClassHelper["default"].getSetter(result, prop.key);
                _context.next = 24;
                return result[setter](subResult);

              case 24:
                _context.next = 29;
                break;

              case 26:
                _setter = _ClassHelper["default"].getSetter(result, prop.key);
                _context.next = 29;
                return result[_setter](Schema.getValue("".concat(schemaMeta, ".").concat(prop.key), prop.value));

              case 29:
                _context.next = 10;
                break;

              case 31:
                return _context.abrupt("return", result);

              case 32:
                _context.next = 35;
                break;

              case 34:
                throw new TypeError("".concat(schemaMeta, " must be defined in the schema"));

              case 35:
                return _context.abrupt("return", null);

              case 36:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function validate(_x, _x2, _x3, _x4) {
        return _validate.apply(this, arguments);
      }

      return validate;
    }()
    /**
     * @param {Object} object
     * @param {Class} prototype
     * @returns {{key: string, value: *}[]}
     */

  }, {
    key: "getProperties",
    value: function getProperties(object, prototype) {
      if (prototype === Array) {
        return _.isArray(object) ? object.map(function (value) {
          return {
            key: 'element',
            value: value
          };
        }) : [];
      } else {
        var tempPrototype = new prototype();
        return Object.getOwnPropertyNames(tempPrototype).map(function (prop) {
          var value;

          if (object) {
            if (object.constructor === Object) {
              value = object[prop];
            } else {
              var getter = _ClassHelper["default"].getGetter(object, prop);

              value = object[getter]();
            }
          }

          return {
            key: prop,
            value: value
          };
        });
      }
    }
    /**
     * Get the actual value from the schema using the given schema meta field and value.
     * Used to help validate the value and correct it according to the format/type
     * @param {String} schemaMeta
     * @param {number|string|boolean|null|undefined} value
     */

  }, {
    key: "getValue",
    value: function getValue(schemaMeta, value) {
      var schema = this.getMeta();
      var prototype = schema[schemaMeta].prototype;
      var newValue;

      switch (prototype) {
        case 'number':
          newValue = value !== null && value !== undefined ? parseFloat(value) : null;
          break;

        case 'string':
          newValue = _.isString(value) ? value : '';
          break;

        case 'boolean':
          newValue = value === 'false' ? false : !!value;
          break;

        default:
          newValue = '';
      }

      return newValue;
    }
  }]);
  return Schema;
}();

var _default = Schema;
exports["default"] = _default;

},{"../project/data/Data.js":139,"../project/data/DataSchema.js":140,"../utils/ClassHelper.js":162,"./SchemaMeta.js":156,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/regenerator":25}],156:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _EntityMotion = _interopRequireDefault(require("../entity/EntityMotion.js"));

var _Vector = _interopRequireDefault(require("../utils/Vector.js"));

var _Size = _interopRequireDefault(require("../pobject/Size.js"));

var _Style = _interopRequireDefault(require("../pobject/Style.js"));

var _PerlinNoiseConfig = _interopRequireDefault(require("../pobject/PerlinNoiseConfig.js"));

var _World = _interopRequireDefault(require("../world/World.js"));

var _EntityManager = _interopRequireDefault(require("../world/manager/EntityManager.js"));

var _TextureManager = _interopRequireDefault(require("../world/manager/TextureManager.js"));

var _Camera = _interopRequireDefault(require("../core/Camera.js"));

var _Physics = _interopRequireDefault(require("../physics/Physics.js"));

var _TerrainManager = _interopRequireDefault(require("../world/terrain/TerrainManager.js"));

var _Terrain = _interopRequireDefault(require("../world/terrain/Terrain.js"));

var _EntityProps = _interopRequireDefault(require("../pobject/EntityProps.js"));

var _PhysicsProps = _interopRequireDefault(require("../pobject/PhysicsProps.js"));

var _Texture = _interopRequireDefault(require("../core/Texture.js"));

var _Mesh = _interopRequireDefault(require("../core/Mesh.js"));

/**
 * Define the schema of project data.
 * Used to serialize/deserialize all data when saving/loading the project.
 * the schema of each data can be defined using type or prototype properties :
 *      - Type: the type can be a string (like 'number'), Array, or a Class of Data type.
 *              if type defined as Data, the Data parent class will be used for serializing,
 *              and the type for deserializing
 *      - Prototype: the prototype can be a string, Array or any Class
 *                   if prototype is specified, it will be used for serializing and deserializing
 */
var _default = {
  world: {
    type: _World["default"],
    meta: {
      dataId: {
        type: 'number'
      },
      mouseConstraintId: {
        type: 'number'
      },
      entityManager: {
        type: _EntityManager["default"],
        meta: {
          dataId: {
            type: 'number'
          },
          entities: {
            type: Array,
            meta: {
              element: {
                type: _EntityMotion["default"],
                meta: {
                  dataId: {
                    type: 'number'
                  },
                  textureId: {
                    type: 'number'
                  },
                  subEntity: {
                    type: 'boolean'
                  },
                  props: {
                    prototype: _EntityProps["default"],
                    meta: {
                      name: {
                        type: 'string'
                      },
                      style: {
                        prototype: _Style["default"],
                        meta: {
                          color: {
                            type: 'string'
                          },
                          fillColor: {
                            type: 'string'
                          },
                          backgroundImageRepeat: {
                            type: 'boolean'
                          },
                          opacity: {
                            type: 'number'
                          },
                          borderSize: {
                            type: 'number'
                          }
                        }
                      },
                      position: {
                        prototype: _Vector["default"],
                        meta: {
                          x: {
                            type: 'number'
                          },
                          y: {
                            type: 'number'
                          },
                          z: {
                            type: 'number'
                          }
                        }
                      },
                      rotation: {
                        type: 'number'
                      },
                      advancedStyle: {
                        prototype: _Style["default"],
                        meta: {
                          color: {
                            type: 'string'
                          },
                          fillColor: {
                            type: 'string'
                          },
                          backgroundImageRepeat: {
                            type: 'boolean'
                          },
                          opacity: {
                            type: 'number'
                          },
                          borderSize: {
                            type: 'number'
                          }
                        }
                      },
                      noiseConfigs: {
                        prototype: _PerlinNoiseConfig["default"],
                        meta: {
                          seed: {
                            type: 'number'
                          },
                          octaves: {
                            type: 'number'
                          },
                          amplitude: {
                            type: 'number'
                          },
                          persistence: {
                            type: 'number'
                          },
                          smoothness: {
                            type: 'number'
                          }
                        }
                      },
                      size: {
                        prototype: _Size["default"],
                        meta: {
                          width: {
                            type: 'number'
                          },
                          height: {
                            type: 'number'
                          }
                        }
                      }
                    }
                  },
                  id: {
                    type: 'number'
                  },
                  shape: {
                    type: 'string'
                  },
                  name: {
                    type: 'string'
                  },
                  rotation: {
                    type: 'number'
                  },
                  radius: {
                    type: 'number'
                  },
                  selectable: {
                    type: 'boolean'
                  },
                  locked: {
                    type: 'boolean'
                  },
                  visible: {
                    type: 'boolean'
                  },
                  clonable: {
                    type: 'boolean'
                  },
                  size: {
                    prototype: _Size["default"],
                    meta: {
                      width: {
                        type: 'number'
                      },
                      height: {
                        type: 'number'
                      }
                    }
                  },
                  style: {
                    prototype: _Style["default"],
                    meta: {
                      color: {
                        type: 'string'
                      },
                      fillColor: {
                        type: 'string'
                      },
                      backgroundImageRepeat: {
                        type: 'boolean'
                      },
                      opacity: {
                        type: 'number'
                      },
                      borderSize: {
                        type: 'number'
                      }
                    }
                  },
                  advancedStyle: {
                    prototype: _Style["default"],
                    meta: {
                      color: {
                        type: 'string'
                      },
                      fillColor: {
                        type: 'string'
                      },
                      backgroundImageRepeat: {
                        type: 'boolean'
                      },
                      opacity: {
                        type: 'number'
                      },
                      borderSize: {
                        type: 'number'
                      }
                    }
                  },
                  noiseConfigs: {
                    prototype: _PerlinNoiseConfig["default"],
                    meta: {
                      seed: {
                        type: 'number'
                      },
                      octaves: {
                        type: 'number'
                      },
                      amplitude: {
                        type: 'number'
                      },
                      persistence: {
                        type: 'number'
                      },
                      smoothness: {
                        type: 'number'
                      }
                    }
                  },
                  vertices: {
                    type: Array,
                    meta: {
                      element: {
                        prototype: _Vector["default"],
                        meta: {
                          x: {
                            type: 'number'
                          },
                          y: {
                            type: 'number'
                          },
                          z: {
                            type: 'number'
                          }
                        }
                      }
                    }
                  },
                  position: {
                    prototype: _Vector["default"],
                    meta: {
                      x: {
                        type: 'number'
                      },
                      y: {
                        type: 'number'
                      },
                      z: {
                        type: 'number'
                      }
                    }
                  },
                  physics: {
                    prototype: _PhysicsProps["default"],
                    meta: {
                      velocity: {
                        prototype: _Vector["default"],
                        meta: {
                          x: {
                            type: 'number'
                          },
                          y: {
                            type: 'number'
                          },
                          z: {
                            type: 'number'
                          }
                        }
                      },
                      angularVelocity: {
                        type: 'number'
                      },
                      speed: {
                        type: 'number'
                      },
                      density: {
                        type: 'number'
                      },
                      force: {
                        prototype: _Vector["default"],
                        meta: {
                          x: {
                            type: 'number'
                          },
                          y: {
                            type: 'number'
                          },
                          z: {
                            type: 'number'
                          }
                        }
                      },
                      fixed: {
                        type: 'boolean'
                      },
                      motion: {
                        type: 'boolean'
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      camera: {
        type: _Camera["default"],
        meta: {
          dataId: {
            type: 'number'
          },
          entityId: {
            type: 'number'
          },
          position: {
            prototype: _Vector["default"],
            meta: {
              x: {
                type: 'number'
              },
              y: {
                type: 'number'
              },
              z: {
                type: 'number'
              }
            }
          }
        }
      },
      physics: {
        type: _Physics["default"],
        meta: {
          dataId: {
            type: 'number'
          }
        }
      },
      terrainManager: {
        type: _TerrainManager["default"],
        meta: {
          dataId: {
            type: 'number'
          },
          terrains: {
            type: Array,
            meta: {
              element: {
                type: _Terrain["default"],
                meta: {
                  dataId: {
                    type: 'number'
                  },
                  entityId: {
                    type: 'number'
                  },
                  rotation: {
                    type: 'number'
                  },
                  chunksNbr: {
                    type: 'number'
                  },
                  chunkIds: {
                    type: Array,
                    meta: {
                      element: {
                        type: 'number'
                      }
                    }
                  },
                  size: {
                    prototype: _Size["default"],
                    meta: {
                      width: {
                        type: 'number'
                      },
                      height: {
                        type: 'number'
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      textureManager: {
        type: _TextureManager["default"],
        meta: {
          dataId: {
            type: 'number'
          },
          textures: {
            type: Array,
            meta: {
              element: {
                type: _Texture["default"],
                meta: {
                  dataId: {
                    type: 'number'
                  },
                  id: {
                    type: 'number'
                  },
                  name: {
                    type: 'string'
                  },
                  mesh: {
                    type: _Mesh["default"],
                    meta: {
                      size: {
                        prototype: _Size["default"],
                        meta: {
                          width: {
                            type: 'number'
                          },
                          height: {
                            type: 'number'
                          }
                        }
                      },
                      position: {
                        prototype: _Vector["default"],
                        meta: {
                          x: {
                            type: 'number'
                          },
                          y: {
                            type: 'number'
                          },
                          z: {
                            type: 'number'
                          }
                        }
                      },
                      dataUrl: {
                        type: 'string'
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};
exports["default"] = _default;

},{"../core/Camera.js":32,"../core/Mesh.js":37,"../core/Texture.js":40,"../entity/EntityMotion.js":43,"../physics/Physics.js":123,"../pobject/EntityProps.js":133,"../pobject/PerlinNoiseConfig.js":134,"../pobject/PhysicsProps.js":135,"../pobject/Size.js":136,"../pobject/Style.js":137,"../utils/Vector.js":169,"../world/World.js":171,"../world/manager/EntityManager.js":173,"../world/manager/TextureManager.js":175,"../world/terrain/Terrain.js":176,"../world/terrain/TerrainManager.js":177,"@babel/runtime/helpers/interopRequireDefault":12}],157:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Schema = _interopRequireDefault(require("../schema/Schema.js"));

var _SerDe2 = _interopRequireDefault(require("./SerDe.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {JsSerDe}
 * @extends {SerDe}
 */
var JsSerDe = /*#__PURE__*/function (_SerDe) {
  (0, _inherits2["default"])(JsSerDe, _SerDe);

  var _super = _createSuper(JsSerDe);

  function JsSerDe() {
    (0, _classCallCheck2["default"])(this, JsSerDe);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(JsSerDe, [{
    key: "serialize",

    /**
     * @override
     */
    value: function serialize(data) {
      if (_.isArray(data)) {
        throw new TypeError('Data to export must be an Object');
      }

      var schema = _Schema["default"].getMeta();

      var result = this.exportData('world', data, schema);
      return result.concat('var EngineWorldData = {world}').join('');
    }
    /**
     * @override
     */

  }, {
    key: "deserialize",
    value: function deserialize(data) {
      return null;
    }
    /**
     * @param {string} key
     * @param {Object|Array} data
     * @param {Object} schema
     * @param {string} varname
     * @param {string} schemaPrefix
     *
     * @returns {string[]}
     */

  }, {
    key: "exportData",
    value: function exportData(key, data, schema) {
      var varname = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      var schemaPrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
      var instr = [];
      var schemaMeta = "".concat(schemaPrefix).concat(key);
      varname = varname ? varname : key;

      if (_.isObject(data) || _.isArray(data)) {
        instr.push("var ".concat(varname, " = new ").concat(!_.isArray(data) ? 'EngineData.' : '').concat(data.constructor.name, "();"));

        for (var iData in data) {
          if (data.hasOwnProperty(iData)) {
            var pKey = "".concat(varname).concat(iData);
            var pSchemaKey = _.isArray(data) ? 'element' : iData;
            var pValue = void 0;
            var subInstr = this.exportData(pSchemaKey, data[iData], schema, pKey, "".concat(schemaMeta, "."));

            if (subInstr.length) {
              instr = instr.concat(subInstr);
              pValue = pKey;
            } else {
              pValue = data[iData];
              var schemaMetaData = schema["".concat(schemaMeta, ".").concat(pSchemaKey)];

              if (schemaMetaData) {
                pValue = schemaMetaData.prototype === 'string' ? "\"".concat(pValue, "\"") : pValue;
              } else {
                throw new TypeError("".concat(schemaMeta, ".").concat(pSchemaKey, " not found in the Schema!"));
              }
            }

            if (data.constructor === Array) {
              instr.push("".concat(varname, "[").concat(iData, "] = ").concat(pValue, ";"));
            } else {
              instr.push("".concat(varname, ".").concat(iData, " = ").concat(pValue, ";"));
            }
          }
        }
      }

      return instr;
    }
  }]);
  return JsSerDe;
}(_SerDe2["default"]);

var _default = JsSerDe;
exports["default"] = _default;

},{"../schema/Schema.js":155,"./SerDe.js":158,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],158:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * @abstract
 * @class {SerDe}
 */
var SerDe = /*#__PURE__*/function () {
  function SerDe() {
    (0, _classCallCheck2["default"])(this, SerDe);
  }

  (0, _createClass2["default"])(SerDe, [{
    key: "serialize",

    /**
     * @abstract
     * @param {Object} data
     * @return {string}
     */
    value: function serialize(data) {
      throw new TypeError('SerDe.serialize must be implemented');
    }
    /**
     * @abstract
     * @param {Object|string} data
     * @return {Object|Map<string, *>}
     */

  }, {
    key: "deserialize",
    value: function deserialize(data) {
      throw new TypeError('SerDe.deserialize must be implemented');
    }
  }]);
  return SerDe;
}();

var _default = SerDe;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],159:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _SerDe2 = _interopRequireDefault(require("./SerDe.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {XmlSerDe}
 * @extends {SerDe}
 */
var XmlSerDe = /*#__PURE__*/function (_SerDe) {
  (0, _inherits2["default"])(XmlSerDe, _SerDe);

  var _super = _createSuper(XmlSerDe);

  function XmlSerDe() {
    (0, _classCallCheck2["default"])(this, XmlSerDe);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(XmlSerDe, [{
    key: "serialize",

    /**
     * @override
     */
    value: function serialize(data) {
      if (_.isArray(data)) {
        throw new TypeError('Data to export must be an Object');
      }

      var xmlSerializer = new XMLSerializer();
      var root = document.implementation.createDocument('', '', null);
      var dataNode = this.exportData('project', data, root);
      root.appendChild(dataNode);
      return xmlSerializer.serializeToString(root);
    }
    /**
     * @override
     */

  }, {
    key: "deserialize",
    value: function deserialize(data) {
      if (_.isArray(data)) {
        throw new TypeError('Data to export must be an Object');
      }

      var parser = new DOMParser();
      var node = parser.parseFromString(data, 'application/xml');
      return this.importData('project', node.documentElement);
    }
    /**
     * @private
     * @param {string} key
     * @param {HTMLElement|ChildNode} node
     * @return {Map<string, *>}
     */

  }, {
    key: "importData",
    value: function importData(key, node) {
      var _this = this;

      var isArray = key === 'element';
      var data = {};
      var attributes = node.attributes;

      for (var nodeAttr in attributes) {
        if (attributes.hasOwnProperty(nodeAttr)) {
          var attribute = attributes[nodeAttr].name;
          data[attribute] = attributes[attribute].nodeValue;
        }
      }

      node.childNodes.forEach(function (cNode) {
        var subObject = _this.importData(cNode.nodeName, cNode);

        if (subObject) {
          if (_.isArray(subObject)) {
            data = !Object.keys(data).length ? [] : data;
            data = data.concat(subObject);
          } else {
            data = Object.assign(data, subObject);
          }
        }
      });
      return isArray ? [data] : (0, _defineProperty2["default"])({}, key, data);
    }
    /**
     * @private
     * @param {string} key
     * @param {Object|Array} data
     * @param {Document} root
     *
     * @returns {HTMLElement}
     */

  }, {
    key: "exportData",
    value: function exportData(key, data, root) {
      var isArray = _.isArray(data);

      if (_.isObject(data) || _.isArray(data)) {
        var node = root.createElement(key);

        for (var iData in data) {
          if (data.hasOwnProperty(iData)) {
            var pKey = isArray ? 'element' : iData;
            var pValue = data[iData];
            var subNode = this.exportData(pKey, pValue, root);

            if (subNode) {
              node.appendChild(subNode);
            } else {
              pValue !== null && node.setAttribute(pKey, pValue);
            }
          }
        }

        return node;
      }

      return null;
    }
  }]);
  return XmlSerDe;
}(_SerDe2["default"]);

var _default = XmlSerDe;
exports["default"] = _default;

},{"./SerDe.js":158,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],160:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _Mouse = _interopRequireDefault(require("../core/Mouse.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var CURSOR = _Mouse["default"].CURSOR;
/**
 * @typedef {{code: string, id: number}} StateType
 */

/**
 * Manage the state of the application over time
 * @property {StateType[]} stateList
 */

var AppState = /*#__PURE__*/function () {
  function AppState() {
    (0, _classCallCheck2["default"])(this, AppState);
    this.reset();
  }
  /**
   * Get the state of the application (drawing ellipse,
   * starting/pausing simulation, moving object, ...).
   */


  (0, _createClass2["default"])(AppState, [{
    key: "getState",
    value: function getState() {
      return this.state;
    }
    /**
     * Get all data associated to a topic.
     * Used to access data related to a state
     * @param {String} topic
     */

  }, {
    key: "getData",
    value: function getData(topic) {
      return this.data && this.data[topic];
    }
    /**
     * Set data.
     * Used to set data for a given state
     * @param {Object} data
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.data = _.merge(this.data, data);
      return this;
    }
    /**
     * Set data associated to a topic
     * @param {string} topic
     * @param {Object|Array} data
     */

  }, {
    key: "setDataByTopic",
    value: function setDataByTopic(topic, data) {
      var dataTopic = this.data[topic];

      if (dataTopic) {
        if (_.isArray(dataTopic)) {
          this.data[topic] = dataTopic.concat(data);
        } else {
          this.data[topic] = _objectSpread({
            dataTopic: dataTopic
          }, data);
        }
      } else {
        this.data[topic] = data;
      }

      return this;
    }
    /**
     * Verify if Application has a state.
     * @param {String} state
     */

  }, {
    key: "hasState",
    value: function hasState(state) {
      return this.state.indexOf(state) >= 0;
    }
    /**
     * Verify if Application has a data state.
     * @param {Object} data
     */

  }, {
    key: "hasData",
    value: function hasData(data) {
      for (var pIndex in data) {
        if (data[pIndex] !== this.data[pIndex]) {
          return false;
        }
      }

      return true;
    }
    /**
     * Add a state to the states list.
     * @param {string} state
     */

  }, {
    key: "addState",
    value: function addState(state) {
      if (this.state.indexOf(state) === -1) {
        if (Object.keys(AppState.States).indexOf(state) >= 0) {
          this.state.push(state);
          var cursor = AppState.States[state].cursor;
          cursor && this.setData({
            cursor: cursor
          });
        } else {
          throw new TypeError("".concat(state, " is not recognized as Application State"));
        }
      }
    }
    /**
     * Is the state can trigger history
     * @param {string} state
     * @return {boolean}
     */

  }, {
    key: "getIsHistory",
    value: function getIsHistory(state) {
      var history = AppState.States[state].history;
      return history;
    }
    /**
     * Find all indices for a specific state or state pattern, use exact param to search for
     * state within the same pattern
     * @param {String} state
     * @param {Boolean} exact
     */

  }, {
    key: "findStateIndex",
    value: function findStateIndex(state) {
      var exact = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var indices = [];

      if (exact) {
        var index = this.state.indexOf(state);

        if (index >= 0) {
          indices.push(index);
        }
      } else {
        var regExpState = new RegExp("^".concat(state));
        this.state.map(function (state_, index) {
          return state_.match(regExpState) && indices.push(index);
        });
      }

      return indices;
    }
    /**
     * Remove a state from the application, use exact param to search for
     * state within the same pattern
     * @param {String} state
     * @param {Boolean} exact
     */

  }, {
    key: "removeState",
    value: function removeState(state) {
      var _this = this;

      var exact = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var indices = this.findStateIndex(state, exact);
      indices.map(function (index) {
        return _this.state.splice(index, 1);
      });
    }
    /**
     * Remove data state
     * @param {string} state
     */

  }, {
    key: "removeData",
    value: function removeData(state) {
      delete this.data[state];
    }
    /**
     * Remove all states from the application
     */

  }, {
    key: "removeAllState",
    value: function removeAllState() {
      this.state = [];
    }
    /**
     * Set an uniq state for a specific group (
     * Remove all state which contains the same prefix
     * value and add the new state to the same group.
     * @param {String} stateGroup
     * @param {String} type
     */

  }, {
    key: "setUniqStateByGroup",
    value: function setUniqStateByGroup(stateGroup, type) {
      var state = "".concat(stateGroup, "_").concat(type);
      var isHistory = !this.findStateIndex(state, true).length;
      this.removeState(stateGroup, false);
      this.addState(state, isHistory);
    }
    /**
     * Set a state.
     * @param {String} state
     */

  }, {
    key: "setState",
    value: function setState(state) {
      var isHistory = !this.findStateIndex(state, true).length;
      this.addState(state, isHistory);
    }
    /**
     * Reset the state of the application
     */

  }, {
    key: "reset",
    value: function reset() {
      this.state = [];
      this.data = {};
    }
  }], [{
    key: "get",
    value: function get() {
      if (!AppState.instance) {
        AppState.instance = new AppState();
      }

      return AppState.instance;
    }
  }]);
  return AppState;
}();

AppState.instance = null;
/**
 * @todo: Think to externalize the states configuration
 */

AppState.States = {
  DRAW_RECT_START: {
    history: false,
    cursor: CURSOR.CROSSHAIR
  },
  DRAW_JOINT_START: {
    history: false,
    cursor: CURSOR.CROSSHAIR
  },
  DRAW_ATTACH_POINT_START: {
    history: false,
    cursor: CURSOR.POINTER
  },
  DRAW_SELECT_START: {
    history: false,
    cursor: CURSOR.MOVE_ENTITY
  },
  DRAW_CIRCLE_START: {
    history: false,
    cursor: CURSOR.CROSSHAIR
  },
  DRAW_RECT_PROGRESS: {
    history: false,
    cursor: CURSOR.CROSSHAIR
  },
  DRAW_JOINT_PROGRESS: {
    history: false,
    cursor: CURSOR.CROSSHAIR
  },
  DRAW_ATTACH_POINT_PROGRESS: {
    history: false,
    cursor: CURSOR.POINTER
  },
  DRAW_SELECT_PROGRESS: {
    history: false,
    cursor: CURSOR.MOVE_ENTITY
  },
  DRAW_CIRCLE_PROGRESS: {
    history: false,
    cursor: CURSOR.CROSSHAIR
  },
  DRAW_CIRCLE_STOP: {
    history: true,
    cursor: CURSOR.DEFAULT
  },
  DRAW_RECT_STOP: {
    history: true,
    cursor: CURSOR.DEFAULT
  },
  DRAW_JOINT_STOP: {
    history: true,
    cursor: CURSOR.DEFAULT
  },
  DRAW_ATTACH_POINT_STOP: {
    history: true
  },
  DRAW_SELECT_STOP: {
    history: false
  },
  SIMULATE_START: {
    history: false,
    cursor: CURSOR.DEFAULT
  },
  SIMULATE_PROGRESS: {
    history: false
  },
  SIMULATE_STOP: {
    history: false
  },
  ACTION_DELETE_START: {
    history: true
  },
  ACTION_DELETE_PROGRESS: {
    history: false
  },
  ACTION_DELETE_STOP: {
    history: false
  },
  ACTION_DUPLICATE_START: {
    history: true
  },
  ACTION_DUPLICATE_PROGRESS: {
    history: false
  },
  ACTION_DUPLICATE_STOP: {
    history: false
  },
  ACTION_UNDO_START: {
    history: false
  },
  ACTION_UNDO_PROGRESS: {
    history: false
  },
  ACTION_UNDO_STOP: {
    history: false
  },
  ACTION_MOVE_START: {
    history: true,
    cursor: CURSOR.MOVE
  },
  ACTION_MOVE_PROGRESS: {
    history: false
  },
  ACTION_MOVE_STOP: {
    history: false
  },
  ACTION_MOVE_UP_START: {
    history: true
  },
  ACTION_MOVE_UP_PROGRESS: {
    history: false
  },
  ACTION_MOVE_UP_STOP: {
    history: false
  },
  ACTION_MOVE_DOWN_START: {
    history: true
  },
  ACTION_MOVE_DOWN_PROGRESS: {
    history: false
  },
  ACTION_MOVE_DOWN_STOP: {
    history: false
  },
  ACTION_LOCK_START: {
    history: true
  },
  ACTION_LOCK_PROGRESS: {
    history: false
  },
  ACTION_LOCK_STOP: {
    history: false
  },
  ACTION_UNLOCK_START: {
    history: true
  },
  ACTION_UNLOCK_PROGRESS: {
    history: false
  },
  ACTION_UNLOCK_STOP: {
    history: false
  },
  ACTION_HIDE_START: {
    history: true
  },
  ACTION_HIDE_PROGRESS: {
    history: false
  },
  ACTION_HIDE_STOP: {
    history: false
  },
  ACTION_SHOW_START: {
    history: true
  },
  ACTION_SHOW_PROGRESS: {
    history: false
  },
  ACTION_SHOW_STOP: {
    history: false
  },
  ACTION_ROTATE_UP_START: {
    history: true
  },
  ACTION_ROTATE_UP_PROGRESS: {
    history: false
  },
  ACTION_ROTATE_UP_STOP: {
    history: false
  },
  ACTION_SELECT_ENTITY_START: {
    history: true
  },
  ACTION_SELECT_ENTITY_PROGRESS: {
    history: false
  },
  ACTION_SELECT_ENTITY_STOP: {
    history: false
  },
  ACTION_HISTORY_PUSH_START: {
    history: false
  },
  ACTION_HISTORY_PUSH_PROGRESS: {
    history: false
  },
  ACTION_HISTORY_PUSH_STOP: {
    history: false
  },
  ACTION_PHYSICS_STATIC_START: {
    history: true
  },
  ACTION_PHYSICS_STATIC_PROGRESS: {
    history: false
  },
  ACTION_PHYSICS_STATIC_STOP: {
    history: false
  },
  ACTION_PHYSICS_NOT_STATIC_START: {
    history: true
  },
  ACTION_PHYSICS_NOT_STATIC_PROGRESS: {
    history: false
  },
  ACTION_PHYSICS_NOT_STATIC_STOP: {
    history: false
  },
  ACTION_FORM_UPDATE_START: {
    history: false
  },
  ACTION_FORM_UPDATE_PROGRESS: {
    history: false
  },
  ACTION_FORM_UPDATE_STOP: {
    history: false
  },
  ACTION_MOVE_CAMERA_START: {
    history: false
  },
  ACTION_MOVE_CAMERA_PROGRESS: {
    history: false
  },
  ACTION_MOVE_CAMERA_STOP: {
    history: false
  },
  ACTION_ZOOM_CAMERA_START: {
    history: false
  },
  ACTION_ZOOM_CAMERA_PROGRESS: {
    history: false
  },
  ACTION_ZOOM_CAMERA_STOP: {
    history: false
  },
  ACTION_SAVE_PROJECT_START: {
    history: false
  },
  ACTION_SAVE_PROJECT_PROGRESS: {
    history: false
  },
  ACTION_SAVE_PROJECT_STOP: {
    history: false
  },
  ACTION_LOAD_PROJECT_START: {
    history: false
  },
  ACTION_LOAD_PROJECT_PROGRESS: {
    history: false
  },
  ACTION_LOAD_PROJECT_STOP: {
    history: false
  },
  ACTION_NEW_PROJECT_START: {
    history: false
  },
  ACTION_NEW_PROJECT_PROGRESS: {
    history: false
  },
  ACTION_NEW_PROJECT_STOP: {
    history: false
  },
  ACTION_EXPORT_PROJECT_START: {
    history: false
  },
  ACTION_EXPORT_PROJECT_PROGRESS: {
    history: false
  },
  ACTION_EXPORT_PROJECT_STOP: {
    history: false
  },
  ACTION_SELECT_LIST_ELEMENT_START: {
    history: false
  },
  ACTION_SELECT_LIST_ELEMENT_PROGRESS: {
    history: false
  },
  ACTION_SELECT_LIST_ELEMENT_STOP: {
    history: false
  }
};
var _default = AppState;
exports["default"] = _default;

},{"../core/Mouse.js":38,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12}],161:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _AppState = _interopRequireDefault(require("./AppState.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Manage the state of the application
 * @property {AppState} appState
 */
var StateManager = /*#__PURE__*/function () {
  /**
   * @type {StateManager}
   */
  function StateManager() {
    (0, _classCallCheck2["default"])(this, StateManager);
    this.appState = _AppState["default"].get();
  }
  /**
   * @param {string} state
   * @return {string|null}
   */


  (0, _createClass2["default"])(StateManager, [{
    key: "getType",
    value: function getType(state) {
      var stepPrefix = ['START', 'PROGRESS', 'STOP'];

      for (var iStep in stepPrefix) {
        if (stepPrefix.hasOwnProperty(iStep)) {
          var regex = new RegExp("([A-Z_]+)_".concat(stepPrefix[iStep], "$"));

          if (state.match(regex)) {
            return state.replace(regex, '$1');
          }
        }
      }

      return null;
    }
    /**
     * Is the state type a start action
     * @param {string} type
     */

  }, {
    key: "isStart",
    value: function isStart(type) {
      return this.appState.hasState("".concat(type, "_START")) && this.getNextStartData(type);
    }
    /**
     * Is the state type in progress
     * @param {string} type
     */

  }, {
    key: "isProgress",
    value: function isProgress(type) {
      return this.appState.hasState("".concat(type, "_PROGRESS")) && this.getNextProgressData(type);
    }
    /**
     * Is the action type a stop action
     * @param {string} type
     */

  }, {
    key: "isStop",
    value: function isStop(type) {
      return this.appState.hasState("".concat(type, "_STOP")) && this.getNextStopData(type);
    }
    /**
     * Start an action by type and data (state)
     * @param {string} type
     * @param {number} id
     * @param {Object} data
     * @TODO Add history (call addHistory(state))
     */

  }, {
    key: "startState",
    value: function startState(type, id) {
      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!id) {
        throw new TypeError('Action id must be defined');
      }

      var state = "".concat(type, "_START");
      this.appState.addState(state);
      this.appState.setDataByTopic(state, [_objectSpread({
        id: id
      }, data)]);
    }
    /**
     * Progress an action (state)
     * @param {string} type
     * @param {number} id
     * @TODO Add history (call addHistory(state))
     */

  }, {
    key: "progressState",
    value: function progressState(type, id) {
      if (!id) {
        throw new TypeError('Action id must be defined');
      }

      var state = "".concat(type, "_PROGRESS");
      var data = this.getStartData(type, id);
      this.appState.addState(state);
      data && this.appState.setData((0, _defineProperty2["default"])({}, state, [data]));
      this.removeStartState(type, id);
    }
    /**
     * Stop an action (state)
     * @param {string} type
     * @param {number} id
     * @TODO Add history (call addHistory(state))
     */

  }, {
    key: "stopState",
    value: function stopState(type, id) {
      if (!id) {
        throw new TypeError('Action id must be defined');
      }

      var state = "".concat(type, "_STOP");
      var data = this.getProgressData(type, id);
      this.appState.addState(state);
      data && this.appState.setData((0, _defineProperty2["default"])({}, state, [data]));
      this.removeStartState(type, id);
      this.removeProgressState(type, id);
    }
    /**
     * Delete the stop action (end action)
     * @param {string} type
     * @param {number} id
     */

  }, {
    key: "endState",
    value: function endState(type, id) {
      if (!id) {
        throw new TypeError('Action id must be defined');
      }

      this.removeProgressState(type, id);
      this.removeStopState(type, id);
    }
    /**
     * @param {string} type
     */

  }, {
    key: "progressNextState",
    value: function progressNextState(type) {
      var data = this.getNextStartData(type);

      if (data) {
        this.progressState(type, data.id);
      } else {
        throw new TypeError("Progress data state not found for ".concat(type));
      }
    }
    /**
     * @param {string} type
     */

  }, {
    key: "stopNextState",
    value: function stopNextState(type) {
      var data = this.getNextProgressData(type) || this.getNextStartData(type);

      if (data) {
        this.stopState(type, data.id);
      } else {
        throw new TypeError("Stop data state not found for ".concat(type));
      }
    }
    /**
     * @param {string} type
     */

  }, {
    key: "endNextState",
    value: function endNextState(type) {
      var data = this.getNextStopData(type);

      if (data) {
        this.endState(type, data.id);
      } else {
        throw new TypeError("End data state not found for ".concat(type));
      }
    }
    /**
     * Is state has action of given type/id
     * @param {string} type
     * @param {number} id
     * @return {boolean}
     */

  }, {
    key: "hasState",
    value: function hasState(type, id) {
      return (this.isStart(type) || this.isStop(type) || this.isProgress(type)) && (this.getStartData(type, id) || this.getProgressData(type, id) || this.getStartData(type, id));
    }
    /**
     * Is running states in progress
     * @return {boolean}
     */

  }, {
    key: "isRunning",
    value: function isRunning() {
      return this.isProgress('SIMULATE');
    }
    /**
     * Add data to history (state)
     * @param {string} state
     * @TODO check we can not pass an ID
     */

  }, {
    key: "addHistory",
    value: function addHistory(state) {
      var isHistory = this.appState.getIsHistory(state);

      if (isHistory) {
        this.startState('ACTION_HISTORY_PUSH', 1);
      }
    }
    /**
     * Get the start state data
     * @param {string} type
     * @param {number} id
     * @return {Object|null}
     */

  }, {
    key: "getStartData",
    value: function getStartData(type, id) {
      if (!id) {
        throw new TypeError('Action id must be defined');
      }

      return this.getStateData("".concat(type, "_START"), id);
    }
    /**
     * Get the progress state data
     * @param {string} type
     * @param {number} id
     * @return {Object|null}
     */

  }, {
    key: "getProgressData",
    value: function getProgressData(type, id) {
      if (!id) {
        throw new TypeError('Action id must be defined');
      }

      return this.getStateData("".concat(type, "_PROGRESS"), id);
    }
    /**
     * Get the start state data
     * @param {string} type
     * @param {number} id
     * @return {Object|null}
     */

  }, {
    key: "getStopData",
    value: function getStopData(type, id) {
      if (!id) {
        throw new TypeError('Action id must be defined');
      }

      return this.getStateData("".concat(type, "_STOP"), id);
    }
    /**
     * Get the next progress state data
     * @param {string} type
     * @return {Object|null}
     */

  }, {
    key: "getNextStartData",
    value: function getNextStartData(type) {
      return this.getNextData("".concat(type, "_START"));
    }
    /**
     * Get the next progress state data
     * @param {string} type
     * @return {Object|null}
     */

  }, {
    key: "getNextProgressData",
    value: function getNextProgressData(type) {
      return this.getNextData("".concat(type, "_PROGRESS"));
    }
    /**
     * Get the next progress state data
     * @param {string} type
     * @return {Object|null}
     */

  }, {
    key: "getNextStopData",
    value: function getNextStopData(type) {
      return this.getNextData("".concat(type, "_STOP"));
    }
    /**
     * Remove the start state
     * @param {string} type
     * @param {number} id
     */

  }, {
    key: "removeStartState",
    value: function removeStartState(type, id) {
      this.removeState("".concat(type, "_START"), id);
    }
    /**
     * Remove the progress state
     * @param {string} type
     * @param {number} id
     */

  }, {
    key: "removeProgressState",
    value: function removeProgressState(type, id) {
      this.removeState("".concat(type, "_PROGRESS"), id);
    }
    /**
     * Remove the stop state
     * @param {string} type
     * @param {number} id
     */

  }, {
    key: "removeStopState",
    value: function removeStopState(type, id) {
      this.removeState("".concat(type, "_STOP"), id);
    }
    /**
     * Get the data by State/Id
     * @private
     * @param {string} type
     * @param {number} id
     */

  }, {
    key: "getDataById",
    value: function getDataById(type, id) {
      var data = this.getData(type);
      return data && data.find(function (value) {
        return value && value.id === id;
      });
    }
    /**
     * Get the data state for the given type
     * @private
     * @param {string} state
     * @return {Array}
     */

  }, {
    key: "getData",
    value: function getData(state) {
      return this.appState.getData(state);
    }
    /**
     * Get the next data state for the given type
     * @private
     * @param {string} state
     * @return {Object}
     */

  }, {
    key: "getNextData",
    value: function getNextData(state) {
      var data = this.getData(state);
      return data && data[0];
    }
    /**
     * Remove the state
     * @private
     * @param {string} state
     * @param {number} id
     */

  }, {
    key: "removeState",
    value: function removeState(state, id) {
      this.removeStateData(state, id);
    }
    /**
     * Remove the state data
     * @private
     * @param {string} state
     * @param {number} id
     */

  }, {
    key: "removeStateData",
    value: function removeStateData(state, id) {
      var dataList = this.getData(state);
      var data = this.getDataById(state, id);

      if (data) {
        dataList.splice(dataList.indexOf(data), 1);
      }

      if (dataList && !dataList.length) {
        this.appState.removeState(state);
        this.appState.removeData(state);
      }
    }
    /**
     * Get the state data
     * @private
     * @param {string} state
     * @param {number} id
     * @return {Object|null}
     */

  }, {
    key: "getStateData",
    value: function getStateData(state, id) {
      return this.getDataById(state, id);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.appState.reset();
    }
    /**
     * Search for all states and stop them all
     */

  }, {
    key: "stopAll",
    value: function stopAll() {
      var _this = this;

      var states = this.appState.getState();
      states.forEach(function (state) {
        var type = _this.getType(state);

        type && _this.stopNextState(type);
      });
    }
    /**
     * @return {StateManager}
     */

  }], [{
    key: "get",
    value: function get() {
      if (!StateManager.instance) {
        StateManager.instance = new StateManager();
      }

      return StateManager.instance;
    }
  }]);
  return StateManager;
}();

(0, _defineProperty2["default"])(StateManager, "instance", null);
var _default = StateManager;
exports["default"] = _default;

},{"./AppState.js":160,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12}],162:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * @class {ClassHelper}
 */
var ClassHelper = /*#__PURE__*/function () {
  function ClassHelper() {
    (0, _classCallCheck2["default"])(this, ClassHelper);
  }

  (0, _createClass2["default"])(ClassHelper, null, [{
    key: "getSetter",

    /**
     * Get the setter name
     * @param {*} object
     * @param {string} key
     * @return {string}
     */
    value: function getSetter(object, key) {
      var setter;

      if (object.constructor === Array) {
        setter = 'push';
      } else {
        var prefix = 'set';
        setter = "".concat(prefix).concat(key.charAt(0).toUpperCase() + key.slice(1));

        if (typeof object[setter] !== 'function') {
          throw new TypeError("".concat(setter, " must be implemented for ").concat(object.constructor.name));
        }
      }

      return setter;
    }
    /**
     * Get the getter name
     * @param {*} object
     * @param {string} key
     * @return {string}
     */

  }, {
    key: "getGetter",
    value: function getGetter(object, key) {
      var getter;

      if (object.constructor === Array) {
        getter = key;
      } else {
        var prefix = 'get';
        getter = "".concat(prefix).concat(key.charAt(0).toUpperCase() + key.slice(1));

        if (typeof object[getter] !== 'function') {
          throw new TypeError("".concat(key, ": ").concat(getter, " must be implemented for ").concat(object.constructor.name));
        }
      }

      return getter;
    }
  }]);
  return ClassHelper;
}();

var _default = ClassHelper;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],163:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Color libs
 */
var Color = /*#__PURE__*/function () {
  function Color() {
    (0, _classCallCheck2["default"])(this, Color);
  }

  (0, _createClass2["default"])(Color, null, [{
    key: "fromArrayInt",

    /**
     * Generate color from integers
     */
    value: function fromArrayInt(ints) {
      var _int = ints.reduce(function (sum, num) {
        return sum + parseInt(num);
      }, 0);

      return (_int & 0x00FFFFFF).toString(16).toUpperCase();
    }
  }]);
  return Color;
}();

var _default = Color;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],164:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _Constant = require("../core/Constant.js");

/**
 * @class {ImageHelper}
 */
var ImageHelper = /*#__PURE__*/function () {
  function ImageHelper() {
    (0, _classCallCheck2["default"])(this, ImageHelper);
  }

  (0, _createClass2["default"])(ImageHelper, null, [{
    key: "getDataURL",

    /**
     * @param {OffscreenCanvas} canvas
     * @param {Size} size
     * @return {string}
     */
    value: function getDataURL(canvas, size) {
      var sizeWidth = size.width,
          sizeHeight = size.height;
      var isWidthGtHeight = canvas.width > canvas.height;
      var coefResize = isWidthGtHeight ? sizeWidth / canvas.width : sizeHeight / canvas.height;
      var width = isWidthGtHeight ? sizeWidth : canvas.width * coefResize;
      var height = isWidthGtHeight ? canvas.height * coefResize : sizeHeight;
      var canvasEl = document.createElement('canvas');
      canvasEl.width = width;
      canvasEl.height = height;
      var contextEl = canvasEl.getContext(_Constant.CANVAS_CONTEXT_TYPE);
      contextEl.drawImage(canvas, 0, 0, width, height);
      var dataUrl = canvasEl.toDataURL('image/png');
      canvasEl.remove();
      return dataUrl;
    }
  }]);
  return ImageHelper;
}();

var _default = ImageHelper;
exports["default"] = _default;

},{"../core/Constant.js":33,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],165:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Maths libs
 */
var Maths = /*#__PURE__*/function () {
  function Maths() {
    (0, _classCallCheck2["default"])(this, Maths);
  }

  (0, _createClass2["default"])(Maths, null, [{
    key: "generateId",

    /**
     * Generate an uniqu ID
     * @return {number}
     */
    value: function generateId() {
      return Date.now() + parseInt(Math.random() * 100000);
    }
    /**
     * Convert degree to randian
     * @param {Number} deg
     */

  }, {
    key: "fromDegree",
    value: function fromDegree(deg) {
      return deg * Math.PI / 180;
    }
    /**
     * Convert radian to degree
     * @param {Number} rad
     */

  }, {
    key: "toDegree",
    value: function toDegree(rad) {
      return Math.round(rad * 180 / Math.PI * 100) / 100;
    }
    /**
     * Get random value within an interval
     * @param {Number} min
     * @param {Number} max
     */

  }, {
    key: "randomInterval",
    value: function randomInterval(min, max) {
      return Math.random() * (max - min) + min;
    }
    /**
     * @param {number} a
     * @param {number} b
     * @param {number} t
     * @return {number}
     */

  }, {
    key: "cosineInterpolate",
    value: function cosineInterpolate(a, b, t) {
      var c = (1 - Math.cos(t * 3.1415927)) * .5;
      return (1. - c) * a + c * b;
    }
  }]);
  return Maths;
}();

var _default = Maths;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],166:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Generate noise random using given seed
 * @property {number} seed
 */
var NoiseRandom = /*#__PURE__*/function () {
  /**
   * @param {number} seed
   */
  function NoiseRandom(seed) {
    (0, _classCallCheck2["default"])(this, NoiseRandom);
    this.seed = seed;
  }
  /**
   * Return random value between 0 and 1
   * @param {number} value
   * @return {number}
   */


  (0, _createClass2["default"])(NoiseRandom, [{
    key: "getNoiseValue",
    value: function getNoiseValue(value) {
      value += this.seed;
      var result = BigInt(value << 13 ^ value);
      result = result * (result * result * BigInt(15731) + BigInt(789221)) + BigInt(1376312589);
      result = parseInt(result.toString(2).slice(-31), 2);
      return 1.0 - result / 1073741824;
    }
    /**
     * @param {number} seed
     * @return {NoiseRandom}
     */

  }], [{
    key: "get",
    value: function get(seed) {
      return new NoiseRandom(seed);
    }
  }]);
  return NoiseRandom;
}();

var _default = NoiseRandom;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],167:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * @class {ObjectHelper}
 */
var ObjectHelper = /*#__PURE__*/function () {
  function ObjectHelper() {
    (0, _classCallCheck2["default"])(this, ObjectHelper);
  }

  (0, _createClass2["default"])(ObjectHelper, null, [{
    key: "isEqual",

    /**
     * @param {Object} object1
     * @param {Object} object2
     * @return {boolean}
     */
    value: function isEqual(object1, object2) {
      return !Object.getOwnPropertyNames(object1).find(function (prop) {
        return object1[prop] !== object2[prop];
      });
    }
  }]);
  return ObjectHelper;
}();

var _default = ObjectHelper;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],168:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _Maths = _interopRequireDefault(require("./Maths.js"));

var _NoiseRandom = _interopRequireDefault(require("./NoiseRandom.js"));

/**
 * Generate perlin noise random values
 * @property {number} seed
 * @property {PerlinNoiseConfig} configs
 */
var PerlinNoise = /*#__PURE__*/function () {
  /**
   * @param {PerlinNoiseConfig} configs
   */
  function PerlinNoise(configs) {
    (0, _classCallCheck2["default"])(this, PerlinNoise);
    this.configs = configs;
  }
  /**
   * @param {number} x
   * @param {number} y
   * @return {number}
   */


  (0, _createClass2["default"])(PerlinNoise, [{
    key: "noise",
    value: function noise(x, y) {
      var integerX = Math.floor(x);
      var integerY = Math.floor(y);
      var fractionalX = x - integerX;
      var fractionalY = y - integerY;
      var a = this.getNoise(integerX, integerY);
      var b = this.getNoise(integerX + 1, integerY);
      var c = this.getNoise(integerX, integerY + 1);
      var d = this.getNoise(integerX + 1, integerY + 1);

      var f = _Maths["default"].cosineInterpolate(a, b, fractionalX);

      var g = _Maths["default"].cosineInterpolate(c, d, fractionalY);

      return _Maths["default"].cosineInterpolate(f, g, fractionalY);
    }
    /**
     * @param {number} x
     * @param {number} y
     * @return {number}
     */

  }, {
    key: "getNoise",
    value: function getNoise(x, y) {
      return _NoiseRandom["default"].get(this.configs.seed).getNoiseValue(x + y);
    }
    /**
     * @param {number} x
     * @param {number} y
     * @return {number}
     */

  }, {
    key: "getPerlinNoise",
    value: function getPerlinNoise(x, y) {
      var r = 0;

      for (var i = 0; i <= this.configs.octaves; i++) {
        var frequency = Math.pow(2, i);
        var amplitude = Math.pow(this.configs.persistence, i);
        var noise = this.noise(x * frequency / this.configs.smoothness, y * frequency / this.configs.smoothness);
        r += noise * amplitude;
      }

      var result = (r / 2 + 1) * this.configs.amplitude - 20;
      return result > 0 ? result : 1;
    }
  }]);
  return PerlinNoise;
}();
/**
 * @typedef {{seed: number, octaves: number, amplitude: number, persistence: number, smoothness: number}} PerlinNoiseConfig
 */


var _default = PerlinNoise;
exports["default"] = _default;

},{"./Maths.js":165,"./NoiseRandom.js":166,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],169:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Vector class.
 * Define a vector coordinate (X, Y)
 */
var Vector = /*#__PURE__*/function () {
  function Vector() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      x: 0,
      y: 0,
      z: 0
    },
        x = _ref.x,
        y = _ref.y,
        z = _ref.z;

    (0, _classCallCheck2["default"])(this, Vector);
    this.x = x;
    this.y = y;
    this.z = z;
  }
  /**
   * @param {number} x
   */


  (0, _createClass2["default"])(Vector, [{
    key: "setX",
    value: function setX(x) {
      this.x = x;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getX",
    value: function getX() {
      return this.x;
    }
    /**
     * @param {number} y
     */

  }, {
    key: "setY",
    value: function setY(y) {
      this.y = y;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getY",
    value: function getY() {
      return this.y;
    }
    /**
     * @param {number} z
     */

  }, {
    key: "setZ",
    value: function setZ(z) {
      this.z = z;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getZ",
    value: function getZ() {
      return this.z;
    }
    /**
     * @param {Vector} vectorA
     * @param {Vector} vectorB
     * @return {number}
     */

  }], [{
    key: "cross",
    value: function cross(vectorA, vectorB) {
      return vectorA.x * vectorB.y - vectorA.y * vectorB.x;
    }
    /**
     * @param {Vector} vectorA
     * @param {Vector} vectorB
     * @return {Vector}
     */

  }, {
    key: "add",
    value: function add(vectorA, vectorB) {
      return {
        x: vectorA.x + vectorB.x,
        y: vectorA.y + vectorB.y,
        z: vectorA.z + vectorB.z
      };
    }
    /**
     * @param {Vector} vector
     * @param {number} value
     * @return {Vector}
     */

  }, {
    key: "multiply",
    value: function multiply(vector, value) {
      return {
        x: vector.x * value,
        y: vector.y * value,
        z: vector.z * value
      };
    }
    /**
     * @param {Vector} vector
     * @param {number} value
     * @return {Vector}
     */

  }, {
    key: "divide",
    value: function divide(vector, value) {
      return {
        x: vector.x / value,
        y: vector.y / value,
        z: vector.z / value
      };
    }
  }]);
  return Vector;
}();

var _default = Vector;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],170:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _Vector = _interopRequireDefault(require("./Vector.js"));

/**
 * Define methods to manipulate vertices
 */
var Vertex = /*#__PURE__*/function () {
  function Vertex() {
    (0, _classCallCheck2["default"])(this, Vertex);
  }

  (0, _createClass2["default"])(Vertex, null, [{
    key: "getArea",

    /**
     * @param {{x: number, y: number}[]} vertices
     */
    value: function getArea(vertices) {
      var area = 0,
          jVertex = vertices.length - 1;
      vertices.forEach(function (vertex, iVertex) {
        area += (vertices[jVertex].x - vertex.x) * (vertices[jVertex].y + vertex.y);
        jVertex = iVertex;
      });
      return area / 2;
    }
    /**
     * Calculate the centroid of the given vertices
     * @param {{x: number, y: number}[]} vertices
     */

  }, {
    key: "getCenter",
    value: function getCenter(vertices) {
      var area = this.getArea(vertices);
      var center = {
        x: 0,
        y: 0
      };
      vertices.forEach(function (vertex, iVertex) {
        var jVertex = (iVertex + 1) % vertices.length;

        var cross = _Vector["default"].cross(vertex, vertices[jVertex]);

        var multiply = _Vector["default"].multiply(_Vector["default"].add(vertex, vertices[jVertex]), cross);

        center = _Vector["default"].add(center, multiply);
      });
      return _Vector["default"].divide(center, 6 * area);
    }
    /**
     * Check if a point is inside a set of vertices
     * @param {{x: number, y: number}[]} vertices
     * @param {Vector} point
     */

  }, {
    key: "contains",
    value: function contains(vertices, point) {
      for (var iVertex = 0; iVertex < vertices.length; iVertex++) {
        var vertex = vertices[iVertex];
        var nextVertex = vertices[(iVertex + 1) % vertices.length];

        if ((point.x - vertex.x) * (nextVertex.y - vertex.y) + (vertex.x - nextVertex.x) * (point.y - vertex.y) > 0) {
          return false;
        }
      }

      return true;
    }
    /**
     * Rotate a set of vertices by the given angle and point
     * @param {{x: number, y: number}[]} vertices
     * @param {number} angleRadian
     * @param {Vector} point
     *
     * @return {{x: number, y: number}[]}
     */

  }, {
    key: "rotate",
    value: function rotate(vertices, angleRadian, point) {
      var cos = Math.cos(angleRadian);
      var sin = Math.sin(angleRadian);
      return vertices.map(function (vertex) {
        var dx = vertex.x - point.x;
        var dy = vertex.y - point.y;
        return {
          x: point.x + (dx * cos - dy * sin),
          y: point.y + (dx * sin + dy * cos)
        };
      });
    }
    /**
     * Translate a set of vertices by the given vector
     * @param {{x: number, y: number}[]} vertices
     * @param {Vector} vector
     * @param {number} sign
     */

  }, {
    key: "translate",
    value: function translate(vertices, vector) {
      var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      return vertices.map(function (vertex) {
        return {
          x: vertex.x + vector.x * sign,
          y: vertex.y + vector.y * sign
        };
      });
    }
  }]);
  return Vertex;
}();

var _default = Vertex;
exports["default"] = _default;

},{"./Vector.js":169,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],171:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _WorldData2 = _interopRequireDefault(require("../project/data/WorldData.js"));

var _EntityManager = _interopRequireDefault(require("./manager/EntityManager.js"));

var _EntitySelector = _interopRequireDefault(require("./manager/EntitySelector.js"));

var _Camera = _interopRequireDefault(require("../core/Camera.js"));

var _Physics = _interopRequireDefault(require("../physics/Physics.js"));

var _TerrainManager = _interopRequireDefault(require("./terrain/TerrainManager.js"));

var _MouseConstraintEntity = _interopRequireDefault(require("../entity/types/constraint/MouseConstraintEntity.js"));

var _Vector = _interopRequireDefault(require("../utils/Vector.js"));

var _TextureManager = _interopRequireDefault(require("./manager/TextureManager.js"));

var _Constant = require("../core/Constant.js");

var _Context = require("../core/Context.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {World}
 * @extends {WorldData}
 */
var World = /*#__PURE__*/function (_WorldData) {
  (0, _inherits2["default"])(World, _WorldData);

  var _super = _createSuper(World);

  function World() {
    var _this;

    (0, _classCallCheck2["default"])(this, World);
    _this = _super.call(this);
    _this.entityManager = new _EntityManager["default"]();
    _this.camera = new _Camera["default"]({
      x: _Constant.SCENE_WIDTH / 2,
      y: _Constant.SCENE_HEIGHT / 2
    });
    _this.physics = new _Physics["default"]();
    _this.terrainManager = new _TerrainManager["default"]();
    _this.textureManager = new _TextureManager["default"]();
    _this.mouseConstraintId = null;

    _this.init();

    return _this;
  }
  /**
   * Initialize the world. will erase also world's element from imported project
   */


  (0, _createClass2["default"])(World, [{
    key: "init",
    value: function init() {
      this.createMouseConstraint();
    }
    /**
     * Draw the entities.
     * @TODO: To optimize (rerender just entities updated)
     * @param {Renderer} renderer
     */

  }, {
    key: "draw",
    value: function draw(renderer) {
      var _this2 = this;

      var bodyEntities = this.getEntityManager().getBodyEntities();
      var attachEntities = this.getEntityManager().getAttachEntities();
      bodyEntities.forEach(function (entity) {
        return _this2.drawEntity(entity, renderer);
      });
      attachEntities.forEach(function (entity) {
        return _this2.drawEntity(entity, renderer);
      });
    }
    /**
     * Set the given entity to the renderer for drawing
     * @param {Entity} entity
     * @param {Renderer} renderer
     */

  }, {
    key: "drawEntity",
    value: function drawEntity(entity, renderer) {
      var _this$getCamera$posit = this.getCamera().position,
          cameraX = _this$getCamera$posit.x,
          cameraY = _this$getCamera$posit.y;

      var _objectContext$canvas = _Context.objectContext.canvas.getBoundingClientRect(),
          sceneCanvasX = _objectContext$canvas.left,
          sceneCanvasY = _objectContext$canvas.top;

      var minX = cameraX - _Constant.SCENE_WIDTH / 2 - entity.size.width;
      var maxX = cameraX + _Constant.SCENE_WIDTH / 2 + sceneCanvasX;
      var minY = cameraY - _Constant.SCENE_HEIGHT / 2 - entity.size.height + sceneCanvasY;
      var maxY = cameraY + _Constant.SCENE_HEIGHT / 2 + sceneCanvasY;

      if (minX <= entity.position.x && maxX >= entity.position.x && minY <= entity.position.y && maxY >= entity.position.y) {
        entity.draw(renderer);
      }
    }
    /**
     * Get the entity from world coordinate
     * @param {Vector} position canvas coordinates (window)
     * @return {Entity|null}
     */

  }, {
    key: "findEntity",
    value: function findEntity(position) {
      var entitySelector = _EntitySelector["default"].get();

      return entitySelector.get(this, this.getWorldPosition(position));
    }
    /**
     * @param {Vector} position position canvas coordinates (window)
     * @return {Entity|null}
     */

  }, {
    key: "findBodyEntity",
    value: function findBodyEntity(position) {
      var entity = this.findEntity(position);
      return this.getEntityManager().isBodyEntity(entity) && entity;
    }
    /**
     * Add an entity to the world
     * @param {Vector} position
     * @param {Class} type
     * @param {EntityProps} props
     */

  }, {
    key: "addEntity",
    value: function addEntity(position, type) {
      var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var entity = this.loadEntity(position, type, props);
      this.getPhysics().loadEntity(entity);
      return entity;
    }
    /**
     * @param {number} entityId
     */

  }, {
    key: "removeEntityById",
    value: function removeEntityById(entityId) {
      var entity = this.getEntityManager().findById(entityId);

      if (entity) {
        this.getPhysics().unloadEntity(entity);
        this.getEntityManager()["delete"](entity);
      }
    }
    /**
     * @param {Class} type
     */

  }, {
    key: "removeEntityByType",
    value: function removeEntityByType(type) {
      var _this3 = this;

      var entities = this.getEntityManager().findByType(type);
      entities.forEach(function (entity) {
        return _this3.removeEntityById(entity.id);
      });
    }
    /**
     * @param {Entity} entity
     */

  }, {
    key: "deleteEntity",
    value: function deleteEntity(entity) {
      this.getEntityManager()["delete"](entity);
    }
    /**
     * @param {Vector} position
     * @param {Entity} type
     * @param {EntityProps} props
     * @return {Entity}
     */

  }, {
    key: "loadEntity",
    value: function loadEntity(position, type) {
      var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.getEntityManager().load(this, position, type, props);
    }
    /**
     * @param {Entity} entity
     */

  }, {
    key: "generateEntity",
    value: function generateEntity(entity) {
      return this.getEntityManager().regenerate(this, entity);
    }
    /**
     * @param {Entity} entity
     */

  }, {
    key: "makeEntity",
    value: function makeEntity(entity) {
      return this.getEntityManager().make(this, entity);
    }
    /**
     * Force the regeneration of all entities (regenerate meshes)
     */

  }, {
    key: "reload",
    value: function reload() {
      this.init();
      this.getEntityManager().regenerateAll(this);
    }
    /**
     * Update entities, terrains, ... (check all entities tagged for regeneration)
     */

  }, {
    key: "update",
    value: function update() {
      this.getTerrainManager().update(this);
      this.getEntityManager().update(this);
    }
    /**
     * Update the camera position for the attached entity (if the camera must be focused on a given entity)
     */

  }, {
    key: "updateCamera",
    value: function updateCamera() {
      var entity = this.getCamera().getEntity(this.getEntityManager());
      entity && this.getCamera().update({
        x: entity.position.x,
        y: this.getCamera().position.y
      });
    }
    /**
     * Reset the camera position
     */

  }, {
    key: "resetCamera",
    value: function resetCamera() {
      this.getCamera().reset();
    }
    /**
     * Get the world position of a given screen position
     * @param {Vector} position
     * @return {Vector}
     */

  }, {
    key: "getWorldPosition",
    value: function getWorldPosition(position) {
      return this.getCamera().fromCanvasCoord(position);
    }
    /**
     * @return {Entity}
     */

  }, {
    key: "getMouseConstraint",
    value: function getMouseConstraint() {
      return this.getEntityManager().findById(this.mouseConstraintId);
    }
  }, {
    key: "createMouseConstraint",
    value: function createMouseConstraint() {
      this.removeEntityByType(_MouseConstraintEntity["default"]);
      var constraint = this.loadEntity(new _Vector["default"]({
        x: 0,
        y: 0
      }), _MouseConstraintEntity["default"]);
      constraint.setSelectable(false);
      this.mouseConstraintId = constraint.getId();
    }
    /**
     * @param {number} mouseConstraintId
     */

  }, {
    key: "setMouseConstraintId",
    value: function setMouseConstraintId(mouseConstraintId) {
      this.mouseConstraintId = mouseConstraintId;
    }
    /**
     * @return {number}
     */

  }, {
    key: "getMouseConstraintId",
    value: function getMouseConstraintId() {
      return this.mouseConstraintId;
    }
  }], [{
    key: "get",
    value: function get() {
      if (!World.instance) {
        World.instance = new World();
      }

      return World.instance;
    }
  }]);
  return World;
}(_WorldData2["default"]);

var _default = World;
exports["default"] = _default;

},{"../core/Camera.js":32,"../core/Constant.js":33,"../core/Context.js":34,"../entity/types/constraint/MouseConstraintEntity.js":48,"../physics/Physics.js":123,"../project/data/WorldData.js":149,"../utils/Vector.js":169,"./manager/EntityManager.js":173,"./manager/EntitySelector.js":174,"./manager/TextureManager.js":175,"./terrain/TerrainManager.js":177,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],172:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * EntityGenerator class.
 * Generate an entity (related to the type, make and load the meshes)
 */
var EntityGenerator = /*#__PURE__*/function () {
  function EntityGenerator() {
    (0, _classCallCheck2["default"])(this, EntityGenerator);
  }

  (0, _createClass2["default"])(EntityGenerator, null, [{
    key: "make",

    /**
     * Generate and build the Entity
     * @param {World} world
     * @param {Entity} entity
     */
    value: function make(world, entity) {
      return entity.updateStyle().build(world);
    }
  }]);
  return EntityGenerator;
}();

var _default = EntityGenerator;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],173:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _EntityGenerator = _interopRequireDefault(require("../generator/EntityGenerator.js"));

var _Entity = _interopRequireDefault(require("../../entity/Entity.js"));

var _AttachEntity = _interopRequireDefault(require("../../entity/types/constraint/AttachEntity.js"));

var _VirtualEntity = _interopRequireDefault(require("../../entity/VirtualEntity.js"));

var _Maths = _interopRequireDefault(require("../../utils/Maths.js"));

var _EntityManagerData2 = _interopRequireDefault(require("../../project/data/EntityManagerData.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Entity Manager class
 * Manage the entities list, used to manipulate the entities (get, add, load, ...)
 *
 * @property {EntityMotion[]} entities
 */
var EntityManager = /*#__PURE__*/function (_EntityManagerData) {
  (0, _inherits2["default"])(EntityManager, _EntityManagerData);

  var _super = _createSuper(EntityManager);

  function EntityManager() {
    var _this;

    (0, _classCallCheck2["default"])(this, EntityManager);
    _this = _super.call(this);
    _this.entities = [];
    return _this;
  }
  /**
   * Get an entity at (x,y)
   * @param {int} x
   * @param {int} y
   * @param {Entity} type
   * @return {Entity}
   */


  (0, _createClass2["default"])(EntityManager, [{
    key: "getAt",
    value: function getAt(x, y, type) {
      return this.entities.find(function (element) {
        return element instanceof type && element.position.x === x && element.position.y === y;
      });
    }
    /**
     * @param {Entity} entity
     */

  }, {
    key: "getIndexOf",
    value: function getIndexOf(entity) {
      return this.entities.findIndex(function (element) {
        return element instanceof entity.constructor && element.position.x === entity.position.x && element.position.y === entity.position.y;
      });
    }
    /**
     * @param {string|number} entityId
     * @return {Entity}
     */

  }, {
    key: "findById",
    value: function findById(entityId) {
      return this.entities.find(function (element) {
        return element.id === parseInt(entityId);
      });
    }
    /**
     * @param {Class} type
     * @return {Entity[]}
     */

  }, {
    key: "findByType",
    value: function findByType(type) {
      return this.entities.filter(function (element) {
        return element instanceof type;
      });
    }
    /**
     * Get an entity if founded, else create it
     * @param {int} x
     * @param {int} y
     * @param {Entity} type
     * @param {Object} defaultProps
     * @return {Entity}
     */

  }, {
    key: "get",
    value: function get(x, y, type) {
      var defaultProps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (!(type.prototype instanceof _Entity["default"])) {
        throw new TypeError("type must be child of Entity class (".concat(type, " given)"));
      }

      var entity = this.getAt(x, y, type);

      if (!entity) {
        var name = "Layer ".concat(this.entities.length);
        var props = Object.assign({
          position: {
            x: x,
            y: y
          },
          name: name
        }, defaultProps);
        var element = new type(props);
        this.entities.push(element);
      }

      return this.getAt(x, y, type);
    }
    /**
     * Regenerate the mesh of all entities
     * NB: The local variable entities must be a copy of this.entities, and the loop forEach must be based
     * on that copy, because the regenerate method may remove elements in this.entities if is not valid,
     * and will have a side effect on the loop forEach
     * @param {World} world
     */

  }, {
    key: "regenerateAll",
    value: function regenerateAll(world) {
      this.entities.forEach(function (entity) {
        return entity.setGenerated(false);
      });
      this.update(world);
    }
    /**
     * Load and generate an entity
     * @param {World} world
     * @param {Vector} position
     * @param {Entity} type
     * @param {Object} props
     * @return {Entity}
     */

  }, {
    key: "load",
    value: function load(world, position, type) {
      var props = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var x = position.x,
          y = position.y;
      var entity = this.get(x, y, type, props);

      if (!entity.isBuffered) {
        this.make(world, entity);
      }

      return entity;
    }
    /**
     * @param {EntityMotion} entity
     */

  }, {
    key: "add",
    value: function add(entity) {
      this.entities.push(entity);
    }
    /**
     * Delete entity from the entities list
     * @param {Entity} entity
     */

  }, {
    key: "deleteEntity",
    value: function deleteEntity(entity) {
      return this.entities.splice(this.getIndexOf(entity), 1);
    }
    /**
     * Delete the given entity and all related AttachEntity
     * @param {Entity} entity
     */

  }, {
    key: "delete",
    value: function _delete(entity) {
      var _this2 = this;

      this.getAllAttachTypeEntity(entity).map(function (pEntity) {
        return _this2.deleteEntity(pEntity);
      });
      this.deleteEntity(entity);
    }
    /**
     * Delete the given entity and all related AttachEntity (by Id)
     * @param {number} entityId
     */

  }, {
    key: "deleteById",
    value: function deleteById(entityId) {
      var entity = this.findById(entityId);
      this["delete"](entity);
    }
    /**
     * Clone entity to the entities list
     * @param {Entity} entity
     * @param {Object} options
     */

  }, {
    key: "clone",
    value: function clone(entity) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cloneEntity = entity.clone();
      cloneEntity.name = "Clone of ".concat(entity.name);
      cloneEntity.id = _Maths["default"].generateId();
      options.sameWorld && (cloneEntity.worldId = entity.id);
      return cloneEntity;
    }
    /**
     * check if the entity and all attached entities must dies
     * @param {Entity} entity
     * @param {PhysicsEngine} physicsEngine
     */

  }, {
    key: "haveToDie",
    value: function haveToDie(entity, physicsEngine) {
      var _this3 = this;

      var attachedEntities = entity.getAttachedEntities(this);
      entity.haveToDie(physicsEngine);

      if (entity.isDead()) {
        attachedEntities.forEach(function (aEntity) {
          return _this3.isBodyEntity(aEntity) && aEntity.setDie(true);
        });
      }
    }
    /**
     * Clone given entities.
     * Manage cloning attach and body entities
     * @param {Entity[]} entities
     * @param {Object} options
     * @todo think to optimize the clone process
     */

  }, {
    key: "cloneEntities",
    value: function cloneEntities(entities) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var bodyEntities = this.getBodyEntities(entities).filter(function (entity) {
        return entity.clonable;
      });
      var attachEntities = this.getAttachEntities(entities).filter(function (entity) {
        return entity.clonable;
      });
      var cloneBodyEntities = bodyEntities.map(function (entity) {
        return _this4.clone(entity);
      });
      var cloneAttachEntities = attachEntities.map(function (entity) {
        return _this4.clone(entity);
      });
      attachEntities.forEach(function (attachEntity, attachIndex) {
        var cloneAttachEntity = cloneAttachEntities[attachIndex];
        var bodyEntityA = attachEntity.entities.a;
        var bodyEntityB = attachEntity.entities.b;
        var bodyIndexA = bodyEntities.findIndex(function (body) {
          return bodyEntityA === body;
        });
        var bodyIndexB = bodyEntities.findIndex(function (body) {
          return bodyEntityB === body;
        });
        var cloneEntityA = bodyIndexA >= 0 && cloneBodyEntities[bodyIndexA];
        var cloneEntityB = bodyIndexB >= 0 && cloneBodyEntities[bodyIndexB];

        if (!cloneEntityA && bodyEntityA) {
          cloneEntityA = _this4.clone(bodyEntityA, options);
          cloneBodyEntities.push(cloneEntityA);
        }

        if (!cloneEntityB && bodyEntityB) {
          cloneEntityB = _this4.clone(bodyEntityB);
          cloneBodyEntities.push(cloneEntityB);
        }

        cloneAttachEntity.entities.a = cloneEntityA;
        cloneAttachEntity.entities.b = cloneEntityB;
      });
      return cloneBodyEntities.concat(cloneAttachEntities);
    }
    /**
     * Concat entities
     * @param {Entity[]} entities
     */

  }, {
    key: "concatEntities",
    value: function concatEntities(entities) {
      this.entities = this.entities.concat(entities);
    }
    /**
     * Replace entities
     * @param {Entity[]} entities
     */

  }, {
    key: "replaceEntities",
    value: function replaceEntities(entities) {
      this.entities = entities;
    }
    /**
     * Make an entity.
     * @param {World} world
     * @param {Entity} entity
     */

  }, {
    key: "make",
    value: function make(world, entity) {
      return _EntityGenerator["default"].make(world, entity);
    }
    /**
     * Regenerate the given entity and delete if not valid
     * @param {World} world
     * @param {Entity} entity
     */

  }, {
    key: "regenerate",
    value: function regenerate(world, entity) {
      entity.regenerate(world);
    }
    /**
     * Update the Mesh for all entities
     * @param {World} world
     */

  }, {
    key: "update",
    value: function update(world) {
      this.entities.forEach(function (entity) {
        if (!entity.isGenerated()) {
          entity.setGenerated(true);
          entity.updateTexture(world);
          entity.regenerate(world);
        }

        entity.addToBuffer(world);
      });
    }
    /**
     * Move an entity up (z-index)
     * @param {Entity} entity
     */

  }, {
    key: "moveUp",
    value: function moveUp(entity) {
      this.moveIndex(entity, 1);
    }
    /**
     * Move an entity down (z-index)
     * @param {Entity} entity
     */

  }, {
    key: "moveDown",
    value: function moveDown(entity) {
      this.moveIndex(entity, 0);
    }
    /**
     * Lock entity for modification
     * @param {Entity} entity
     */

  }, {
    key: "lock",
    value: function lock(entity) {
      this.lockEntity(entity, true);
    }
    /**
     * Unlock entity for modification
     * @param {Entity} entity
     */

  }, {
    key: "unlock",
    value: function unlock(entity) {
      this.lockEntity(entity, false);
    }
    /**
     * Hide the given entity
     * @param {Entity} entity
     */

  }, {
    key: "hide",
    value: function hide(entity) {
      entity.show(false);
    }
    /**
     * Show the given entity
     * @param {Entity} entity
     */

  }, {
    key: "show",
    value: function show(entity) {
      entity.show(true);
    }
    /**
     * Replace entities by the given list
     * @param {Entity[]} entities
     */

  }, {
    key: "replace",
    value: function replace(entities) {
      this.entities = entities;
    }
    /**
     * Move the index of an entity up/down.
     * NB: The first element in the list is always the Platform Entity.
     * @param {Entity} entity
     * @param {Boolean} up (1 = UP, 0 = DOWN)
     */

  }, {
    key: "moveIndex",
    value: function moveIndex(entity, up) {
      var entities = this.getBodyEntities();
      var index = entities.findIndex(function (pEntity) {
        return pEntity === entity;
      });

      if (index < entities.length - 1 && up || index > 1) {
        var newIndex = up ? index + 1 : index - 1;
        this.permutEntity(entity, entities[newIndex]);
      }
    }
    /**
     * Permute two entities
     * @param {Entity} entityA
     * @param {Entity} entityB
     */

  }, {
    key: "permutEntity",
    value: function permutEntity(entityA, entityB) {
      var indexA = this.entities.findIndex(function (pEntity) {
        return pEntity === entityA;
      });
      var indexB = this.entities.findIndex(function (pEntity) {
        return pEntity === entityB;
      });

      if (indexA >= 0 && indexB >= 0 && !entityB.selected) {
        this.entities[indexA] = entityB;
        this.entities[indexB] = entityA;
      }
    }
    /**
     * Lock/Unlock the given entity and all attached type entities
     * @param {Entity} entity
     * @param {Boolean} lock
     */

  }, {
    key: "lockEntity",
    value: function lockEntity(entity, lock) {
      var _this5 = this;

      this.getAllAttachTypeEntity(entity).map(function (pEntity) {
        return _this5.lockEntity(pEntity, lock);
      });
      entity.lock(lock);
    }
    /**
     * Get valid entities (not in loading mode, ...)
     */

  }, {
    key: "getValidEntities",
    value: function getValidEntities() {
      return this.entities.filter(function (entity) {
        return entity.isValid();
      });
    }
    /**
     * Is the given entity is a body type
     * @param {Entity} entity
     */

  }, {
    key: "isBodyEntity",
    value: function isBodyEntity(entity) {
      return !(entity instanceof _AttachEntity["default"]) && !(entity instanceof _VirtualEntity["default"]);
    }
    /**
     * Is the given entity is an attach type
     * @param {Entity} entity
     */

  }, {
    key: "isAttachEntity",
    value: function isAttachEntity(entity) {
      return entity instanceof _AttachEntity["default"];
    }
    /**
     * Is the given entity is not static
     * @param {EntityMotion} entity
     */

  }, {
    key: "isNotStaticEntity",
    value: function isNotStaticEntity(entity) {
      return !entity.isFixed() && !entity.isControlled();
    }
    /**
     * Get all entities of specific type
     * @param {Entity} type
     */

  }, {
    key: "getEntitiesAs",
    value: function getEntitiesAs(type) {
      return this.entities.filter(function (entity) {
        return entity instanceof type;
      });
    }
    /**
     * Get all entities does not of specific type
     * @param {Entity} type
     */

  }, {
    key: "getEntitiesNotAs",
    value: function getEntitiesNotAs(type) {
      return this.entities.filter(function (entity) {
        return !(entity instanceof type);
      });
    }
    /**
     * Get attached entities (bidirectional).
     * PS: The list include the given entity
     * @param {Entity} entity
     * @param {Entity[]} exculdeEntities
     */

  }, {
    key: "getAttachedEntities",
    value: function getAttachedEntities(entity) {
      var _this6 = this;

      var exculdeEntities = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var attachedEntities = [entity];
      this.getAllAttachTypeEntity(entity).forEach(function (attachEntity) {
        attachedEntities.push(attachEntity);

        for (var kEntity in attachEntity.entities) {
          var entityAB = attachEntity.entities[kEntity];

          if (entityAB !== entity && !exculdeEntities.includes(entityAB)) {
            attachedEntities = attachedEntities.concat(_this6.getAttachedEntities(entityAB, attachedEntities));
          }
        }
      });
      return _.uniq(attachedEntities);
    }
    /**
     * Get all Attach entities for the given entity and type
     * @param {Entity} entity
     */

  }, {
    key: "getAllAttachTypeEntity",
    value: function getAllAttachTypeEntity(entity) {
      return this.getAttachEntities().filter(function (pEntity) {
        return pEntity.entities.a === entity || pEntity.entities.b === entity;
      });
    }
    /**
     * Get active entities
     */

  }, {
    key: "getActiveEntities",
    value: function getActiveEntities() {
      return this.entities.filter(function (entity) {
        return entity.isActive();
      });
    }
    /**
     * Get entities of type body
     * @param {Entity[]} entities
     */

  }, {
    key: "getBodyEntities",
    value: function getBodyEntities() {
      var _this7 = this;

      var entities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return (entities || this.entities).filter(function (entity) {
        return _this7.isBodyEntity(entity);
      });
    }
    /**
     * Get entities of type attach
     * @param {Entity[]} entities
     */

  }, {
    key: "getAttachEntities",
    value: function getAttachEntities() {
      var _this8 = this;

      var entities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return (entities || this.entities).filter(function (entity) {
        return _this8.isAttachEntity(entity);
      });
    }
    /**
     * Get dynamic entities (not static, like platform, ...)
     * @param {EntityMotion[]} entities
     * @return {EntityMotion[]}
     */

  }, {
    key: "getDynamicEntities",
    value: function getDynamicEntities() {
      var _this9 = this;

      var entities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return (entities || this.entities).filter(function (entity) {
        return _this9.isNotStaticEntity(entity);
      });
    }
    /**
     * Get valid entities of type body
     * @return {Entity[]}
     */

  }, {
    key: "getValidBodyEntities",
    value: function getValidBodyEntities() {
      return this.getBodyEntities().filter(function (entity) {
        return entity.isValid();
      });
    }
    /**
     * Disable collision for not static entities
     */

  }, {
    key: "disableCollision",
    value: function disableCollision() {
      this.getDynamicEntities().map(function (entity) {
        return entity.setCollisionGroup(-1);
      });
    }
  }]);
  return EntityManager;
}(_EntityManagerData2["default"]);

var _default = EntityManager;
exports["default"] = _default;

},{"../../entity/Entity.js":42,"../../entity/VirtualEntity.js":44,"../../entity/types/constraint/AttachEntity.js":45,"../../project/data/EntityManagerData.js":142,"../../utils/Maths.js":165,"../generator/EntityGenerator.js":172,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],174:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var EntitySelector = /*#__PURE__*/function () {
  function EntitySelector() {
    (0, _classCallCheck2["default"])(this, EntitySelector);
    this.entities = [];
  }
  /**
   * Get all entities selected
   * @param {World} world
   */


  (0, _createClass2["default"])(EntitySelector, [{
    key: "getSelected",
    value: function getSelected(world) {
      return world.getEntityManager().entities.filter(function (entity) {
        return entity.isSelected();
      });
    }
    /**
     * Get first entity selected
     * @param {World} world
     */

  }, {
    key: "getFirstSelected",
    value: function getFirstSelected(world) {
      var selectedEntities = this.getSelected(world);

      if (selectedEntities.length) {
        return selectedEntities[0];
      }

      return null;
    }
    /**
     * Get the entity in a specific point (absolute position)
     * @param {World} world
     * @param {Object} point
     * @param {Entity} exceptType
     */

  }, {
    key: "get",
    value: function get(world, point) {
      var exceptType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var entities = this.getAll(world, point, exceptType);
      return entities.length && entities[entities.length - 1];
    }
    /**
     * Get all entities in a specific point (absolute position)
     * @param {World} world
     * @param {Object} point
     * @param {Entity} exceptType
     */

  }, {
    key: "getAll",
    value: function getAll(world, point) {
      var exceptType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return world.getEntityManager().getActiveEntities().filter(function (entity) {
        return entity.includes(point) && entity.isSelectable() && (!exceptType || !(entity instanceof exceptType));
      });
    }
    /**
     * Get all entities inside a selected area
     * @param {World} world
     * @param {Object} point
     * @param {Object} size
     */

  }, {
    key: "getInsideArea",
    value: function getInsideArea(world, point, size) {
      return world.getEntityManager().getActiveEntities().filter(function (entity) {
        return entity.selectable && entity.position.x >= point.x && entity.position.x + entity.size.width <= point.x + size.width && entity.position.y >= point.y && entity.position.y + entity.size.height <= point.y + size.height;
      });
    }
    /**
     * Select all entities inside the area of selection
     * @param {World} world
     * @param {Object} point
     * @param {Object} size
     * @param {Boolean} includeAttach
     */

  }, {
    key: "select",
    value: function select(world, point, size) {
      var includeAttach = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var selectedEntities = [];

      if (!size || !size.width && !size.height) {
        var selectedEntity = this.get(world, point);

        if (selectedEntity) {
          if (includeAttach) {
            selectedEntities = selectedEntities.concat(selectedEntity.getAttachedEntities(world.getEntityManager()));
          } else {
            selectedEntities.push(selectedEntity);
          }
        }
      } else {
        selectedEntities = this.getInsideArea(world, point, size);
      }

      return selectedEntities.map(function (selectedEntity) {
        return selectedEntity.isActive() && selectedEntity.select();
      });
    }
    /**
     * Unselect all entities
     * @param {World} world
     */

  }, {
    key: "unselectAll",
    value: function unselectAll(world) {
      world.getEntityManager().entities.map(function (entity) {
        return entity.unselect();
      });
    }
    /**
     * Unfocus all entities.
     * Do not unfocus entity in loading mode
     * @param {World} world
     */

  }, {
    key: "unfocusAll",
    value: function unfocusAll(world) {
      world.getEntityManager().getActiveEntities().map(function (entity) {
        return entity.unfocus();
      });
    }
    /**
     * focus all entities in a given point.
     * Do not focus entity in loading mode
     * @param {World} world
     * @param {Vector} point
     */

  }, {
    key: "focus",
    value: function focus(world, point) {
      this.getAll(world, point).map(function (entity) {
        return entity.focus();
      });
    }
  }], [{
    key: "get",
    value: function get() {
      if (!EntitySelector.instance) {
        EntitySelector.instance = new EntitySelector();
      }

      return EntitySelector.instance;
    }
  }]);
  return EntitySelector;
}();

EntitySelector.instance = null;
var _default = EntitySelector;
exports["default"] = _default;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],175:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Texture = _interopRequireDefault(require("../../core/Texture.js"));

var _TextureManagerData2 = _interopRequireDefault(require("../../project/data/TextureManagerData.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @class {TextureManager}
 * @extends {TextureManagerData}
 */
var TextureManager = /*#__PURE__*/function (_TextureManagerData) {
  (0, _inherits2["default"])(TextureManager, _TextureManagerData);

  var _super = _createSuper(TextureManager);

  function TextureManager() {
    var _this;

    (0, _classCallCheck2["default"])(this, TextureManager);
    _this = _super.call(this);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "textures", void 0);
    _this.textures = [];
    return _this;
  }
  /**
   * @param {string} image
   */


  (0, _createClass2["default"])(TextureManager, [{
    key: "setTexture",
    value: function () {
      var _setTexture = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(image) {
        var texture;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                texture = new _Texture["default"]();
                _context.next = 3;
                return texture.load(image);

              case 3:
                if (!_context.sent) {
                  _context.next = 5;
                  break;
                }

                this.textures.push(texture);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setTexture(_x) {
        return _setTexture.apply(this, arguments);
      }

      return setTexture;
    }()
    /**
     * @return {null}
     */

  }, {
    key: "getTexture",
    value: function getTexture() {
      return null;
    }
    /**
     * @return {Texture}
     */

  }, {
    key: "getSelectedTexture",
    value: function getSelectedTexture() {
      return this.getTextures().find(function (texture) {
        return texture.isSelected();
      });
    }
    /**
     * @param {number|string} textureId
     * @return {Texture | null}
     */

  }, {
    key: "findById",
    value: function findById(textureId) {
      return this.textures.find(function (texture) {
        return texture.id === parseInt(textureId);
      });
    }
  }]);
  return TextureManager;
}(_TextureManagerData2["default"]);

var _default = TextureManager;
exports["default"] = _default;

},{"../../core/Texture.js":40,"../../project/data/TextureManagerData.js":148,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17,"@babel/runtime/regenerator":25}],176:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _VirtualEntity = _interopRequireDefault(require("../../entity/VirtualEntity.js"));

var _TerrainData2 = _interopRequireDefault(require("../../project/data/TerrainData.js"));

var _ObjectHelper = _interopRequireDefault(require("../../utils/ObjectHelper.js"));

var _Constant = require("../../core/Constant.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Terrain class
 * Define and generate terrains
 * @class {Terrain}
 * @extends {TerrainData}
 * @abstract
 *
 * @property {number[]} chunkIds
 * @property {Vector} position
 * @property {number} entityId
 */
var Terrain = /*#__PURE__*/function (_TerrainData) {
  (0, _inherits2["default"])(Terrain, _TerrainData);

  var _super = _createSuper(Terrain);

  function Terrain() {
    var _this;

    (0, _classCallCheck2["default"])(this, Terrain);
    _this = _super.call(this);
    _this.entityId = null;
    _this.size = {
      width: _Constant.SCENE_WIDTH,
      height: 300
    };
    _this.chunksNbr = 3;
    _this.chunkIds = [];
    return _this;
  }
  /**
   * Initialize data
   * @param {World} world
   */


  (0, _createClass2["default"])(Terrain, [{
    key: "init",
    value: function init(world) {
      if (!this.entityId) {
        this.entityId = world.addEntity({
          x: 0,
          y: 650
        }, _VirtualEntity["default"], {
          name: 'Terrain',
          size: this.size,
          noiseConfigs: {
            seed: 1234,
            octaves: 9,
            amplitude: 80,
            persistence: 0.51,
            smoothness: 250
          }
        }).getId();
      }
    }
    /**
     * Load the terrain
     * @param {World} world
     */

  }, {
    key: "load",
    value: function load(world) {
      this.init(world);
      this.loadChunks(world);
    }
    /**
     * @abstract
     * @param {World} world
     * @param {number} x
     * @param {number} y
     * @param {EntityProps} props
     * @return {Entity}
     */

  }, {
    key: "loadChunk",
    value: function loadChunk(world, x, y, props) {
      throw new TypeError('loadChunks must be implemented');
    }
    /**
     * Unload the terrain
     * @param {World} world
     */

  }, {
    key: "unload",
    value: function unload(world) {
      this.removeChunks(world);
      world.removeEntityById(this.entityId);
    }
    /**
     * @param {number} entityId
     * @param {World} world
     * @return {Entity}
     */

  }, {
    key: "getEntityById",
    value: function getEntityById(world, entityId) {
      return world.getEntityManager().findById(entityId);
    }
    /**
     * @param {World} world
     * @return {Entity}
     */

  }, {
    key: "getEntity",
    value: function getEntity(world) {
      return this.getEntityById(world, this.entityId);
    }
    /**
     * Create and load chunks by camera position
     * @param {World} world
     */

  }, {
    key: "loadChunks",
    value: function loadChunks(world) {
      var _this2 = this;

      var camera = world.getCamera();
      var entity = this.getEntity(world);

      if (entity) {
        var chunkIds = Array.from(Array(this.chunksNbr).keys()).map(function (iChunk) {
          var x = Math.floor(camera.position.x / entity.getWidth()) + (iChunk - 1);

          var chunk = _this2.loadChunk(world, x * entity.getWidth() + entity.getPositionX(), entity.getPositionY(), {
            size: {
              width: entity.getWidth(),
              height: entity.getHeight()
            },
            noiseConfigs: _.clone(entity.noiseConfigs)
          });

          chunk.setSubEntity(true);
          return chunk.getId();
        });
        this.chunkIds.filter(function (entityId) {
          return !chunkIds.includes(entityId);
        }).forEach(function (entityId) {
          return world.removeEntityById(entityId);
        });
        this.chunkIds = chunkIds;
        this.updateChunks(world);
      }
    }
    /**
     * Update all chunks (background, size, ...)
     * @param {World} world
     */

  }, {
    key: "updateChunks",
    value: function updateChunks(world) {
      var _this3 = this;

      this.chunkIds.forEach(function (entityId) {
        var chunkEntity = _this3.getEntityById(world, entityId);

        var entity = _this3.getEntity(world);

        if (entity.getTextureId() !== chunkEntity.getTextureId()) {
          chunkEntity.setTextureId(entity.getTextureId());
        }

        if (entity.isBackgroundImageRepeat() !== chunkEntity.isBackgroundImageRepeat()) {
          chunkEntity.setBackgroundImageRepeat(entity.isBackgroundImageRepeat());
        }

        if (!_ObjectHelper["default"].isEqual(entity.size, chunkEntity.size) || !_ObjectHelper["default"].isEqual(entity.noiseConfigs, chunkEntity.noiseConfigs)) {
          _this3.removeChunk(world, entityId);
        }
      });
    }
    /**
     * Remove all chunks from the world
     * @param {World} world
     */

  }, {
    key: "removeChunks",
    value: function removeChunks(world) {
      this.chunkIds.forEach(function (entityId) {
        return world.removeEntityById(entityId);
      });
    }
    /**
     * Remove the given chunk ID
     * @param {World} world
     * @param {number} chunkId
     */

  }, {
    key: "removeChunk",
    value: function removeChunk(world, chunkId) {
      world.removeEntityById(chunkId);
    }
  }]);
  return Terrain;
}(_TerrainData2["default"]);

var _default = Terrain;
exports["default"] = _default;

},{"../../core/Constant.js":33,"../../entity/VirtualEntity.js":44,"../../project/data/TerrainData.js":145,"../../utils/ObjectHelper.js":167,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],177:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _PlainTerrain = _interopRequireDefault(require("./types/PlainTerrain.js"));

var _NoiseTerrain = _interopRequireDefault(require("./types/NoiseTerrain.js"));

var _TerrainManagerData2 = _interopRequireDefault(require("../../project/data/TerrainManagerData.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Manage all terrains
 * @class {TerrainManager}
 * @extends {TerrainManagerData}
 *
 * @property {Object.<string, Terrain>} terrainTypes
 * @property {Terrain} terrain
 */
var TerrainManager = /*#__PURE__*/function (_TerrainManagerData) {
  (0, _inherits2["default"])(TerrainManager, _TerrainManagerData);

  var _super = _createSuper(TerrainManager);

  function TerrainManager() {
    var _this;

    (0, _classCallCheck2["default"])(this, TerrainManager);
    _this = _super.call(this);
    _this.terrains = [];

    _this.init();

    return _this;
  }
  /**
   * Initialize data
   */


  (0, _createClass2["default"])(TerrainManager, [{
    key: "init",
    value: function init() {
      var _this$terrainTypes;

      this.terrainTypes = (_this$terrainTypes = {}, (0, _defineProperty2["default"])(_this$terrainTypes, TerrainManager.TYPES.PLAIN, _PlainTerrain["default"]), (0, _defineProperty2["default"])(_this$terrainTypes, TerrainManager.TYPES.NOISE, _NoiseTerrain["default"]), _this$terrainTypes);
    }
    /**
     * @param {World} world
     */

  }, {
    key: "update",
    value: function update(world) {
      this.unload(world);
      this.load(world);
    }
    /**
     * @param {World} world
     */

  }, {
    key: "load",
    value: function load(world) {
      var terrain = this.getTerrain();
      terrain && terrain.load(world);
    }
    /**
     * @param {World} world
     */

  }, {
    key: "unload",
    value: function unload(world) {
      var terrain = this.getTerrain();
      this.getTerrains().filter(function (pTerrain) {
        return pTerrain !== terrain;
      }).forEach(function (pTerrain) {
        return pTerrain && pTerrain.unload(world);
      });
      this.setTerrains([terrain]);
    }
    /**
     * @return {Object.<string, Terrain>}
     */

  }, {
    key: "getTerrainTypes",
    value: function getTerrainTypes() {
      return this.terrainTypes;
    }
    /**
     * @param {Object.<string, Terrain>} types
     */

  }, {
    key: "setTerrainTypes",
    value: function setTerrainTypes(types) {
      this.terrainTypes = types;
    }
    /**
     * @param {string} type
     */

  }, {
    key: "setTerrainType",
    value: function setTerrainType(type) {
      var terrain = this.terrainTypes[type];

      if (terrain) {
        this.terrains.push(new terrain());
      } else {
        this.terrains.push(null);
      }
    }
    /**
     * @return {string}
     */

  }, {
    key: "getTerrainType",
    value: function getTerrainType() {
      var terrain = this.getTerrain();

      for (var tType in this.terrainTypes) {
        if (this.terrainTypes.hasOwnProperty(tType)) {
          if (terrain instanceof this.terrainTypes[tType]) {
            return tType;
          }
        }
      }
    }
    /**
     * @return {Terrain}
     */

  }, {
    key: "getTerrain",
    value: function getTerrain() {
      return this.terrains.length && this.terrains[this.terrains.length - 1];
    }
  }], [{
    key: "TYPES",
    get: function get() {
      return {
        PLAIN: 'plain',
        NOISE: 'noise'
      };
    }
  }]);
  return TerrainManager;
}(_TerrainManagerData2["default"]);

var _default = TerrainManager;
exports["default"] = _default;

},{"../../project/data/TerrainManagerData.js":146,"./types/NoiseTerrain.js":178,"./types/PlainTerrain.js":179,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],178:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Terrain2 = _interopRequireDefault(require("../Terrain.js"));

var _NoiseEntity = _interopRequireDefault(require("../../../entity/types/terrain/NoiseEntity.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Manage and generate noise terrains
 * @property {number[]} chunkIds
 */
var NoiseTerrain = /*#__PURE__*/function (_Terrain) {
  (0, _inherits2["default"])(NoiseTerrain, _Terrain);

  var _super = _createSuper(NoiseTerrain);

  function NoiseTerrain() {
    (0, _classCallCheck2["default"])(this, NoiseTerrain);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(NoiseTerrain, [{
    key: "loadChunk",

    /**
     * @override
     */
    value: function loadChunk(world, x, y, props) {
      return world.addEntity({
        x: x,
        y: y
      }, _NoiseEntity["default"], props);
    }
  }]);
  return NoiseTerrain;
}(_Terrain2["default"]);

var _default = NoiseTerrain;
exports["default"] = _default;

},{"../../../entity/types/terrain/NoiseEntity.js":53,"../Terrain.js":176,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],179:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _Terrain2 = _interopRequireDefault(require("../Terrain.js"));

var _PlatformEntity = _interopRequireDefault(require("../../../entity/types/terrain/PlatformEntity.js"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Manage and generate plain terrains
 */
var PlainTerrain = /*#__PURE__*/function (_Terrain) {
  (0, _inherits2["default"])(PlainTerrain, _Terrain);

  var _super = _createSuper(PlainTerrain);

  function PlainTerrain() {
    (0, _classCallCheck2["default"])(this, PlainTerrain);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(PlainTerrain, [{
    key: "loadChunk",

    /**
     * @override
     */
    value: function loadChunk(world, x, y, props) {
      return world.addEntity({
        x: x,
        y: y
      }, _PlatformEntity["default"], props);
    }
  }]);
  return PlainTerrain;
}(_Terrain2["default"]);

var _default = PlainTerrain;
exports["default"] = _default;

},{"../../../entity/types/terrain/PlatformEntity.js":54,"../Terrain.js":176,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":17}],180:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _Application = _interopRequireDefault(require("../app/core/Application.js"));

var _RunGame = _interopRequireDefault(require("../app/loop/RunGame.js"));

new _Application["default"]([_RunGame["default"]]).start();

},{"../app/core/Application.js":31,"../app/loop/RunGame.js":121,"@babel/runtime/helpers/interopRequireDefault":12}]},{},[180]);
